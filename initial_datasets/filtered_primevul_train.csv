func,target,cwe,project,commit_id,hash,size,message
"int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)
{
  char **atimes, **aranges = NULL;
  int numtimes=0,i=0,numranges=0;
  size_t buffer_size = 512;
  char buffer[512], bufferTmp[512];

  buffer[0] = '\0';
  bufferTmp[0] = '\0';

   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
   /* discrete time */
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) { /* discrete time */
    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);
  } else {

    /* multiple times, or ranges */
    atimes = msStringSplit (timestring, ',', &numtimes);
    if (atimes == NULL || numtimes < 1)
      return MS_FALSE;

    strlcat(buffer, ""("", buffer_size);
    for(i=0; i<numtimes; i++) {
      if(i!=0) {
        strlcat(buffer, "" OR "", buffer_size);
      }
      strlcat(buffer, ""("", buffer_size);
      aranges = msStringSplit(atimes[i],  '/', &numranges);
      if(!aranges) return MS_FALSE;
      if(numranges == 1) {
        /* we don't have range, just a simple time */
        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else if(numranges == 2) {
        /* we have a range */
        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else {
        return MS_FALSE;
      }
      msFreeCharArray(aranges, numranges);
      strlcat(buffer, "")"", buffer_size);
    }
    strlcat(buffer, "")"", buffer_size);
    msFreeCharArray(atimes, numtimes);
  }
  if(!*buffer) {
    return MS_FALSE;
  }
  if(lp->filteritem) free(lp->filteritem);
  lp->filteritem = msStrdup(timefield);
  if (&lp->filter) {
    /* if the filter is set and it's a string type, concatenate it with
       the time. If not just free it */
    if (lp->filter.type == MS_EXPRESSION) {
      snprintf(bufferTmp, buffer_size, ""(%s) and %s"", lp->filter.string, buffer);
      loadExpressionString(&lp->filter, bufferTmp);
    } else {
      freeExpression(&lp->filter);
      loadExpressionString(&lp->filter, buffer);
    }
  }


  return MS_TRUE;
}
",1,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,92160701703090280340745521839872003209,,
"		void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx == """") {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str());
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
			std::string oname = ""floorplan"";
			if (result[0][0].size() > 10)
			{
				if (result[0][0][0] == 'P')
					oname += "".png"";
				else if (result[0][0][0] == -1)
					oname += "".jpg"";
				else if (result[0][0][0] == 'B')
					oname += "".bmp"";
				else if (result[0][0][0] == 'G')
					oname += "".gif"";
			}
			reply::add_header_attachment(&rep, oname);
		}
",1,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,126919339259422647630024323951648713830,,
"arcCircleCenter(const pointObj *p1, const pointObj *p2, const pointObj *p3, pointObj *center, double *radius)
{
  pointObj c;
  double r;

  /* Components of the matrices. */
  double x1sq = p1->x * p1->x;
  double x2sq = p2->x * p2->x;
  double x3sq = p3->x * p3->x;
  double y1sq = p1->y * p1->y;
  double y2sq = p2->y * p2->y;
  double y3sq = p3->y * p3->y;
  double matrix_num_x[9];
  double matrix_num_y[9];
  double matrix_denom[9];

  /* Intialize matrix_num_x */
  matrix_num_x[0] = x1sq+y1sq;
  matrix_num_x[1] = p1->y;
  matrix_num_x[2] = 1.0;
  matrix_num_x[3] = x2sq+y2sq;
  matrix_num_x[4] = p2->y;
  matrix_num_x[5] = 1.0;
  matrix_num_x[6] = x3sq+y3sq;
  matrix_num_x[7] = p3->y;
  matrix_num_x[8] = 1.0;

  /* Intialize matrix_num_y */
  matrix_num_y[0] = p1->x;
  matrix_num_y[1] = x1sq+y1sq;
  matrix_num_y[2] = 1.0;
  matrix_num_y[3] = p2->x;
  matrix_num_y[4] = x2sq+y2sq;
  matrix_num_y[5] = 1.0;
  matrix_num_y[6] = p3->x;
  matrix_num_y[7] = x3sq+y3sq;
  matrix_num_y[8] = 1.0;

  /* Intialize matrix_denom */
  matrix_denom[0] = p1->x;
  matrix_denom[1] = p1->y;
  matrix_denom[2] = 1.0;
  matrix_denom[3] = p2->x;
  matrix_denom[4] = p2->y;
  matrix_denom[5] = 1.0;
  matrix_denom[6] = p3->x;
  matrix_denom[7] = p3->y;
  matrix_denom[8] = 1.0;

  /* Circle is closed, so p2 must be opposite p1 & p3. */
  if ( FP_EQ(p1->x,p3->x) && FP_EQ(p1->y,p3->y) ) {
    c.x = (p1->x + p2->x) / 2.0;
    c.y = (p1->y + p2->y) / 2.0;
    r = sqrt( (p1->x - p2->x) * (p1->x - p2->x) + (p1->y - p2->y) * (p1->y - p2->y) ) / 2.0;
  }
  /* There is no circle here, the points are actually co-linear */
  else if ( arcSegmentSide(p1, p3, p2) == FP_COLINEAR ) {
    return MS_FAILURE;
  }
  /* Calculate the center and radius. */
  else {
    double denom = 2.0 * arcDeterminant3x3(matrix_denom);
    /* Center components */
    c.x = arcDeterminant3x3(matrix_num_x) / denom;
    c.y = arcDeterminant3x3(matrix_num_y) / denom;

    /* Radius */
    r = sqrt((p1->x-c.x) * (p1->x-c.x) + (p1->y-c.y) * (p1->y-c.y));
  }

  if ( radius ) *radius = r;
  if ( center ) *center = c;

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,294238668053508798623271778623300135355,,
"arcDeterminant3x3(double *m)
{
  /* This had better be a 3x3 matrix or we'll fall to bits */
  return m[0] * ( m[4] * m[8] - m[7] * m[5] ) -
         m[3] * ( m[1] * m[8] - m[7] * m[2] ) +
         m[6] * ( m[1] * m[5] - m[4] * m[2] );
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,168331348892364584343097707953702155644,,
"arcSegmentSide(const pointObj *p1, const pointObj *p2, const pointObj *q)
{
  double side = ( (q->x - p1->x) * (p2->y - p1->y) - (p2->x - p1->x) * (q->y - p1->y) );
  if ( FP_EQ(side,0.0) ) {
    return FP_COLINEAR;
  } else {
    if ( side < 0.0 )
      return FP_LEFT;
    else
      return FP_RIGHT;
  }
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,168546444933769311709077540623567193548,,
"arcStrokeCircle(const pointObj *p1, const pointObj *p2, const pointObj *p3,
                double segment_angle, int include_first, pointArrayObj *pa)
{
  pointObj center; /* Center of our circular arc */
  double radius; /* Radius of our circular arc */
  double sweep_angle_r; /* Total angular size of our circular arc in radians */
  double segment_angle_r; /* Segment angle in radians */
  double a1, /*a2,*/ a3; /* Angles represented by p1, p2, p3 relative to center */
  int side = arcSegmentSide(p1, p3, p2); /* What side of p1,p3 is the middle point? */
  int num_edges; /* How many edges we will be generating */
  double current_angle_r; /* What angle are we generating now (radians)? */
  int i; /* Counter */
  pointObj p; /* Temporary point */
  int is_closed = MS_FALSE;

  /* We need to know if we're dealing with a circle early */
  if ( FP_EQ(p1->x, p3->x) && FP_EQ(p1->y, p3->y) )
    is_closed = MS_TRUE;

  /* Check if the ""arc"" is actually straight */
  if ( ! is_closed && side == FP_COLINEAR ) {
    /* We just need to write in the end points */
    if ( include_first )
      pointArrayAddPoint(pa, p1);
    pointArrayAddPoint(pa, p3);
    return MS_SUCCESS;
  }

  /* We should always be able to find the center of a non-linear arc */
  if ( arcCircleCenter(p1, p2, p3, &center, &radius) == MS_FAILURE )
    return MS_FAILURE;

  /* Calculate the angles that our three points represent */
  a1 = atan2(p1->y - center.y, p1->x - center.x);
  /* UNUSED
  a2 = atan2(p2->y - center.y, p2->x - center.x);
   */
  a3 = atan2(p3->y - center.y, p3->x - center.x);
  segment_angle_r = M_PI * segment_angle / 180.0;

  /* Closed-circle case, we sweep the whole circle! */
  if ( is_closed ) {
    sweep_angle_r = 2.0 * M_PI;
  }
  /* Clockwise sweep direction */
  else if ( side == FP_LEFT ) {
    if ( a3 > a1 ) /* Wrapping past 180? */
      sweep_angle_r = a1 + (2.0 * M_PI - a3);
    else
      sweep_angle_r = a1 - a3;
  }
  /* Counter-clockwise sweep direction */
  else if ( side == FP_RIGHT ) {
    if ( a3 > a1 ) /* Wrapping past 180? */
      sweep_angle_r = a3 - a1;
    else
      sweep_angle_r = a3 + (2.0 * M_PI - a1);
  } else
    sweep_angle_r = 0.0;

  /* We don't have enough resolution, let's invert our strategy. */
  if ( (sweep_angle_r / segment_angle_r) < SEGMENT_MINPOINTS ) {
    segment_angle_r = sweep_angle_r / (SEGMENT_MINPOINTS + 1);
  }

  /* We don't have enough resolution to stroke this arc,
  *  so just join the start to the end. */
  if ( sweep_angle_r < segment_angle_r ) {
    if ( include_first )
      pointArrayAddPoint(pa, p1);
    pointArrayAddPoint(pa, p3);
    return MS_SUCCESS;
  }

  /* How many edges to generate (we add the final edge
  *  by sticking on the last point */
  num_edges = floor(sweep_angle_r / fabs(segment_angle_r));

  /* Go backwards (negative angular steps) if we are stroking clockwise */
  if ( side == FP_LEFT )
    segment_angle_r *= -1;

  /* What point should we start with? */
  if( include_first ) {
    current_angle_r = a1;
  } else {
    current_angle_r = a1 + segment_angle_r;
    num_edges--;
  }

  /* For each edge, increment or decrement by our segment angle */
  for( i = 0; i < num_edges; i++ ) {
    if (segment_angle_r > 0.0 && current_angle_r > M_PI)
      current_angle_r -= 2*M_PI;
    if (segment_angle_r < 0.0 && current_angle_r < -1*M_PI)
      current_angle_r -= 2*M_PI;
    p.x = center.x + radius*cos(current_angle_r);
    p.y = center.y + radius*sin(current_angle_r);
    pointArrayAddPoint(pa, &p);
    current_angle_r += segment_angle_r;
  }

  /* Add the last point */
  pointArrayAddPoint(pa, p3);
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,278295598182049670215811874493419144666,,
"arcStrokeCircularString(wkbObj *w, double segment_angle, lineObj *line)
{
  pointObj p1, p2, p3;
  int npoints, nedges;
  int edge = 0;
  pointArrayObj *pa;

  if ( ! w || ! line ) return MS_FAILURE;

  npoints = wkbReadInt(w);
  nedges = npoints / 2;

  /* All CircularStrings have an odd number of points */
  if ( npoints < 3 || npoints % 2 != 1 )
    return MS_FAILURE;

  /* Make a large guess at how much space we'll need */
  pa = pointArrayNew(nedges * 180 / segment_angle);

  wkbReadPointP(w,&p3);

  /* Fill out the point array with stroked arcs */
  while( edge < nedges ) {
    p1 = p3;
    wkbReadPointP(w,&p2);
    wkbReadPointP(w,&p3);
    if ( arcStrokeCircle(&p1, &p2, &p3, segment_angle, edge ? 0 : 1, pa) == MS_FAILURE ) {
      pointArrayFree(pa);
      return MS_FAILURE;
    }
    edge++;
  }

  /* Copy the point array into the line */
  line->numpoints = pa->npoints;
  line->point = msSmallMalloc(line->numpoints * sizeof(pointObj));
  memcpy(line->point, pa->data, line->numpoints * sizeof(pointObj));

  /* Clean up */
  pointArrayFree(pa);

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,181795641718242513085439093831879074808,,
"int createPostgresTimeCompareRange(const char *timecol, const char *mintime, const char *maxtime,
                                   char *dest, size_t destsize)
{
  int mintimeresolution = msTimeGetResolution(mintime);
  int maxtimeresolution = msTimeGetResolution(maxtime);
  char minTimeStamp[100];
  char maxTimeStamp[100];
  char *minTimeInterval,*maxTimeInterval;
  if (mintimeresolution < 0 || maxtimeresolution < 0)
    return MS_FALSE;
  postgresTimeStampForTimeString(mintime,minTimeStamp,100);
  postgresTimeStampForTimeString(maxtime,maxTimeStamp,100);

  switch(maxtimeresolution) {
    case TIME_RESOLUTION_YEAR:
      maxTimeInterval = ""year"";
      break;
    case TIME_RESOLUTION_MONTH:
      maxTimeInterval = ""month"";
      break;
    case TIME_RESOLUTION_DAY:
      maxTimeInterval = ""day"";
      break;
    case TIME_RESOLUTION_HOUR:
      maxTimeInterval = ""hour"";
      break;
    case TIME_RESOLUTION_MINUTE:
      maxTimeInterval = ""minute"";
      break;
    case TIME_RESOLUTION_SECOND:
      maxTimeInterval = ""second"";
      break;
    default:
      return MS_FAILURE;
  }
  switch(mintimeresolution) {
    case TIME_RESOLUTION_YEAR:
      minTimeInterval = ""year"";
      break;
    case TIME_RESOLUTION_MONTH:
      minTimeInterval = ""month"";
      break;
    case TIME_RESOLUTION_DAY:
      minTimeInterval = ""day"";
      break;
    case TIME_RESOLUTION_HOUR:
      minTimeInterval = ""hour"";
      break;
    case TIME_RESOLUTION_MINUTE:
      minTimeInterval = ""minute"";
      break;
    case TIME_RESOLUTION_SECOND:
      minTimeInterval = ""second"";
      break;
    default:
      return MS_FAILURE;
  }
  snprintf(dest, destsize,""(%s >= date_trunc('%s',%s) and %s < date_trunc('%s',%s) + interval '1 %s')"",
           timecol, minTimeInterval, minTimeStamp,
           timecol, maxTimeInterval, maxTimeStamp, maxTimeInterval);
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,215165748141185053144876277046309794525,,
"int msPostGISBase64Decode(unsigned char *dest, const char *src, int srclen)
{

  if (src && *src) {

    unsigned char *p = dest;
    int i, j, k;
    unsigned char *buf = calloc(srclen + 1, sizeof(unsigned char));

    /* Drop illegal chars first */
    for (i=0, j=0; src[i]; i++) {
      unsigned char c = src[i];
      if ( (msPostGISBase64DecodeChar[c] != 64) || (c == '=') ) {
        buf[j++] = c;
      }
    }

    for (k=0; k<j; k+=4) {
      register unsigned char c1='A', c2='A', c3='A', c4='A';
      register unsigned char b1=0, b2=0, b3=0, b4=0;

      c1 = buf[k];

      if (k+1<j) {
        c2 = buf[k+1];
      }
      if (k+2<j) {
        c3 = buf[k+2];
      }
      if (k+3<j) {
        c4 = buf[k+3];
      }

      b1 = msPostGISBase64DecodeChar[c1];
      b2 = msPostGISBase64DecodeChar[c2];
      b3 = msPostGISBase64DecodeChar[c3];
      b4 = msPostGISBase64DecodeChar[c4];

      *p++=((b1<<2)|(b2>>4) );
      if (c3 != '=') {
        *p++=(((b2&0xf)<<4)|(b3>>2) );
      }
      if (c4 != '=') {
        *p++=(((b3&0x3)<<6)|b4 );
      }
    }
    free(buf);
    return(p-dest);
  }
  return 0;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,42578136161055550909497130774921052309,,
"char *msPostGISBuildSQL(layerObj *layer, rectObj *rect, long *uid)
{

  msPostGISLayerInfo *layerinfo = 0;
  char *strFrom = 0;
  char *strItems = 0;
  char *strWhere = 0;
  char *strSQL = 0;
  static char *strSQLTemplate0 = ""select %s from %s where %s"";
  static char *strSQLTemplate1 = ""select %s from %s%s"";
  char *strSQLTemplate = 0;

  if (layer->debug) {
    msDebug(""msPostGISBuildSQL called.\n"");
  }

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;

  strItems = msPostGISBuildSQLItems(layer);
  if ( ! strItems ) {
    msSetError(MS_MISCERR, ""Failed to build SQL items."", ""msPostGISBuildSQL()"");
    return NULL;
  }

  strFrom = msPostGISBuildSQLFrom(layer, rect);

  if ( ! strFrom ) {
    msSetError(MS_MISCERR, ""Failed to build SQL 'from'."", ""msPostGISBuildSQL()"");
    return NULL;
  }

  /* If there's BOX hackery going on, we don't want to append a box index test at
     the end of the query, the user is going to be responsible for making things
     work with their hackery. */
  if ( strstr(layerinfo->fromsource, BOXTOKEN) )
    strWhere = msPostGISBuildSQLWhere(layer, NULL, uid);
  else
    strWhere = msPostGISBuildSQLWhere(layer, rect, uid);

  if ( ! strWhere ) {
    msSetError(MS_MISCERR, ""Failed to build SQL 'where'."", ""msPostGISBuildSQL()"");
    return NULL;
  }

  strSQLTemplate = strlen(strWhere) ? strSQLTemplate0 : strSQLTemplate1;

  strSQL = msSmallMalloc(strlen(strSQLTemplate) + strlen(strFrom) + strlen(strItems) + strlen(strWhere));
  sprintf(strSQL, strSQLTemplate, strItems, strFrom, strWhere);
  if (strItems) free(strItems);
  if (strFrom) free(strFrom);
  if (strWhere) free(strWhere);

  return strSQL;

}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,278602129817369573484904352812273463452,,
"char *msPostGISBuildSQLBox(layerObj *layer, rectObj *rect, char *strSRID)
{

  char *strBox = NULL;
  size_t sz;

  if (layer->debug) {
    msDebug(""msPostGISBuildSQLBox called.\n"");
  }

  if ( strSRID ) {
    static char *strBoxTemplate = ""ST_GeomFromText('POLYGON((%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g))',%s)"";
    /* 10 doubles + 1 integer + template characters */
    sz = 10 * 22 + strlen(strSRID) + strlen(strBoxTemplate);
    strBox = (char*)msSmallMalloc(sz+1); /* add space for terminating NULL */
    if ( sz <= snprintf(strBox, sz, strBoxTemplate,
                        rect->minx, rect->miny,
                        rect->minx, rect->maxy,
                        rect->maxx, rect->maxy,
                        rect->maxx, rect->miny,
                        rect->minx, rect->miny,
                        strSRID)) {
      msSetError(MS_MISCERR,""Bounding box digits truncated."",""msPostGISBuildSQLBox"");
      return NULL;
    }
  } else {
    static char *strBoxTemplate = ""ST_GeomFromText('POLYGON((%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g))')"";
    /* 10 doubles + template characters */
    sz = 10 * 22 + strlen(strBoxTemplate);
    strBox = (char*)msSmallMalloc(sz+1); /* add space for terminating NULL */
    if ( sz <= snprintf(strBox, sz, strBoxTemplate,
                        rect->minx, rect->miny,
                        rect->minx, rect->maxy,
                        rect->maxx, rect->maxy,
                        rect->maxx, rect->miny,
                        rect->minx, rect->miny) ) {
      msSetError(MS_MISCERR,""Bounding box digits truncated."",""msPostGISBuildSQLBox"");
      return NULL;
    }
  }

  return strBox;

}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,52891066793423702758551672530504282060,,
"char *msPostGISBuildSQLItems(layerObj *layer)
{

  char *strEndian = NULL;
  char *strGeom = NULL;
  char *strItems = NULL;
  msPostGISLayerInfo *layerinfo = NULL;

  if (layer->debug) {
    msDebug(""msPostGISBuildSQLItems called.\n"");
  }

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;

  if ( ! layerinfo->geomcolumn ) {
    msSetError(MS_MISCERR, ""layerinfo->geomcolumn is not initialized."", ""msPostGISBuildSQLItems()"");
    return NULL;
  }

  /*
  ** Get the server to transform the geometry into our
  ** native endian before transmitting it to us..
  */
  if (layerinfo->endian == LITTLE_ENDIAN) {
    strEndian = ""NDR"";
  } else {
    strEndian = ""XDR"";
  }

  {
    /*
    ** We transfer the geometry from server to client as a
    ** hex or base64 encoded WKB byte-array. We will have to decode this
    ** data once we get it. Forcing to 2D (via the AsBinary function
    ** which includes a 2D force in it) removes ordinates we don't
    ** need, saving transfer and encode/decode time.
    */
#if TRANSFER_ENCODING == 64
    static char *strGeomTemplate = ""encode(ST_AsBinary(ST_Force_2D(\""%s\""),'%s'),'base64') as geom,\""%s\"""";
#else
    static char *strGeomTemplate = ""encode(ST_AsBinary(ST_Force_2D(\""%s\""),'%s'),'hex') as geom,\""%s\"""";
#endif
    strGeom = (char*)msSmallMalloc(strlen(strGeomTemplate) + strlen(strEndian) + strlen(layerinfo->geomcolumn) + strlen(layerinfo->uid));
    sprintf(strGeom, strGeomTemplate, layerinfo->geomcolumn, strEndian, layerinfo->uid);
  }

  if( layer->debug > 1 ) {
    msDebug(""msPostGISBuildSQLItems: %d items requested.\n"",layer->numitems);
  }

  /*
  ** Not requesting items? We just need geometry and unique id.
  */
  if (layer->numitems == 0) {
    strItems = msStrdup(strGeom);
  }
  /*
  ** Build SQL to pull all the items.
  */
  else {
    int length = strlen(strGeom) + 2;
    int t;
    for ( t = 0; t < layer->numitems; t++ ) {
      length += strlen(layer->items[t]) + 3; /* itemname + """", */
    }
    strItems = (char*)msSmallMalloc(length);
    strItems[0] = '\0';
    for ( t = 0; t < layer->numitems; t++ ) {
      strlcat(strItems, ""\"""", length);
      strlcat(strItems, layer->items[t], length);
      strlcat(strItems, ""\"","", length);
    }
    strlcat(strItems, strGeom, length);
  }

  free(strGeom);
  return strItems;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,184390011862808188101614909607911686758,,
"char *msPostGISBuildSQLWhere(layerObj *layer, rectObj *rect, long *uid)
{
  char *strRect = 0;
  char *strFilter = 0;
  char *strUid = 0;
  char *strWhere = 0;
  char *strLimit = 0;
  char *strOffset = 0;
  size_t strRectLength = 0;
  size_t strFilterLength = 0;
  size_t strUidLength = 0;
  size_t strLimitLength = 0;
  size_t strOffsetLength = 0;
  size_t bufferSize = 0;
  int insert_and = 0;
  msPostGISLayerInfo *layerinfo;

  if (layer->debug) {
    msDebug(""msPostGISBuildSQLWhere called.\n"");
  }

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;

  if ( ! layerinfo->fromsource ) {
    msSetError(MS_MISCERR, ""Layerinfo->fromsource is not initialized."", ""msPostGISBuildSQLWhere()"");
    return NULL;
  }

  /* Populate strLimit, if necessary. */
  if ( layerinfo->paging && layer->maxfeatures >= 0 ) {
    static char *strLimitTemplate = "" limit %d"";
    strLimit = msSmallMalloc(strlen(strLimitTemplate) + 12);
    sprintf(strLimit, strLimitTemplate, layer->maxfeatures);
    strLimitLength = strlen(strLimit);
  }

  /* Populate strOffset, if necessary. */
  if ( layerinfo->paging && layer->startindex > 0 ) {
    static char *strOffsetTemplate = "" offset %d"";
    strOffset = msSmallMalloc(strlen(strOffsetTemplate) + 12);
    sprintf(strOffset, strOffsetTemplate, layer->startindex-1);
    strOffsetLength = strlen(strOffset);
  }

  /* Populate strRect, if necessary. */
  if ( rect && layerinfo->geomcolumn ) {
    char *strBox = 0;
    char *strSRID = 0;
    size_t strBoxLength = 0;
    static char *strRectTemplate = ""%s && %s"";

    /* We see to set the SRID on the box, but to what SRID? */
    strSRID = msPostGISBuildSQLSRID(layer);
    if ( ! strSRID ) {
      return NULL;
    }

    strBox = msPostGISBuildSQLBox(layer, rect, strSRID);
    if ( strBox ) {
      strBoxLength = strlen(strBox);
    } else {
      msSetError(MS_MISCERR, ""Unable to build box SQL."", ""msPostGISBuildSQLWhere()"");
      return NULL;
    }

    strRect = (char*)msSmallMalloc(strlen(strRectTemplate) + strBoxLength + strlen(layerinfo->geomcolumn));
    sprintf(strRect, strRectTemplate, layerinfo->geomcolumn, strBox);
    strRectLength = strlen(strRect);
    if (strBox) free(strBox);
    if (strSRID) free(strSRID);
  }

  /* Populate strFilter, if necessary. */
  if ( layer->filter.string ) {
    static char *strFilterTemplate = ""(%s)"";
    strFilter = (char*)msSmallMalloc(strlen(strFilterTemplate) + strlen(layer->filter.string));
    sprintf(strFilter, strFilterTemplate, layer->filter.string);
    strFilterLength = strlen(strFilter);
  }

  /* Populate strUid, if necessary. */
  if ( uid ) {
    static char *strUidTemplate = ""\""%s\"" = %ld"";
    strUid = (char*)msSmallMalloc(strlen(strUidTemplate) + strlen(layerinfo->uid) + 64);
    sprintf(strUid, strUidTemplate, layerinfo->uid, *uid);
    strUidLength = strlen(strUid);
  }

  bufferSize = strRectLength + 5 + strFilterLength + 5 + strUidLength
               + strLimitLength + strOffsetLength;
  strWhere = (char*)msSmallMalloc(bufferSize);
  *strWhere = '\0';
  if ( strRect ) {
    strlcat(strWhere, strRect, bufferSize);
    insert_and++;
    free(strRect);
  }
  if ( strFilter ) {
    if ( insert_and ) {
      strlcat(strWhere, "" and "", bufferSize);
    }
    strlcat(strWhere, strFilter, bufferSize);
    free(strFilter);
    insert_and++;
  }
  if ( strUid ) {
    if ( insert_and ) {
      strlcat(strWhere, "" and "", bufferSize);
    }
    strlcat(strWhere, strUid, bufferSize);
    free(strUid);
    insert_and++;
  }
  if ( strLimit ) {
    strlcat(strWhere, strLimit, bufferSize);
    free(strLimit);
  }
  if ( strOffset ) {
    strlcat(strWhere, strOffset, bufferSize);
    free(strOffset);
  }

  return strWhere;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,240372754014776782848867347854388210561,,
"msPostGISLayerInfo *msPostGISCreateLayerInfo(void)
{
  msPostGISLayerInfo *layerinfo = msSmallMalloc(sizeof(msPostGISLayerInfo));
  layerinfo->sql = NULL;
  layerinfo->srid = NULL;
  layerinfo->uid = NULL;
  layerinfo->pgconn = NULL;
  layerinfo->pgresult = NULL;
  layerinfo->geomcolumn = NULL;
  layerinfo->fromsource = NULL;
  layerinfo->endian = 0;
  layerinfo->rownum = 0;
  layerinfo->version = 0;
  layerinfo->paging = MS_TRUE;
  return layerinfo;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,86043167793218923418161470669362147546,,
"void msPostGISEnablePaging(layerObj *layer, int value)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo *layerinfo = NULL;

  if (layer->debug) {
    msDebug(""msPostGISEnablePaging called.\n"");
  }

  if(!msPostGISLayerIsOpen(layer))
    msPostGISLayerOpen(layer);

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;
  layerinfo->paging = value;

#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISEnablePaging()"");
#endif
  return;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,69777726222789414009537205503686219234,,
"char *msPostGISEscapeSQLParam(layerObj *layer, const char *pszString)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo *layerinfo = NULL;
  int nError;
  size_t nSrcLen;
  char* pszEscapedStr =NULL;

  if (layer && pszString && strlen(pszString) > 0) {
    if(!msPostGISLayerIsOpen(layer))
      msPostGISLayerOpen(layer);

    assert(layer->layerinfo != NULL);

    layerinfo = (msPostGISLayerInfo *) layer->layerinfo;
    nSrcLen = strlen(pszString);
    pszEscapedStr = (char*) msSmallMalloc( 2 * nSrcLen + 1);
    PQescapeStringConn (layerinfo->pgconn, pszEscapedStr, pszString, nSrcLen, &nError);
    if (nError != 0) {
      free(pszEscapedStr);
      pszEscapedStr = NULL;
    }
  }
  return pszEscapedStr;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISEscapeSQLParam()"");
  return NULL;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,279709593279789177426072526587132181919,,
"msPostGISFindBestType(wkbObj *w, shapeObj *shape)
{
  int wkbtype;

  /* What kind of geometry is this? */
  wkbtype = wkbType(w);

  /* Generic collection, we need to look a little deeper. */
  if ( wkbtype == WKB_GEOMETRYCOLLECTION )
    wkbtype = wkbCollectionSubType(w);

  switch ( wkbtype ) {
    case WKB_POLYGON:
    case WKB_CURVEPOLYGON:
    case WKB_MULTIPOLYGON:
      shape->type = MS_SHAPE_POLYGON;
      break;
    case WKB_LINESTRING:
    case WKB_CIRCULARSTRING:
    case WKB_COMPOUNDCURVE:
    case WKB_MULTICURVE:
    case WKB_MULTILINESTRING:
      shape->type = MS_SHAPE_LINE;
      break;
    case WKB_POINT:
    case WKB_MULTIPOINT:
      shape->type = MS_SHAPE_POINT;
      break;
    default:
      return MS_FAILURE;
  }

  return wkbConvGeometryToShape(w, shape);
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,58268235296778276030482866033073825931,,
"void msPostGISFreeLayerInfo(layerObj *layer)
{
  msPostGISLayerInfo *layerinfo = NULL;
  layerinfo = (msPostGISLayerInfo*)layer->layerinfo;
  if ( layerinfo->sql ) free(layerinfo->sql);
  if ( layerinfo->uid ) free(layerinfo->uid);
  if ( layerinfo->srid ) free(layerinfo->srid);
  if ( layerinfo->geomcolumn ) free(layerinfo->geomcolumn);
  if ( layerinfo->fromsource ) free(layerinfo->fromsource);
  if ( layerinfo->pgresult ) PQclear(layerinfo->pgresult);
  if ( layerinfo->pgconn ) msConnPoolRelease(layer, layerinfo->pgconn);
  free(layerinfo);
  layer->layerinfo = NULL;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,237503149799399679868634565678692026963,,
"int msPostGISGetPaging(layerObj *layer)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo *layerinfo = NULL;

  if (layer->debug) {
    msDebug(""msPostGISGetPaging called.\n"");
  }

  if(!msPostGISLayerIsOpen(layer))
    return MS_TRUE;

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;
  return layerinfo->paging;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISEnablePaging()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,265615605127270431391263852103821242599,,
"int msPostGISHexDecode(unsigned char *dest, const char *src, int srclen)
{

  if (src && *src && (srclen % 2 == 0) ) {

    unsigned char *p = dest;
    int i;

    for ( i=0; i<srclen; i+=2 ) {
      register unsigned char b1=0, b2=0;
      register unsigned char c1 = src[i];
      register unsigned char c2 = src[i + 1];

      b1 = msPostGISHexDecodeChar[c1];
      b2 = msPostGISHexDecodeChar[c2];

      *p++ = (b1 << 4) | b2;

    }
    return(p-dest);
  }
  return 0;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,322782002038198957674928210986766619819,,
"int msPostGISLayerClose(layerObj *layer)
{
#ifdef USE_POSTGIS

  if (layer->debug) {
    msDebug(""msPostGISLayerClose called: %s\n"", layer->data);
  }

  if( layer->layerinfo ) {
    msPostGISFreeLayerInfo(layer);
  }

  return MS_SUCCESS;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerClose()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,237748274208853707956934663625853517644,,
"int msPostGISLayerGetItems(layerObj *layer)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo *layerinfo = NULL;
  static char *strSQLTemplate = ""select * from %s where false limit 0"";
  PGresult *pgresult = NULL;
  char *col = NULL;
  char *sql = NULL;
  char *strFrom = NULL;
  char found_geom = 0;
  const char *value;
  int t, item_num;
  rectObj rect;

  /* A useless rectangle for our useless query */
  rect.minx = rect.miny = rect.maxx = rect.maxy = 0.0;

  assert(layer != NULL);
  assert(layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

  assert(layerinfo->pgconn);

  if (layer->debug) {
    msDebug(""msPostGISLayerGetItems called.\n"");
  }

  /* Fill out layerinfo with our current DATA state. */
  if ( msPostGISParseData(layer) != MS_SUCCESS) {
    return MS_FAILURE;
  }

  layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

  /* This allocates a fresh string, so remember to free it... */
  strFrom = msPostGISReplaceBoxToken(layer, &rect, layerinfo->fromsource);

  /*
  ** Both the ""table"" and ""(select ...) as sub"" cases can be handled with the
  ** same SQL.
  */
  sql = (char*) msSmallMalloc(strlen(strSQLTemplate) + strlen(strFrom));
  sprintf(sql, strSQLTemplate, strFrom);
  free(strFrom);

  if (layer->debug) {
    msDebug(""msPostGISLayerGetItems executing SQL: %s\n"", sql);
  }

  pgresult = PQexecParams(layerinfo->pgconn, sql,0, NULL, NULL, NULL, NULL, 0);

  if ( (!pgresult) || (PQresultStatus(pgresult) != PGRES_TUPLES_OK) ) {
    if ( layer->debug ) {
      msDebug(""Error (%s) executing SQL: %s"", ""msPostGISLayerGetItems()\n"", PQerrorMessage(layerinfo->pgconn), sql);
    }
    msSetError(MS_QUERYERR, ""Error executing SQL: %s"", ""msPostGISLayerGetItems()"", PQerrorMessage(layerinfo->pgconn));
    if (pgresult) {
      PQclear(pgresult);
    }
    free(sql);
    return MS_FAILURE;
  }

  free(sql);

  layer->numitems = PQnfields(pgresult) - 1; /* dont include the geometry column (last entry)*/
  layer->items = msSmallMalloc(sizeof(char*) * (layer->numitems + 1)); /* +1 in case there is a problem finding geometry column */

  found_geom = 0; /* havent found the geom field */
  item_num = 0;

  for (t = 0; t < PQnfields(pgresult); t++) {
    col = PQfname(pgresult, t);
    if ( strcmp(col, layerinfo->geomcolumn) != 0 ) {
      /* this isnt the geometry column */
      layer->items[item_num] = msStrdup(col);
      item_num++;
    } else {
      found_geom = 1;
    }
  }

  /*
  ** consider populating the field definitions in metadata.
  */
  if((value = msOWSLookupMetadata(&(layer->metadata), ""G"", ""types"")) != NULL
      && strcasecmp(value,""auto"") == 0 )
    msPostGISPassThroughFieldDefinitions( layer, pgresult );

  /*
  ** Cleanup
  */
  PQclear(pgresult);

  if (!found_geom) {
    msSetError(MS_QUERYERR, ""Tried to find the geometry column in the database, but couldn't find it.  Is it mis-capitalized? '%s'"", ""msPostGISLayerGetItems()"", layerinfo->geomcolumn);
    return MS_FAILURE;
  }

  return msPostGISLayerInitItemInfo(layer);
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerGetItems()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,85018141374801265569543313371880663786,,
"int msPostGISLayerGetShape(layerObj *layer, shapeObj *shape, resultObj *record)
{
#ifdef USE_POSTGIS

  PGresult *pgresult = NULL;
  msPostGISLayerInfo *layerinfo = NULL;

  long shapeindex = record->shapeindex;
  int resultindex = record->resultindex;

  assert(layer != NULL);
  assert(layer->layerinfo != NULL);

  if (layer->debug) {
    msDebug(""msPostGISLayerGetShape called for record = %i\n"", resultindex);
  }

  /* If resultindex is set, fetch the shape from the resultcache, otherwise fetch it from the DB  */
  if (resultindex >= 0) {
    int status;

    layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

    /* Check the validity of the open result. */
    pgresult = layerinfo->pgresult;
    if ( ! pgresult ) {
      msSetError( MS_MISCERR,
                  ""PostgreSQL result set is null."",
                  ""msPostGISLayerGetShape()"");
      return MS_FAILURE;
    }
    status = PQresultStatus(pgresult);
    if ( layer->debug > 1 ) {
      msDebug(""msPostGISLayerGetShape query status: %s (%d)\n"", PQresStatus(status), status);
    }
    if( ! ( status == PGRES_COMMAND_OK || status == PGRES_TUPLES_OK) ) {
      msSetError( MS_MISCERR,
                  ""PostgreSQL result set is not ready."",
                  ""msPostGISLayerGetShape()"");
      return MS_FAILURE;
    }

    /* Check the validity of the requested record number. */
    if( resultindex >= PQntuples(pgresult) ) {
      msDebug(""msPostGISLayerGetShape got request for (%d) but only has %d tuples.\n"", resultindex, PQntuples(pgresult));
      msSetError( MS_MISCERR,
                  ""Got request larger than result set."",
                  ""msPostGISLayerGetShape()"");
      return MS_FAILURE;
    }

    layerinfo->rownum = resultindex; /* Only return one result. */

    /* We don't know the shape type until we read the geometry. */
    shape->type = MS_SHAPE_NULL;

    /* Return the shape, cursor access mode. */
    msPostGISReadShape(layer, shape);

    return (shape->type == MS_SHAPE_NULL) ? MS_FAILURE : MS_SUCCESS;
  } else { /* no resultindex, fetch the shape from the DB */
    int num_tuples;
    char *strSQL = 0;

    /* Fill out layerinfo with our current DATA state. */
    if ( msPostGISParseData(layer) != MS_SUCCESS) {
      return MS_FAILURE;
    }

    /*
    ** This comes *after* parsedata, because parsedata fills in
    ** layer->layerinfo.
    */
    layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

    /* Build a SQL query based on our current state. */
    strSQL = msPostGISBuildSQL(layer, 0, &shapeindex);
    if ( ! strSQL ) {
      msSetError(MS_QUERYERR, ""Failed to build query SQL."", ""msPostGISLayerGetShape()"");
      return MS_FAILURE;
    }

    if (layer->debug) {
      msDebug(""msPostGISLayerGetShape query: %s\n"", strSQL);
    }

    pgresult = PQexecParams(layerinfo->pgconn, strSQL,0, NULL, NULL, NULL, NULL, 0);

    /* Something went wrong. */
    if ( (!pgresult) || (PQresultStatus(pgresult) != PGRES_TUPLES_OK) ) {
      if ( layer->debug ) {
        msDebug(""Error (%s) executing SQL: %s"", ""msPostGISLayerGetShape()\n"", PQerrorMessage(layerinfo->pgconn), strSQL );
      }
      msSetError(MS_QUERYERR, ""Error executing SQL: %s"", ""msPostGISLayerGetShape()"", PQerrorMessage(layerinfo->pgconn));

      if (pgresult) {
        PQclear(pgresult);
      }
      free(strSQL);

      return MS_FAILURE;
    }

    /* Clean any existing pgresult before storing current one. */
    if(layerinfo->pgresult) PQclear(layerinfo->pgresult);
    layerinfo->pgresult = pgresult;

    /* Clean any existing SQL before storing current. */
    if(layerinfo->sql) free(layerinfo->sql);
    layerinfo->sql = strSQL;

    layerinfo->rownum = 0; /* Only return one result. */

    /* We don't know the shape type until we read the geometry. */
    shape->type = MS_SHAPE_NULL;

    num_tuples = PQntuples(pgresult);
    if (layer->debug) {
      msDebug(""msPostGISLayerGetShape number of records: %d\n"", num_tuples);
    }

    if (num_tuples > 0) {
      /* Get shape in random access mode. */
      msPostGISReadShape(layer, shape);
    }

    return (shape->type == MS_SHAPE_NULL) ? MS_FAILURE : ( (num_tuples > 0) ? MS_SUCCESS : MS_DONE );
  }
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerGetShape()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,206675996142925405325788767069929109072,,
"int msPostGISLayerInitItemInfo(layerObj *layer)
{
#ifdef USE_POSTGIS
  int i;
  int *itemindexes ;

  if (layer->debug) {
    msDebug(""msPostGISLayerInitItemInfo called.\n"");
  }

  if (layer->numitems == 0) {
    return MS_SUCCESS;
  }

  if (layer->iteminfo) {
    free(layer->iteminfo);
  }

  layer->iteminfo = msSmallMalloc(sizeof(int) * layer->numitems);
  if (!layer->iteminfo) {
    msSetError(MS_MEMERR, ""Out of memory."", ""msPostGISLayerInitItemInfo()"");
    return MS_FAILURE;
  }

  itemindexes = (int*)layer->iteminfo;
  for (i = 0; i < layer->numitems; i++) {
    itemindexes[i] = i; /* Last item is always the geometry. The rest are non-geometry. */
  }

  return MS_SUCCESS;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerInitItemInfo()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,7778221621330036461149065608901507289,,
"int msPostGISLayerInitializeVirtualTable(layerObj *layer)
{
  assert(layer != NULL);
  assert(layer->vtable != NULL);

  layer->vtable->LayerInitItemInfo = msPostGISLayerInitItemInfo;
  layer->vtable->LayerFreeItemInfo = msPostGISLayerFreeItemInfo;
  layer->vtable->LayerOpen = msPostGISLayerOpen;
  layer->vtable->LayerIsOpen = msPostGISLayerIsOpen;
  layer->vtable->LayerWhichShapes = msPostGISLayerWhichShapes;
  layer->vtable->LayerNextShape = msPostGISLayerNextShape;
  layer->vtable->LayerGetShape = msPostGISLayerGetShape;
  layer->vtable->LayerClose = msPostGISLayerClose;
  layer->vtable->LayerGetItems = msPostGISLayerGetItems;
  /* layer->vtable->LayerGetExtent = msPostGISLayerGetExtent; */
  layer->vtable->LayerApplyFilterToLayer = msLayerApplyCondSQLFilterToLayer;
  /* layer->vtable->LayerGetAutoStyle, not supported for this layer */
  /* layer->vtable->LayerCloseConnection = msPostGISLayerClose; */
  layer->vtable->LayerSetTimeFilter = msPostGISLayerSetTimeFilter;
  /* layer->vtable->LayerCreateItems, use default */
  /* layer->vtable->LayerGetNumFeatures, use default */

  /* layer->vtable->LayerGetAutoProjection, use defaut*/

  layer->vtable->LayerEscapeSQLParam = msPostGISEscapeSQLParam;
  layer->vtable->LayerEnablePaging = msPostGISEnablePaging;
  layer->vtable->LayerGetPaging = msPostGISGetPaging;

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,223209223546697296463896030016026878968,,
"int msPostGISLayerIsOpen(layerObj *layer)
{
#ifdef USE_POSTGIS

  if (layer->debug) {
    msDebug(""msPostGISLayerIsOpen called.\n"");
  }

  if (layer->layerinfo)
    return MS_TRUE;
  else
    return MS_FALSE;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerIsOpen()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,174030100669387754654236657487382115236,,
"int msPostGISLayerNextShape(layerObj *layer, shapeObj *shape)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo  *layerinfo;

  if (layer->debug) {
    msDebug(""msPostGISLayerNextShape called.\n"");
  }

  assert(layer != NULL);
  assert(layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

  shape->type = MS_SHAPE_NULL;

  /*
  ** Roll through pgresult until we hit non-null shape (usually right away).
  */
  while (shape->type == MS_SHAPE_NULL) {
    if (layerinfo->rownum < PQntuples(layerinfo->pgresult)) {
      /* Retrieve this shape, cursor access mode. */
      msPostGISReadShape(layer, shape);
      if( shape->type != MS_SHAPE_NULL ) {
        (layerinfo->rownum)++; /* move to next shape */
        return MS_SUCCESS;
      } else {
        (layerinfo->rownum)++; /* move to next shape */
      }
    } else {
      return MS_DONE;
    }
  }

  /* Found nothing, clean up and exit. */
  msFreeShape(shape);

  return MS_FAILURE;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerNextShape()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,335747732673501731441587028099902339569,,
"int msPostGISLayerOpen(layerObj *layer)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo  *layerinfo;
  int order_test = 1;

  assert(layer != NULL);

  if (layer->debug) {
    msDebug(""msPostGISLayerOpen called: %s\n"", layer->data);
  }

  if (layer->layerinfo) {
    if (layer->debug) {
      msDebug(""msPostGISLayerOpen: Layer is already open!\n"");
    }
    return MS_SUCCESS;  /* already open */
  }

  if (!layer->data) {
    msSetError(MS_QUERYERR, ""Nothing specified in DATA statement."", ""msPostGISLayerOpen()"");
    return MS_FAILURE;
  }

  /*
  ** Initialize the layerinfo
  **/
  layerinfo = msPostGISCreateLayerInfo();

  if (((char*) &order_test)[0] == 1) {
    layerinfo->endian = LITTLE_ENDIAN;
  } else {
    layerinfo->endian = BIG_ENDIAN;
  }

  /*
  ** Get a database connection from the pool.
  */
  layerinfo->pgconn = (PGconn *) msConnPoolRequest(layer);

  /* No connection in the pool, so set one up. */
  if (!layerinfo->pgconn) {
    char *conn_decrypted;
    if (layer->debug) {
      msDebug(""msPostGISLayerOpen: No connection in pool, creating a fresh one.\n"");
    }

    if (!layer->connection) {
      msSetError(MS_MISCERR, ""Missing CONNECTION keyword."", ""msPostGISLayerOpen()"");
      return MS_FAILURE;
    }

    /*
    ** Decrypt any encrypted token in connection string and attempt to connect.
    */
    conn_decrypted = msDecryptStringTokens(layer->map, layer->connection);
    if (conn_decrypted == NULL) {
      return MS_FAILURE;  /* An error should already have been produced */
    }
    layerinfo->pgconn = PQconnectdb(conn_decrypted);
    msFree(conn_decrypted);
    conn_decrypted = NULL;

    /*
    ** Connection failed, return error message with passwords ***ed out.
    */
    if (!layerinfo->pgconn || PQstatus(layerinfo->pgconn) == CONNECTION_BAD) {
      char *index, *maskeddata;
      if (layer->debug)
        msDebug(""msPostGISLayerOpen: Connection failure.\n"");

      maskeddata = msStrdup(layer->connection);
      index = strstr(maskeddata, ""password="");
      if (index != NULL) {
        index = (char*)(index + 9);
        while (*index != '\0' && *index != ' ') {
          *index = '*';
          index++;
        }
      }

      msSetError(MS_QUERYERR, ""Database connection failed (%s) with connect string '%s'\nIs the database running? Is it allowing connections? Does the specified user exist? Is the password valid? Is the database on the standard port?"", ""msPostGISLayerOpen()"", PQerrorMessage(layerinfo->pgconn), maskeddata);

      free(maskeddata);
      free(layerinfo);
      return MS_FAILURE;
    }

    /* Register to receive notifications from the database. */
    PQsetNoticeProcessor(layerinfo->pgconn, postresqlNoticeHandler, (void *) layer);

    /* Save this connection in the pool for later. */
    msConnPoolRegister(layer, layerinfo->pgconn, msPostGISCloseConnection);
  } else {
    /* Connection in the pool should be tested to see if backend is alive. */
    if( PQstatus(layerinfo->pgconn) != CONNECTION_OK ) {
      /* Uh oh, bad connection. Can we reset it? */
      PQreset(layerinfo->pgconn);
      if( PQstatus(layerinfo->pgconn) != CONNECTION_OK ) {
        /* Nope, time to bail out. */
        msSetError(MS_QUERYERR, ""PostgreSQL database connection gone bad (%s)"", ""msPostGISLayerOpen()"", PQerrorMessage(layerinfo->pgconn));
        return MS_FAILURE;
      }

    }
  }

  /* Get the PostGIS version number from the database */
  layerinfo->version = msPostGISRetrieveVersion(layerinfo->pgconn);
  if( layerinfo->version == MS_FAILURE ) return MS_FAILURE;
  if (layer->debug)
    msDebug(""msPostGISLayerOpen: Got PostGIS version %d.\n"", layerinfo->version);

  /* Save the layerinfo in the layerObj. */
  layer->layerinfo = (void*)layerinfo;

  return MS_SUCCESS;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerOpen()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,179971218884454587800551597377139839610,,
"int msPostGISLayerWhichShapes(layerObj *layer, rectObj rect, int isQuery)
{
#ifdef USE_POSTGIS
  msPostGISLayerInfo *layerinfo = NULL;
  char *strSQL = NULL;
  PGresult *pgresult = NULL;
  char** layer_bind_values = (char**)msSmallMalloc(sizeof(char*) * 1000);
  char* bind_value;
  char* bind_key = (char*)msSmallMalloc(3);

  int num_bind_values = 0;

  /* try to get the first bind value */
  bind_value = msLookupHashTable(&layer->bindvals, ""1"");
  while(bind_value != NULL) {
    /* put the bind value on the stack */
    layer_bind_values[num_bind_values] = bind_value;
    /* increment the counter */
    num_bind_values++;
    /* create a new lookup key */
    sprintf(bind_key, ""%d"", num_bind_values+1);
    /* get the bind_value */
    bind_value = msLookupHashTable(&layer->bindvals, bind_key);
  }

  assert(layer != NULL);
  assert(layer->layerinfo != NULL);

  if (layer->debug) {
    msDebug(""msPostGISLayerWhichShapes called.\n"");
  }

  /* Fill out layerinfo with our current DATA state. */
  if ( msPostGISParseData(layer) != MS_SUCCESS) {
    return MS_FAILURE;
  }

  /*
  ** This comes *after* parsedata, because parsedata fills in
  ** layer->layerinfo.
  */
  layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

  /* Build a SQL query based on our current state. */
  strSQL = msPostGISBuildSQL(layer, &rect, NULL);
  if ( ! strSQL ) {
    msSetError(MS_QUERYERR, ""Failed to build query SQL."", ""msPostGISLayerWhichShapes()"");
    return MS_FAILURE;
  }

  if (layer->debug) {
    msDebug(""msPostGISLayerWhichShapes query: %s\n"", strSQL);
  }

  if(num_bind_values > 0) {
    pgresult = PQexecParams(layerinfo->pgconn, strSQL, num_bind_values, NULL, (const char**)layer_bind_values, NULL, NULL, 1);
  } else {
    pgresult = PQexecParams(layerinfo->pgconn, strSQL,0, NULL, NULL, NULL, NULL, 0);
  }

  /* free bind values */
  free(bind_key);
  free(layer_bind_values);

  if ( layer->debug > 1 ) {
    msDebug(""msPostGISLayerWhichShapes query status: %s (%d)\n"", PQresStatus(PQresultStatus(pgresult)), PQresultStatus(pgresult));
  }

  /* Something went wrong. */
  if (!pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {
    if ( layer->debug ) {
      msDebug(""Error (%s) executing query: %s"", ""msPostGISLayerWhichShapes()\n"", PQerrorMessage(layerinfo->pgconn), strSQL);
    }
    msSetError(MS_QUERYERR, ""Error executing query: %s "", ""msPostGISLayerWhichShapes()"", PQerrorMessage(layerinfo->pgconn));
    free(strSQL);
    if (pgresult) {
      PQclear(pgresult);
    }
    return MS_FAILURE;
  }

  if ( layer->debug ) {
    msDebug(""msPostGISLayerWhichShapes got %d records in result.\n"", PQntuples(pgresult));
  }

  /* Clean any existing pgresult before storing current one. */
  if(layerinfo->pgresult) PQclear(layerinfo->pgresult);
  layerinfo->pgresult = pgresult;

  /* Clean any existing SQL before storing current. */
  if(layerinfo->sql) free(layerinfo->sql);
  layerinfo->sql = strSQL;

  layerinfo->rownum = 0;

  return MS_SUCCESS;
#else
  msSetError( MS_MISCERR,
              ""PostGIS support is not available."",
              ""msPostGISLayerWhichShapes()"");
  return MS_FAILURE;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,21203477191773266844759026338064686286,,
"int msPostGISParseData(layerObj *layer)
{
  char *pos_opt, *pos_scn, *tmp, *pos_srid, *pos_uid, *pos_geom, *data;
  int slength;
  msPostGISLayerInfo *layerinfo;

  assert(layer != NULL);
  assert(layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo*)(layer->layerinfo);

  if (layer->debug) {
    msDebug(""msPostGISParseData called.\n"");
  }

  if (!layer->data) {
    msSetError(MS_QUERYERR, ""Missing DATA clause. DATA statement must contain 'geometry_column from table_name' or 'geometry_column from (sub-query) as sub'."", ""msPostGISParseData()"");
    return MS_FAILURE;
  }
  data = layer->data;

  /*
  ** Clean up any existing strings first, as we will be populating these fields.
  */
  if( layerinfo->srid ) {
    free(layerinfo->srid);
    layerinfo->srid = NULL;
  }
  if( layerinfo->uid ) {
    free(layerinfo->uid);
    layerinfo->uid = NULL;
  }
  if( layerinfo->geomcolumn ) {
    free(layerinfo->geomcolumn);
    layerinfo->geomcolumn = NULL;
  }
  if( layerinfo->fromsource ) {
    free(layerinfo->fromsource);
    layerinfo->fromsource = NULL;
  }

  /*
  ** Look for the optional ' using unique ID' string first.
  */
  pos_uid = strcasestr(data, "" using unique "");
  if (pos_uid) {
    /* Find the end of this case 'using unique ftab_id using srid=33' */
    tmp = strstr(pos_uid + 14, "" "");
    /* Find the end of this case 'using srid=33 using unique ftab_id' */
    if (!tmp) {
      tmp = pos_uid + strlen(pos_uid);
    }
    layerinfo->uid = (char*) msSmallMalloc((tmp - (pos_uid + 14)) + 1);
    strlcpy(layerinfo->uid, pos_uid + 14, tmp - (pos_uid + 14)+1);
    msStringTrim(layerinfo->uid);
  }

  /*
  ** Look for the optional ' using srid=333 ' string next.
  */
  pos_srid = strcasestr(data, "" using srid="");
  if (!pos_srid) {
    layerinfo->srid = (char*) msSmallMalloc(1);
    (layerinfo->srid)[0] = '\0'; /* no SRID, so return just null terminator*/
  } else {
    slength = strspn(pos_srid + 12, ""-0123456789"");
    if (!slength) {
      msSetError(MS_QUERYERR, ""Error parsing PostGIS DATA variable. You specified 'USING SRID' but didnt have any numbers! %s"", ""msPostGISParseData()"", data);
      return MS_FAILURE;
    } else {
      layerinfo->srid = (char*) msSmallMalloc(slength + 1);
      strlcpy(layerinfo->srid, pos_srid + 12, slength+1);
      msStringTrim(layerinfo->srid);
    }
  }

  /*
  ** This is a little hack so the rest of the code works.
  ** pos_opt should point to the start of the optional blocks.
  **
  ** If they are both set, return the smaller one.
  */
  if (pos_srid && pos_uid) {
    pos_opt = (pos_srid > pos_uid) ? pos_uid : pos_srid;
  }
  /* If one or none is set, return the larger one. */
  else {
    pos_opt = (pos_srid > pos_uid) ? pos_srid : pos_uid;
  }
  /* No pos_opt? Move it to the end of the string. */
  if (!pos_opt) {
    pos_opt = data + strlen(data);
  }

  /*
  ** Scan for the 'geometry from table' or 'geometry from () as foo' clause.
  */

  /* Find the first non-white character to start from */
  pos_geom = data;
  while( *pos_geom == ' ' || *pos_geom == '\t' || *pos_geom == '\n' || *pos_geom == '\r' )
    pos_geom++;

  /* Find the end of the geom column name */
  pos_scn = strcasestr(data, "" from "");
  if (!pos_scn) {
    msSetError(MS_QUERYERR, ""Error parsing PostGIS DATA variable. Must contain 'geometry from table' or 'geometry from (subselect) as foo'. %s"", ""msPostGISParseData()"", data);
    return MS_FAILURE;
  }

  /* Copy the geometry column name */
  layerinfo->geomcolumn = (char*) msSmallMalloc((pos_scn - pos_geom) + 1);
  strlcpy(layerinfo->geomcolumn, pos_geom, pos_scn - pos_geom+1);
  msStringTrim(layerinfo->geomcolumn);

  /* Copy the table name or sub-select clause */
  layerinfo->fromsource = (char*) msSmallMalloc((pos_opt - (pos_scn + 6)) + 1);
  strlcpy(layerinfo->fromsource, pos_scn + 6, pos_opt - (pos_scn + 6)+1);
  msStringTrim(layerinfo->fromsource);

  /* Something is wrong, our goemetry column and table references are not there. */
  if (strlen(layerinfo->fromsource) < 1 || strlen(layerinfo->geomcolumn) < 1) {
    msSetError(MS_QUERYERR, ""Error parsing PostGIS DATA variable.  Must contain 'geometry from table' or 'geometry from (subselect) as foo'. %s"", ""msPostGISParseData()"", data);
    return MS_FAILURE;
  }

  /*
  ** We didn't find a ' using unique ' in the DATA string so try and find a
  ** primary key on the table.
  */
  if ( ! (layerinfo->uid) ) {
    if ( strstr(layerinfo->fromsource, "" "") ) {
      msSetError(MS_QUERYERR, ""Error parsing PostGIS DATA variable.  You must specify 'using unique' when supplying a subselect in the data definition."", ""msPostGISParseData()"");
      return MS_FAILURE;
    }
    if ( msPostGISRetrievePK(layer) != MS_SUCCESS ) {
      /* No user specified unique id so we will use the PostgreSQL oid */
      /* TODO: Deprecate this, oids are deprecated in PostgreSQL */
      layerinfo->uid = msStrdup(""oid"");
    }
  }

  if (layer->debug) {
    msDebug(""msPostGISParseData: unique_column=%s, srid=%s, geom_column_name=%s, table_name=%s\n"", layerinfo->uid, layerinfo->srid, layerinfo->geomcolumn, layerinfo->fromsource);
  }
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,68565151911132238250374003709188785538,,
"msPostGISPassThroughFieldDefinitions( layerObj *layer,
                                      PGresult *pgresult )

{
  int i, numitems = PQnfields(pgresult);
  msPostGISLayerInfo *layerinfo = layer->layerinfo;

  for(i=0; i<numitems; i++) {
    int oid, fmod;
    const char *gml_type = ""Character"";
    const char *item = PQfname(pgresult,i);
    char md_item_name[256];
    char gml_width[32], gml_precision[32];

    gml_width[0] = '\0';
    gml_precision[0] = '\0';

    /* skip geometry column */
    if( strcmp(item, layerinfo->geomcolumn) == 0 )
      continue;

    oid = PQftype(pgresult,i);
    fmod = PQfmod(pgresult,i);

    if( (oid == BPCHAROID || oid == VARCHAROID) && fmod >= 4 ) {
      sprintf( gml_width, ""%d"", fmod-4 );

    } else if( oid == BOOLOID ) {
      gml_type = ""Integer"";
      sprintf( gml_width, ""%d"", 1 );

    } else if( oid == INT2OID ) {
      gml_type = ""Integer"";
      sprintf( gml_width, ""%d"", 5 );

    } else if( oid == INT4OID || oid == INT8OID ) {
      gml_type = ""Integer"";

    } else if( oid == FLOAT4OID || oid == FLOAT8OID ) {
      gml_type = ""Real"";

    } else if( oid == NUMERICOID ) {
      gml_type = ""Real"";

      if( fmod >= 4 && ((fmod - 4) & 0xFFFF) == 0 ) {
        gml_type = ""Integer"";
        sprintf( gml_width, ""%d"", (fmod - 4) >> 16 );
      } else if( fmod >= 4 ) {
        sprintf( gml_width, ""%d"", (fmod - 4) >> 16 );
        sprintf( gml_precision, ""%d"", ((fmod-4) & 0xFFFF) );
      }
    } else if( oid == DATEOID
               || oid == TIMESTAMPOID || oid == TIMESTAMPTZOID ) {
      gml_type = ""Date"";
    }

    snprintf( md_item_name, sizeof(md_item_name), ""gml_%s_type"", item );
    if( msOWSLookupMetadata(&(layer->metadata), ""G"", ""type"") == NULL )
      msInsertHashTable(&(layer->metadata), md_item_name, gml_type );

    snprintf( md_item_name, sizeof(md_item_name), ""gml_%s_width"", item );
    if( strlen(gml_width) > 0
        && msOWSLookupMetadata(&(layer->metadata), ""G"", ""width"") == NULL )
      msInsertHashTable(&(layer->metadata), md_item_name, gml_width );

    snprintf( md_item_name, sizeof(md_item_name), ""gml_%s_precision"",item );
    if( strlen(gml_precision) > 0
        && msOWSLookupMetadata(&(layer->metadata), ""G"", ""precision"")==NULL )
      msInsertHashTable(&(layer->metadata), md_item_name, gml_precision );
  }
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,140213422150158647452544722938450335348,,
"int msPostGISReadShape(layerObj *layer, shapeObj *shape)
{

  char *wkbstr = NULL;
  unsigned char wkbstatic[wkbstaticsize];
  unsigned char *wkb = NULL;
  wkbObj w;
  msPostGISLayerInfo *layerinfo = NULL;
  int result = 0;
  int wkbstrlen = 0;

  if (layer->debug) {
    msDebug(""msPostGISReadShape called.\n"");
  }

  assert(layer->layerinfo != NULL);
  layerinfo = (msPostGISLayerInfo*) layer->layerinfo;

  /* Retrieve the geometry. */
  wkbstr = (char*)PQgetvalue(layerinfo->pgresult, layerinfo->rownum, layer->numitems );
  wkbstrlen = PQgetlength(layerinfo->pgresult, layerinfo->rownum, layer->numitems);

  if ( ! wkbstr ) {
    msSetError(MS_QUERYERR, ""Base64 WKB returned is null!"", ""msPostGISReadShape()"");
    return MS_FAILURE;
  }

  if(wkbstrlen > wkbstaticsize) {
    wkb = calloc(wkbstrlen, sizeof(char));
  } else {
    wkb = wkbstatic;
  }
#if TRANSFER_ENCODING == 64
  result = msPostGISBase64Decode(wkb, wkbstr, wkbstrlen - 1);
#else
  result = msPostGISHexDecode(wkb, wkbstr, wkbstrlen);
#endif

  if( ! result ) {
    if(wkb!=wkbstatic) free(wkb);
    return MS_FAILURE;
  }

  /* Initialize our wkbObj */
  w.wkb = (char*)wkb;
  w.ptr = w.wkb;
  w.size = (wkbstrlen - 1)/2;

  /* Set the type map according to what version of PostGIS we are dealing with */
  if( layerinfo->version >= 20000 ) /* PostGIS 2.0+ */
    w.typemap = wkb_postgis20;
  else
    w.typemap = wkb_postgis15;

  switch (layer->type) {

    case MS_LAYER_POINT:
      shape->type = MS_SHAPE_POINT;
      result = wkbConvGeometryToShape(&w, shape);
      break;

    case MS_LAYER_LINE:
      shape->type = MS_SHAPE_LINE;
      result = wkbConvGeometryToShape(&w, shape);
      break;

    case MS_LAYER_POLYGON:
      shape->type = MS_SHAPE_POLYGON;
      result = wkbConvGeometryToShape(&w, shape);
      break;

    case MS_LAYER_ANNOTATION:
    case MS_LAYER_QUERY:
    case MS_LAYER_CHART:
      result = msPostGISFindBestType(&w, shape);
      break;

    case MS_LAYER_RASTER:
      msDebug(""Ignoring MS_LAYER_RASTER in msPostGISReadShape.\n"");
      break;

    case MS_LAYER_CIRCLE:
      msDebug(""Ignoring MS_LAYER_RASTER in msPostGISReadShape.\n"");
      break;

    default:
      msDebug(""Unsupported layer type in msPostGISReadShape()!\n"");
      break;
  }

  /* All done with WKB geometry, free it! */
  if(wkb!=wkbstatic) free(wkb);

  if (result != MS_FAILURE) {
    int t;
    long uid;
    char *tmp;
    /* Found a drawable shape, so now retreive the attributes. */

    shape->values = (char**) msSmallMalloc(sizeof(char*) * layer->numitems);
    for ( t = 0; t < layer->numitems; t++) {
      int size = PQgetlength(layerinfo->pgresult, layerinfo->rownum, t);
      char *val = (char*)PQgetvalue(layerinfo->pgresult, layerinfo->rownum, t);
      int isnull = PQgetisnull(layerinfo->pgresult, layerinfo->rownum, t);
      if ( isnull ) {
        shape->values[t] = msStrdup("""");
      } else {
        shape->values[t] = (char*) msSmallMalloc(size + 1);
        memcpy(shape->values[t], val, size);
        shape->values[t][size] = '\0'; /* null terminate it */
        msStringTrimBlanks(shape->values[t]);
      }
      if( layer->debug > 4 ) {
        msDebug(""msPostGISReadShape: PQgetlength = %d\n"", size);
      }
      if( layer->debug > 1 ) {
        msDebug(""msPostGISReadShape: [%s] \""%s\""\n"", layer->items[t], shape->values[t]);
      }
    }

    /* t is the geometry, t+1 is the uid */
    tmp = PQgetvalue(layerinfo->pgresult, layerinfo->rownum, t + 1);
    if( tmp ) {
      uid = strtol( tmp, NULL, 10 );
    } else {
      uid = 0;
    }
    if( layer->debug > 4 ) {
      msDebug(""msPostGISReadShape: Setting shape->index = %d\n"", uid);
      msDebug(""msPostGISReadShape: Setting shape->resultindex = %d\n"", layerinfo->rownum);
    }
    shape->index = uid;
    shape->resultindex = layerinfo->rownum;

    if( layer->debug > 2 ) {
      msDebug(""msPostGISReadShape: [index] %d\n"",  shape->index);
    }

    shape->numvalues = layer->numitems;

    msComputeBounds(shape);
  }

  if( layer->debug > 2 ) {
    char *tmp = msShapeToWKT(shape);
    msDebug(""msPostGISReadShape: [shape] %s\n"", tmp);
    free(tmp);
  }

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,234585256080074357429147410861627152438,,
"static char *msPostGISReplaceBoxToken(layerObj *layer, rectObj *rect, const char *fromsource)
{
  char *result = NULL;

  if ( strstr(fromsource, BOXTOKEN) && rect ) {
    char *strBox = NULL;
    char *strSRID = NULL;

    /* We see to set the SRID on the box, but to what SRID? */
    strSRID = msPostGISBuildSQLSRID(layer);
    if ( ! strSRID ) {
      return NULL;
    }

    /* Create a suitable SQL string from the rectangle and SRID. */
    strBox = msPostGISBuildSQLBox(layer, rect, strSRID);
    if ( ! strBox ) {
      msSetError(MS_MISCERR, ""Unable to build box SQL."", ""msPostGISReplaceBoxToken()"");
      if (strSRID) free(strSRID);
      return NULL;
    }

    /* Do the substitution. */
    while ( strstr(fromsource, BOXTOKEN) ) {
      char    *start, *end;
      char    *oldresult = result;
      size_t buffer_size = 0;
      start = strstr(fromsource, BOXTOKEN);
      end = start + BOXTOKENLENGTH;

      buffer_size = (start - fromsource) + strlen(strBox) + strlen(end) +1;
      result = (char*)msSmallMalloc(buffer_size);

      strlcpy(result, fromsource, start - fromsource +1);
      strlcpy(result + (start - fromsource), strBox, buffer_size-(start - fromsource));
      strlcat(result, end, buffer_size);

      fromsource = result;
      if (oldresult != NULL)
        free(oldresult);
    }

    if (strSRID) free(strSRID);
    if (strBox) free(strBox);
  } else {
    result = msStrdup(fromsource);
  }
  return result;

}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,1728729636571590189038244204188881357,,
"msPostGISRetrievePK(layerObj *layer)
{
  PGresult *pgresult = NULL;
  char *sql = 0;
  size_t size;
  msPostGISLayerInfo *layerinfo = 0;
  int length;
  int pgVersion;
  char *pos_sep;
  char *schema = NULL;
  char *table = NULL;

  if (layer->debug) {
    msDebug(""msPostGISRetrievePK called.\n"");
  }

  layerinfo = (msPostGISLayerInfo *) layer->layerinfo;

  /* Attempt to separate fromsource into schema.table */
  pos_sep = strstr(layerinfo->fromsource, ""."");
  if (pos_sep) {
    length = strlen(layerinfo->fromsource) - strlen(pos_sep) + 1;
    schema = (char*)msSmallMalloc(length);
    strlcpy(schema, layerinfo->fromsource, length);

    length = strlen(pos_sep);
    table = (char*)msSmallMalloc(length);
    strlcpy(table, pos_sep + 1, length);

    if (layer->debug) {
      msDebug(""msPostGISRetrievePK(): Found schema %s, table %s.\n"", schema, table);
    }
  }

  if (layerinfo->pgconn == NULL) {
    msSetError(MS_QUERYERR, ""Layer does not have a postgis connection."", ""msPostGISRetrievePK()"");
    return MS_FAILURE;
  }
  pgVersion = msPostGISRetrievePgVersion(layerinfo->pgconn);

  if (pgVersion < 70000) {
    if (layer->debug) {
      msDebug(""msPostGISRetrievePK(): Major version below 7.\n"");
    }
    return MS_FAILURE;
  }
  if (pgVersion < 70200) {
    if (layer->debug) {
      msDebug(""msPostGISRetrievePK(): Version below 7.2.\n"");
    }
    return MS_FAILURE;
  }
  if (pgVersion < 70300) {
    /*
    ** PostgreSQL v7.2 has a different representation of primary keys that
    ** later versions.  This currently does not explicitly exclude
    ** multicolumn primary keys.
    */
    static char *v72sql = ""select b.attname from pg_class as a, pg_attribute as b, (select oid from pg_class where relname = '%s') as c, pg_index as d where d.indexrelid = a.oid and d.indrelid = c.oid and d.indisprimary and b.attrelid = a.oid and a.relnatts = 1"";
    sql = msSmallMalloc(strlen(layerinfo->fromsource) + strlen(v72sql));
    sprintf(sql, v72sql, layerinfo->fromsource);
  } else {
    /*
    ** PostgreSQL v7.3 and later treat primary keys as constraints.
    ** We only support single column primary keys, so multicolumn
    ** pks are explicitly excluded from the query.
    */
    if (schema && table) {
      static char *v73sql = ""select attname from pg_attribute, pg_constraint, pg_class, pg_namespace where pg_constraint.conrelid = pg_class.oid and pg_class.oid = pg_attribute.attrelid and pg_constraint.contype = 'p' and pg_constraint.conkey[1] = pg_attribute.attnum and pg_class.relname = '%s' and pg_class.relnamespace = pg_namespace.oid and pg_namespace.nspname = '%s' and pg_constraint.conkey[2] is null"";
      sql = msSmallMalloc(strlen(schema) + strlen(table) + strlen(v73sql));
      sprintf(sql, v73sql, table, schema);
      free(table);
      free(schema);
    } else {
      static char *v73sql = ""select attname from pg_attribute, pg_constraint, pg_class where pg_constraint.conrelid = pg_class.oid and pg_class.oid = pg_attribute.attrelid and pg_constraint.contype = 'p' and pg_constraint.conkey[1] = pg_attribute.attnum and pg_class.relname = '%s' and pg_table_is_visible(pg_class.oid) and pg_constraint.conkey[2] is null"";
      sql = msSmallMalloc(strlen(layerinfo->fromsource) + strlen(v73sql));
      sprintf(sql, v73sql, layerinfo->fromsource);
    }
  }

  if (layer->debug > 1) {
    msDebug(""msPostGISRetrievePK: %s\n"", sql);
  }

  layerinfo = (msPostGISLayerInfo *) layer->layerinfo;

  if (layerinfo->pgconn == NULL) {
    msSetError(MS_QUERYERR, ""Layer does not have a postgis connection."", ""msPostGISRetrievePK()"");
    free(sql);
    return MS_FAILURE;
  }

  pgresult = PQexecParams(layerinfo->pgconn, sql, 0, NULL, NULL, NULL, NULL, 0);
  if ( !pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {
    static char *tmp1 = ""Error executing SQL: "";
    char *tmp2 = NULL;
    size_t size2;

    size2 = sizeof(char)*(strlen(tmp1) + strlen(sql) + 1);
    tmp2 = (char*)msSmallMalloc(size2);
    strlcpy(tmp2, tmp1, size2);
    strlcat(tmp2, sql, size2);
    msSetError(MS_QUERYERR, tmp2, ""msPostGISRetrievePK()"");
    free(tmp2);
    free(sql);
    return MS_FAILURE;
  }

  if (PQntuples(pgresult) < 1) {
    if (layer->debug) {
      msDebug(""msPostGISRetrievePK: No results found.\n"");
    }
    PQclear(pgresult);
    free(sql);
    return MS_FAILURE;
  }
  if (PQntuples(pgresult) > 1) {
    if (layer->debug) {
      msDebug(""msPostGISRetrievePK: Multiple results found.\n"");
    }
    PQclear(pgresult);
    free(sql);
    return MS_FAILURE;
  }

  if (PQgetisnull(pgresult, 0, 0)) {
    if (layer->debug) {
      msDebug(""msPostGISRetrievePK: Null result returned.\n"");
    }
    PQclear(pgresult);
    free(sql);
    return MS_FAILURE;
  }

  size = PQgetlength(pgresult, 0, 0) + 1;
  layerinfo->uid = (char*)msSmallMalloc(size);
  strlcpy(layerinfo->uid, PQgetvalue(pgresult, 0, 0), size);

  PQclear(pgresult);
  free(sql);
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,297159965786304322347215169634581632192,,
"msPostGISRetrievePgVersion(PGconn *pgconn)
{
#ifndef POSTGIS_HAS_SERVER_VERSION
  int pgVersion = 0;
  char *strVersion = NULL;
  char *strParts[3] = { NULL, NULL, NULL };
  int i = 0, j = 0, len = 0;
  int factor = 10000;

  if (pgconn == NULL) {
    msSetError(MS_QUERYERR, ""Layer does not have a postgis connection."", ""msPostGISRetrievePgVersion()"");
    return MS_FAILURE;
  }

  if (! PQparameterStatus(pgconn, ""server_version"") )
    return MS_FAILURE;

  strVersion = msStrdup(PQparameterStatus(pgconn, ""server_version""));
  if( ! strVersion )
    return MS_FAILURE;

  strParts[j] = strVersion;
  j++;
  len = strlen(strVersion);
  for( i = 0; i < len; i++ ) {
    if( strVersion[i] == '.' ) {
      strVersion[i] = '\0';

      if( j < 3 ) {
        strParts[j] = strVersion + i + 1;
        j++;
      } else {
        free(strVersion);
        msSetError(MS_QUERYERR, ""Too many parts in version string."", ""msPostGISRetrievePgVersion()"");
        return MS_FAILURE;
      }
    }
  }

  for( j = 0; j < 3 && strParts[j]; j++ ) {
    pgVersion += factor * atoi(strParts[j]);
    factor = factor / 100;
  }
  free(strVersion);
  return pgVersion;
#else
  return PQserverVersion(pgconn);
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,339126460621514598644767797263109878893,,
"msPostGISRetrieveVersion(PGconn *pgconn)
{
  static char* sql = ""SELECT postgis_version()"";
  int version = 0;
  size_t strSize;
  char *strVersion = NULL;
  char *ptr;
  char *strParts[3] = { NULL, NULL, NULL };
  int i = 0, j = 0;
  int factor = 10000;
  PGresult *pgresult = NULL;

  if ( ! pgconn ) {
    msSetError(MS_QUERYERR, ""No open connection."", ""msPostGISRetrieveVersion()"");
    return MS_FAILURE;
  }

  pgresult = PQexecParams(pgconn, sql,0, NULL, NULL, NULL, NULL, 0);

  if ( !pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {
    msSetError(MS_QUERYERR, ""Error executing SQL: %s"", ""msPostGISRetrieveVersion()"", sql);
    return MS_FAILURE;
  }

  if (PQgetisnull(pgresult, 0, 0)) {
    PQclear(pgresult);
    msSetError(MS_QUERYERR,""Null result returned."",""msPostGISRetrieveVersion()"");
    return MS_FAILURE;
  }

  strSize = PQgetlength(pgresult, 0, 0) + 1;
  strVersion = (char*)msSmallMalloc(strSize);
  strlcpy(strVersion, PQgetvalue(pgresult, 0, 0), strSize);
  PQclear(pgresult);

  ptr = strVersion;
  strParts[j++] = strVersion;
  while( ptr != '\0' && j < 3 ) {
    if ( *ptr == '.' ) {
      *ptr = '\0';
      strParts[j++] = ptr + 1;
    }
    if ( *ptr == ' ' ) {
      *ptr = '\0';
      break;
    }
    ptr++;
  }

  for( i = 0; i < j; i++ ) {
    version += factor * atoi(strParts[i]);
    factor = factor / 100;
  }
  free(strVersion);

  return version;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,218760003602065866448382536378248202743,,
"pointArrayAddPoint(pointArrayObj *d, const pointObj *p)
{
  if ( !p || !d ) return MS_FAILURE;
  /* Avoid overwriting memory buffer */
  if ( d->maxpoints - d->npoints == 0 ) {
    d->maxpoints *= 2;
    d->data = realloc(d->data, d->maxpoints * sizeof(pointObj));
  }
  d->data[d->npoints] = *p;
  d->npoints++;
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,76737100811039277081221012728007963189,,
"pointArrayFree(pointArrayObj *d)
{
  if ( ! d ) return;
  if ( d->data ) free(d->data);
  free(d);
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,201762556813746346109204356635271813006,,
"pointArrayNew(int maxpoints)
{
  pointArrayObj *d = msSmallMalloc(sizeof(pointArrayObj));
  if ( maxpoints < 1 ) maxpoints = 1; /* Avoid a degenerate case */
  d->maxpoints = maxpoints;
  d->data = msSmallMalloc(maxpoints * sizeof(pointObj));
  d->npoints = 0;
  return d;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,301716156939950467252939377521487230029,,
"int postgresTimeStampForTimeString(const char *timestring, char *dest, size_t destsize)
{
  int nlength = strlen(timestring);
  int timeresolution = msTimeGetResolution(timestring);
  int bNoDate = (*timestring == 'T');
  if (timeresolution < 0)
    return MS_FALSE;

  switch(timeresolution) {
    case TIME_RESOLUTION_YEAR:
      if (timestring[nlength-1] != '-') {
        snprintf(dest, destsize,""date '%s-01-01'"",timestring);
      } else {
        snprintf(dest, destsize,""date '%s01-01'"",timestring);
      }
      break;
    case TIME_RESOLUTION_MONTH:
      if (timestring[nlength-1] != '-') {
        snprintf(dest, destsize,""date '%s-01'"",timestring);
      } else {
        snprintf(dest, destsize,""date '%s01'"",timestring);
      }
      break;
    case TIME_RESOLUTION_DAY:
      snprintf(dest, destsize,""date '%s'"",timestring);
      break;
    case TIME_RESOLUTION_HOUR:
      if (timestring[nlength-1] != ':') {
        if(bNoDate)
          snprintf(dest, destsize,""time '%s:00:00'"", timestring);
        else
          snprintf(dest, destsize,""timestamp '%s:00:00'"", timestring);
      } else {
        if(bNoDate)
          snprintf(dest, destsize,""time '%s00:00'"", timestring);
        else
          snprintf(dest, destsize,""timestamp '%s00:00'"", timestring);
      }
      break;
    case TIME_RESOLUTION_MINUTE:
      if (timestring[nlength-1] != ':') {
        if(bNoDate)
          snprintf(dest, destsize,""time '%s:00'"", timestring);
        else
          snprintf(dest, destsize,""timestamp '%s:00'"", timestring);
      } else {
        if(bNoDate)
          snprintf(dest, destsize,""time '%s00'"", timestring);
        else
          snprintf(dest, destsize,""timestamp '%s00'"", timestring);
      }
      break;
    case TIME_RESOLUTION_SECOND:
      if(bNoDate)
         snprintf(dest, destsize,""time '%s'"", timestring);
      else
         snprintf(dest, destsize,""timestamp '%s'"", timestring);
      break;
    default:
      return MS_FAILURE;
  }
  return MS_SUCCESS;

}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,207025148588495610817620460441990580012,,
"void postresqlNoticeHandler(void *arg, const char *message)
{
  layerObj *lp;
  lp = (layerObj*)arg;

  if (lp->debug) {
    msDebug(""%s\n"", message);
  }
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,42750425915979108278684077321674475138,,
"wkbCollectionSubType(wkbObj *w)
{
  int t;
  memcpy(&t, (w->ptr + 1 + 4 + 4 + 1), sizeof(int));
  return wkbTypeMap(w,t);
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,122248720603523470548518997491003087476,,
"wkbConvCollectionToShape(wkbObj *w, shapeObj *shape)
{
  int i, ncomponents;
  int failures = 0;

  /*endian = */wkbReadChar(w);
  /*type = */wkbTypeMap(w,wkbReadInt(w));
  ncomponents = wkbReadInt(w);

  /*
  * If we can draw any portion of the collection, we will,
  * but if all the components fail, we will draw nothing.
  */
  for ( i = 0; i < ncomponents; i++ ) {
    if ( wkbConvGeometryToShape(w, shape) == MS_FAILURE ) {
      wkbSkipGeometry(w);
      failures++;
    }
  }
  if ( failures == ncomponents )
    return MS_FAILURE;
  else
    return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,164338519271424460798950417590817127398,,
"wkbConvCurvePolygonToShape(wkbObj *w, shapeObj *shape)
{
  int type, i, ncomponents;
  int failures = 0;
  int was_poly = ( shape->type == MS_SHAPE_POLYGON );

  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));
  ncomponents = wkbReadInt(w);

  if( type != WKB_CURVEPOLYGON ) return MS_FAILURE;

  /* Lower the allowed dimensionality so we can
  *  catch the linear ring components */
  shape->type = MS_SHAPE_LINE;

  for ( i = 0; i < ncomponents; i++ ) {
    if ( wkbConvGeometryToShape(w, shape) == MS_FAILURE ) {
      wkbSkipGeometry(w);
      failures++;
    }
  }

  /* Go back to expected dimensionality */
  if ( was_poly) shape->type = MS_SHAPE_POLYGON;

  if ( failures == ncomponents )
    return MS_FAILURE;
  else
    return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,175890588353096109254424698504531038,,
"wkbConvPointToShape(wkbObj *w, shapeObj *shape)
{
  int type;
  lineObj line;

  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));

  if( type != WKB_POINT ) return MS_FAILURE;

  if( ! (shape->type == MS_SHAPE_POINT) ) return MS_FAILURE;
  line.numpoints = 1;
  line.point = msSmallMalloc(sizeof(pointObj));
  line.point[0] = wkbReadPoint(w);
  msAddLineDirectly(shape, &line);
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,97744175765234221089803362552945455703,,
"wkbConvPolygonToShape(wkbObj *w, shapeObj *shape)
{
  int type;
  int i, nrings;
  lineObj line;

  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));

  if( type != WKB_POLYGON ) return MS_FAILURE;

  /* How many rings? */
  nrings = wkbReadInt(w);

  /* Add each ring to the shape */
  for( i = 0; i < nrings; i++ ) {
    wkbReadLine(w,&line);
    msAddLineDirectly(shape, &line);
  }

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,267701145573206463667786497433833079040,,
"wkbReadDouble(wkbObj *w)
{
  double d;
  memcpy(&d, w->ptr, sizeof(double));
  w->ptr += sizeof(double);
  return d;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,212908992545620687041465268184465896778,,
"wkbReadInt(wkbObj *w)
{
  int i;
  memcpy(&i, w->ptr, sizeof(int));
  w->ptr += sizeof(int);
  return i;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,33248819808847312041511278425694485381,,
"wkbReadLine(wkbObj *w, lineObj *line)
{
  int i;
  pointObj p;
  int npoints = wkbReadInt(w);

  line->numpoints = npoints;
  line->point = msSmallMalloc(npoints * sizeof(pointObj));
  for ( i = 0; i < npoints; i++ ) {
    wkbReadPointP(w, &p);
    line->point[i] = p;
  }
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,135410214543979648823757699774274883242,,
"wkbReadPoint(wkbObj *w)
{
  pointObj p;
  wkbReadPointP(w, &p);
  return p;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,197934971053398074441106400024646736422,,
"wkbSkipGeometry(wkbObj *w)
{
  int type, npoints, nrings, ngeoms, i;
  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));
  switch(type) {
    case WKB_POINT:
      w->ptr += 2 * sizeof(double);
      break;
    case WKB_CIRCULARSTRING:
    case WKB_LINESTRING:
      npoints = wkbReadInt(w);
      w->ptr += npoints * 2 * sizeof(double);
      break;
    case WKB_POLYGON:
      nrings = wkbReadInt(w);
      for ( i = 0; i < nrings; i++ ) {
        npoints = wkbReadInt(w);
        w->ptr += npoints * 2 * sizeof(double);
      }
      break;
    case WKB_MULTIPOINT:
    case WKB_MULTILINESTRING:
    case WKB_MULTIPOLYGON:
    case WKB_GEOMETRYCOLLECTION:
    case WKB_COMPOUNDCURVE:
    case WKB_CURVEPOLYGON:
    case WKB_MULTICURVE:
    case WKB_MULTISURFACE:
      ngeoms = wkbReadInt(w);
      for ( i = 0; i < ngeoms; i++ ) {
        wkbSkipGeometry(w);
      }
  }
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,235253763225886894768871373255514357565,,
"wkbType(wkbObj *w)
{
  int t;
  memcpy(&t, (w->ptr + 1), sizeof(int));
  return wkbTypeMap(w,t);
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,20762173888145525730102426670792688447,,
"		void CWebServer::AddUser(const unsigned long ID, const std::string &username, const std::string &password, const int userrights, const int activetabs)
		{
			std::vector<std::vector<std::string> > result = m_sql.safe_query(""SELECT COUNT(*) FROM SharedDevices WHERE (SharedUserID == '%d')"", ID);
			if (result.empty())
				return;

			_tWebUserPassword wtmp;
			wtmp.ID = ID;
			wtmp.Username = username;
			wtmp.Password = password;
			wtmp.userrights = (_eUserRights)userrights;
			wtmp.ActiveTabs = activetabs;
			wtmp.TotSensors = atoi(result[0][0].c_str());
			m_users.push_back(wtmp);

			m_pWebEm->AddUserPassword(ID, username, password, (_eUserRights)userrights, activetabs);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,317206963511615575286258480340656004274,,
"		CWebServer::CWebServer(void) : session_store()
		{
			m_pWebEm = NULL;
			m_bDoStop = false;
#ifdef WITH_OPENZWAVE
			m_ZW_Hwidx = -1;
#endif
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,27593487129730631470532581157659067853,,
"		void CWebServer::CleanSessions() {
			m_sql.safe_query(
				""DELETE FROM UserSessions WHERE ExpirationDate < datetime('now', 'localtime')"");
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,202929858496199700554339767487447983979,,
"		void CWebServer::ClearUserPasswords()
		{
			m_users.clear();
			m_pWebEm->ClearUserPasswords();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,57915641729439034077923666805875111709,,
"		void CWebServer::Cmd_AddHardware(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string name = CURLEncode::URLDecode(request::findValue(&req, ""name""));
			std::string senabled = request::findValue(&req, ""enabled"");
			std::string shtype = request::findValue(&req, ""htype"");
			std::string address = request::findValue(&req, ""address"");
			std::string sport = request::findValue(&req, ""port"");
			std::string username = CURLEncode::URLDecode(request::findValue(&req, ""username""));
			std::string password = CURLEncode::URLDecode(request::findValue(&req, ""password""));
			std::string extra = CURLEncode::URLDecode(request::findValue(&req, ""extra""));
			std::string sdatatimeout = request::findValue(&req, ""datatimeout"");
			if (
				(name.empty()) ||
				(senabled.empty()) ||
				(shtype.empty())
				)
				return;
			_eHardwareTypes htype = (_eHardwareTypes)atoi(shtype.c_str());

			int iDataTimeout = atoi(sdatatimeout.c_str());
			int mode1 = 0;
			int mode2 = 0;
			int mode3 = 0;
			int mode4 = 0;
			int mode5 = 0;
			int mode6 = 0;
			int port = atoi(sport.c_str());
			std::string mode1Str = request::findValue(&req, ""Mode1"");
			if (!mode1Str.empty()) {
				mode1 = atoi(mode1Str.c_str());
			}
			std::string mode2Str = request::findValue(&req, ""Mode2"");
			if (!mode2Str.empty()) {
				mode2 = atoi(mode2Str.c_str());
			}
			std::string mode3Str = request::findValue(&req, ""Mode3"");
			if (!mode3Str.empty()) {
				mode3 = atoi(mode3Str.c_str());
			}
			std::string mode4Str = request::findValue(&req, ""Mode4"");
			if (!mode4Str.empty()) {
				mode4 = atoi(mode4Str.c_str());
			}
			std::string mode5Str = request::findValue(&req, ""Mode5"");
			if (!mode5Str.empty()) {
				mode5 = atoi(mode5Str.c_str());
			}
			std::string mode6Str = request::findValue(&req, ""Mode6"");
			if (!mode6Str.empty()) {
				mode6 = atoi(mode6Str.c_str());
			}

			if (IsSerialDevice(htype))
			{
				if (sport.empty())
					return; //need to have a serial port

				if (htype == HTYPE_TeleinfoMeter) {
					m_sql.UpdatePreferencesVar(""SmartMeterType"", 0);
				}
			}
			else if (IsNetworkDevice(htype))
			{
				if (address.empty() || port == 0)
					return;

				if (htype == HTYPE_MySensorsMQTT || htype == HTYPE_MQTT) {
					std::string modeqStr = request::findValue(&req, ""mode1"");
					if (!modeqStr.empty()) {
						mode1 = atoi(modeqStr.c_str());
					}
				}

				if (htype == HTYPE_ECODEVICES) {
					m_sql.UpdatePreferencesVar(""SmartMeterType"", 0);
				}
			}
			else if (htype == HTYPE_DomoticzInternal) {
				return;
			}
			else if (htype == HTYPE_Domoticz) {
				if (address.empty() || port == 0)
					return;
			}
			else if (htype == HTYPE_TE923) {
			}
			else if (htype == HTYPE_VOLCRAFTCO20) {
			}
			else if (htype == HTYPE_System) {
				std::vector<std::vector<std::string> > result;
				result = m_sql.safe_query(""SELECT ID FROM Hardware WHERE (Type==%d)"", HTYPE_System);
				if (!result.empty())
					return;
			}
			else if (htype == HTYPE_1WIRE) {
			}
			else if (htype == HTYPE_Rtl433) {
			}
			else if (htype == HTYPE_Pinger) {
			}
			else if (htype == HTYPE_Kodi) {
			}
			else if (htype == HTYPE_PanasonicTV) {
			}
			else if (htype == HTYPE_LogitechMediaServer) {
			}
			else if (htype == HTYPE_RaspberryBMP085) {
			}
			else if (htype == HTYPE_RaspberryHTU21D) {
			}
			else if (htype == HTYPE_RaspberryTSL2561) {
			}
			else if (htype == HTYPE_RaspberryBME280) {
			}
			else if (htype == HTYPE_RaspberryMCP23017) {
			}
			else if (htype == HTYPE_Dummy) {
			}
			else if (htype == HTYPE_Tellstick) {
			}
			else if (htype == HTYPE_EVOHOME_SCRIPT || htype == HTYPE_EVOHOME_SERIAL || htype == HTYPE_EVOHOME_WEB || htype == HTYPE_EVOHOME_TCP) {
			}
			else if (htype == HTYPE_PiFace) {
			}
			else if (htype == HTYPE_HTTPPOLLER) {
			}
			else if (htype == HTYPE_BleBox) {
			}
			else if (htype == HTYPE_HEOS) {
			}
			else if (htype == HTYPE_Yeelight) {
			}
			else if (htype == HTYPE_XiaomiGateway) {
			}
			else if (htype == HTYPE_Arilux) {
			}
			else if (htype == HTYPE_USBtinGateway) {
			}
			else if (
				(htype == HTYPE_Wunderground) ||
				(htype == HTYPE_DarkSky) ||
				(htype == HTYPE_AccuWeather) ||
				(htype == HTYPE_OpenWeatherMap) ||
				(htype == HTYPE_ICYTHERMOSTAT) ||
				(htype == HTYPE_TOONTHERMOSTAT) ||
				(htype == HTYPE_AtagOne) ||
				(htype == HTYPE_PVOUTPUT_INPUT) ||
				(htype == HTYPE_NEST) ||
				(htype == HTYPE_ANNATHERMOSTAT) ||
				(htype == HTYPE_THERMOSMART) ||
				(htype == HTYPE_Tado) ||
				(htype == HTYPE_Netatmo)
				)
			{
				if (
					(username.empty()) ||
					(password.empty())
					)
					return;
			}
			else if (htype == HTYPE_SolarEdgeAPI)
			{
				if (
					(username.empty())
					)
					return;
			}
			else if (htype == HTYPE_Nest_OAuthAPI) {
				if (
					(username == """") &&
					(extra == ""||"")
					)
					return;
			}
			else if (htype == HTYPE_SBFSpot) {
				if (username.empty())
					return;
			}
			else if (htype == HTYPE_HARMONY_HUB) {
				if (
					(address.empty() || port == 0)
					)
					return;
			}
			else if (htype == HTYPE_Philips_Hue) {
				if (
					(username.empty()) ||
					(address.empty() || port == 0)
					)
					return;
				if (port == 0)
					port = 80;
			}
			else if (htype == HTYPE_WINDDELEN) {
				std::string mill_id = request::findValue(&req, ""Mode1"");
				if (
					(mill_id.empty()) ||
					(sport.empty())
					)

					return;
				mode1 = atoi(mill_id.c_str());
			}
			else if (htype == HTYPE_Honeywell) {
			}
			else if (htype == HTYPE_RaspberryGPIO) {
			}
			else if (htype == HTYPE_SysfsGpio) {
			}
			else if (htype == HTYPE_OpenWebNetTCP) {
			}
			else if (htype == HTYPE_Daikin) {
			}
			else if (htype == HTYPE_GoodweAPI) {
				if (username.empty())
					return;
			}
			else if (htype == HTYPE_PythonPlugin) {
			}
			else if (htype == HTYPE_RaspberryPCF8574) {
			}
			else if (htype == HTYPE_OpenWebNetUSB) {
			}
			else if (htype == HTYPE_IntergasInComfortLAN2RF) {
			}
			else if (htype == HTYPE_EnphaseAPI) {
			}
			else if (htype == HTYPE_EcoCompteur) {
			}
			else
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""AddHardware"";

			std::vector<std::vector<std::string> > result;

			if (htype == HTYPE_Domoticz)
			{
				if (password.size() != 32)
				{
					password = GenerateMD5Hash(password);
				}
			}
			else if ((htype == HTYPE_S0SmartMeterUSB) || (htype == HTYPE_S0SmartMeterTCP))
			{
				extra = ""0;1000;0;1000;0;1000;0;1000;0;1000"";
			}
			else if (htype == HTYPE_Pinger)
			{
				mode1 = 30;
				mode2 = 1000;
			}
			else if (htype == HTYPE_Kodi)
			{
				mode1 = 30;
				mode2 = 1000;
			}
			else if (htype == HTYPE_PanasonicTV)
			{
				mode1 = 30;
				mode2 = 1000;
			}
			else if (htype == HTYPE_LogitechMediaServer)
			{
				mode1 = 30;
				mode2 = 1000;
			}
			else if (htype == HTYPE_HEOS)
			{
				mode1 = 30;
				mode2 = 1000;
			}
			else if (htype == HTYPE_Tellstick)
			{
				mode1 = 4;
				mode2 = 500;
			}

			if (htype == HTYPE_HTTPPOLLER) {
				m_sql.safe_query(
					""INSERT INTO Hardware (Name, Enabled, Type, Address, Port, SerialPort, Username, Password, Extra, Mode1, Mode2, Mode3, Mode4, Mode5, Mode6, DataTimeout) VALUES ('%q',%d, %d,'%q',%d,'%q','%q','%q','%q','%q','%q', '%q', '%q', '%q', '%q', %d)"",
					name.c_str(),
					(senabled == ""true"") ? 1 : 0,
					htype,
					address.c_str(),
					port,
					sport.c_str(),
					username.c_str(),
					password.c_str(),
					extra.c_str(),
					mode1Str.c_str(), mode2Str.c_str(), mode3Str.c_str(), mode4Str.c_str(), mode5Str.c_str(), mode6Str.c_str(),
					iDataTimeout
				);
			}
			else if (htype == HTYPE_PythonPlugin) {
				sport = request::findValue(&req, ""serialport"");
				m_sql.safe_query(
					""INSERT INTO Hardware (Name, Enabled, Type, Address, Port, SerialPort, Username, Password, Extra, Mode1, Mode2, Mode3, Mode4, Mode5, Mode6, DataTimeout) VALUES ('%q',%d, %d,'%q',%d,'%q','%q','%q','%q','%q','%q', '%q', '%q', '%q', '%q', %d)"",
					name.c_str(),
					(senabled == ""true"") ? 1 : 0,
					htype,
					address.c_str(),
					port,
					sport.c_str(),
					username.c_str(),
					password.c_str(),
					extra.c_str(),
					mode1Str.c_str(), mode2Str.c_str(), mode3Str.c_str(), mode4Str.c_str(), mode5Str.c_str(), mode6Str.c_str(),
					iDataTimeout
				);
			}
			else if (
				(htype == HTYPE_RFXtrx433)||
				(htype == HTYPE_RFXtrx868)
				)
			{
				m_sql.safe_query(
					""INSERT INTO Hardware (Name, Enabled, Type, Address, Port, SerialPort, Username, Password, Mode1, Mode2, Mode3, Mode4, Mode5, Mode6, DataTimeout) VALUES ('%q',%d, %d,'%q',%d,'%q','%q','%q',%d,%d,%d,%d,%d,%d,%d)"",
					name.c_str(),
					(senabled == ""true"") ? 1 : 0,
					htype,
					address.c_str(),
					port,
					sport.c_str(),
					username.c_str(),
					password.c_str(),
					mode1, mode2, mode3, mode4, mode5, mode6,
					iDataTimeout
				);
				extra = ""0"";
			}
			else {
				m_sql.safe_query(
					""INSERT INTO Hardware (Name, Enabled, Type, Address, Port, SerialPort, Username, Password, Extra, Mode1, Mode2, Mode3, Mode4, Mode5, Mode6, DataTimeout) VALUES ('%q',%d, %d,'%q',%d,'%q','%q','%q','%q',%d,%d,%d,%d,%d,%d,%d)"",
					name.c_str(),
					(senabled == ""true"") ? 1 : 0,
					htype,
					address.c_str(),
					port,
					sport.c_str(),
					username.c_str(),
					password.c_str(),
					extra.c_str(),
					mode1, mode2, mode3, mode4, mode5, mode6,
					iDataTimeout
				);
			}

			result = m_sql.safe_query(""SELECT MAX(ID) FROM Hardware"");
			if (!result.empty())
			{
				std::vector<std::string> sd = result[0];
				int ID = atoi(sd[0].c_str());

				root[""idx""] = sd[0].c_str(); // OTO output the created ID for easier management on the caller side (if automated)

				m_mainworker.AddHardwareFromParams(ID, name, (senabled == ""true"") ? true : false, htype, address, port, sport, username, password, extra, mode1, mode2, mode3, mode4, mode5, mode6, iDataTimeout, true);
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,295186167863111004523236678007636486416,,
"		void CWebServer::Cmd_AddLogMessage(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string smessage = request::findValue(&req, ""message"");
			if (smessage.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""AddLogMessage"";

			_log.Log(LOG_STATUS, ""%s"", smessage.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,100252033626170092347142357554569389689,,
"		void CWebServer::Cmd_AddMobileDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string suuid = request::findValue(&req, ""uuid"");
			std::string ssenderid = request::findValue(&req, ""senderid"");
			std::string sname = request::findValue(&req, ""name"");
			std::string sdevtype = request::findValue(&req, ""devicetype"");
			std::string sactive = request::findValue(&req, ""active"");
			if (
				(suuid.empty()) ||
				(ssenderid.empty())
				)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""AddMobileDevice"";

			if (sactive.empty())
				sactive = ""1"";
			int iActive = (sactive == ""1"") ? 1 : 0;

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Name, DeviceType FROM MobileDevices WHERE (UUID=='%q')"", suuid.c_str());
			if (result.empty())
			{
				m_sql.safe_query(""INSERT INTO MobileDevices (Active,UUID,SenderID,Name,DeviceType) VALUES (%d,'%q','%q','%q','%q')"",
					iActive,
					suuid.c_str(),
					ssenderid.c_str(),
					sname.c_str(),
					sdevtype.c_str());
			}
			else
			{
				time_t now = mytime(NULL);
				struct tm ltime;
				localtime_r(&now, &ltime);
				m_sql.safe_query(""UPDATE MobileDevices SET Active=%d, SenderID='%q', LastUpdate='%04d-%02d-%02d %02d:%02d:%02d' WHERE (UUID == '%q')"",
					iActive,
					ssenderid.c_str(),
					ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday, ltime.tm_hour, ltime.tm_min, ltime.tm_sec,
					suuid.c_str()
				);

				std::string dname = result[0][1];
				std::string ddevtype = result[0][2];
				if (dname.empty() || ddevtype.empty())
				{
					m_sql.safe_query(""UPDATE MobileDevices SET Name='%q', DeviceType='%q' WHERE (UUID == '%q')"",
						sname.c_str(), sdevtype.c_str(),
						suuid.c_str()
					);
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,279086157378788756750603468621739712958,,
"		void CWebServer::Cmd_AddPlan(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string name = request::findValue(&req, ""name"");
			root[""status""] = ""OK"";
			root[""title""] = ""AddPlan"";
			m_sql.safe_query(
				""INSERT INTO Plans (Name) VALUES ('%q')"",
				name.c_str()
			);
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT MAX(ID) FROM Plans"");
			if (!result.empty())
			{
				std::vector<std::string> sd = result[0];
				int ID = atoi(sd[0].c_str());

				root[""idx""] = sd[0].c_str(); // OTO output the created ID for easier management on the caller side (if automated)
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,114937120571545681557265936679301428402,,
"		void CWebServer::Cmd_AddPlanActiveDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			std::string sactivetype = request::findValue(&req, ""activetype"");
			std::string activeidx = request::findValue(&req, ""activeidx"");
			if (
				(idx.empty()) ||
				(sactivetype.empty()) ||
				(activeidx.empty())
				)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""AddPlanActiveDevice"";

			int activetype = atoi(sactivetype.c_str());

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID FROM DeviceToPlansMap WHERE (DeviceRowID=='%q') AND (DevSceneType==%d) AND (PlanID=='%q')"",
				activeidx.c_str(), activetype, idx.c_str());
			if (result.empty())
			{
				m_sql.safe_query(
					""INSERT INTO DeviceToPlansMap (DevSceneType,DeviceRowID, PlanID) VALUES (%d,'%q','%q')"",
					activetype,
					activeidx.c_str(),
					idx.c_str()
				);
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,34628207497470415449666896848738241515,,
"		void CWebServer::Cmd_AddSceneCode(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sceneidx = request::findValue(&req, ""sceneidx"");
			std::string idx = request::findValue(&req, ""idx"");
			std::string cmnd = request::findValue(&req, ""cmnd"");
			if (
				(sceneidx.empty()) ||
				(idx.empty()) ||
				(cmnd.empty())
				)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""AddSceneCode"";

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT Activators, SceneType FROM Scenes WHERE (ID==%q)"", sceneidx.c_str());
			if (result.empty())
				return;
			std::string Activators = result[0][0];
			unsigned char scenetype = atoi(result[0][1].c_str());

			if (!Activators.empty())
			{
				std::vector<std::string> arrayActivators;
				StringSplit(Activators, "";"", arrayActivators);
				for (const auto & ittAct : arrayActivators)
				{
					std::string sCodeCmd = ittAct;

					std::vector<std::string> arrayCode;
					StringSplit(sCodeCmd, "":"", arrayCode);

					std::string sID = arrayCode[0];
					std::string sCode = """";
					if (arrayCode.size() == 2)
					{
						sCode = arrayCode[1];
					}

					if (sID == idx)
					{
						if (scenetype == 1)
							return; //Group does not work with separate codes, so already there
						if (sCode == cmnd)
							return; //same code, already there!
					}
				}
			}
			if (!Activators.empty())
				Activators += "";"";
			Activators += idx;
			if (scenetype == 0)
			{
				Activators += "":"" + cmnd;
			}
			m_sql.safe_query(""UPDATE Scenes SET Activators='%q' WHERE (ID==%q)"", Activators.c_str(), sceneidx.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,42758994760645838892068919000769963469,,
"		void CWebServer::Cmd_AddUserVariable(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string variablename = request::findValue(&req, ""vname"");
			std::string variablevalue = request::findValue(&req, ""vvalue"");
			std::string variabletype = request::findValue(&req, ""vtype"");
			if (
				(variablename.empty()) ||
				(variabletype.empty()) ||
				((variablevalue.empty()) && (variabletype != ""2""))
				)
				return;

			root[""title""] = ""AddUserVariable"";

			std::string errorMessage;
			if (!m_sql.AddUserVariable(variablename, (const _eUsrVariableType)atoi(variabletype.c_str()), variablevalue, errorMessage))
			{
				root[""status""] = ""ERR"";
				root[""message""] = errorMessage;
			}
			else {
				root[""status""] = ""OK"";
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,50259300174420684998570095018950098619,,
"		void CWebServer::Cmd_AllowNewHardware(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string sTimeout = request::findValue(&req, ""timeout"");
			if (sTimeout.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""AllowNewHardware"";

			m_sql.AllowNewHardwareTimer(atoi(sTimeout.c_str()));
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,35059949112669000479904718316423379401,,
"		void CWebServer::Cmd_ChangePlanDeviceOrder(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string planid = request::findValue(&req, ""planid"");
			std::string idx = request::findValue(&req, ""idx"");
			std::string sway = request::findValue(&req, ""way"");
			if (
				(planid.empty()) ||
				(idx.empty()) ||
				(sway.empty())
				)
				return;
			bool bGoUp = (sway == ""0"");

			std::string aOrder, oID, oOrder;

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT [Order] FROM DeviceToPlansMap WHERE ((ID=='%q') AND (PlanID=='%q'))"",
				idx.c_str(), planid.c_str());
			if (result.empty())
				return;
			aOrder = result[0][0];

			if (!bGoUp)
			{
				result = m_sql.safe_query(""SELECT ID, [Order] FROM DeviceToPlansMap WHERE (([Order]>'%q') AND (PlanID=='%q')) ORDER BY [Order] ASC"",
					aOrder.c_str(), planid.c_str());
				if (result.empty())
					return;
				oID = result[0][0];
				oOrder = result[0][1];
			}
			else
			{
				result = m_sql.safe_query(""SELECT ID, [Order] FROM DeviceToPlansMap WHERE (([Order]<'%q') AND (PlanID=='%q')) ORDER BY [Order] DESC"",
					aOrder.c_str(), planid.c_str());
				if (result.empty())
					return;
				oID = result[0][0];
				oOrder = result[0][1];
			}
			root[""status""] = ""OK"";
			root[""title""] = ""ChangePlanOrder"";

			m_sql.safe_query(""UPDATE DeviceToPlansMap SET [Order] = '%q' WHERE (ID='%q')"",
				oOrder.c_str(), idx.c_str());
			m_sql.safe_query(""UPDATE DeviceToPlansMap SET [Order] = '%q' WHERE (ID='%q')"",
				aOrder.c_str(), oID.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,119822179944771575851257132475741175623,,
"		void CWebServer::Cmd_ChangePlanOrder(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			std::string sway = request::findValue(&req, ""way"");
			if (sway.empty())
				return;
			bool bGoUp = (sway == ""0"");

			std::string aOrder, oID, oOrder;

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT [Order] FROM Plans WHERE (ID=='%q')"",
				idx.c_str());
			if (result.empty())
				return;
			aOrder = result[0][0];

			if (!bGoUp)
			{
				result = m_sql.safe_query(""SELECT ID, [Order] FROM Plans WHERE ([Order]>'%q') ORDER BY [Order] ASC"",
					aOrder.c_str());
				if (result.empty())
					return;
				oID = result[0][0];
				oOrder = result[0][1];
			}
			else
			{
				result = m_sql.safe_query(""SELECT ID, [Order] FROM Plans WHERE ([Order]<'%q') ORDER BY [Order] DESC"",
					aOrder.c_str());
				if (result.empty())
					return;
				oID = result[0][0];
				oOrder = result[0][1];
			}
			root[""status""] = ""OK"";
			root[""title""] = ""ChangePlanOrder"";

			m_sql.safe_query(""UPDATE Plans SET [Order] = '%q' WHERE (ID='%q')"",
				oOrder.c_str(), idx.c_str());
			m_sql.safe_query(""UPDATE Plans SET [Order] = '%q' WHERE (ID='%q')"",
				aOrder.c_str(), oID.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,152393739318284028013884035346976438216,,
"		void CWebServer::Cmd_CheckForUpdate(WebEmSession & session, const request& req, Json::Value &root)
		{
			bool bHaveUser = (session.username != """");
			int urights = 3;
			if (bHaveUser)
			{
				int iUser = FindUser(session.username.c_str());
				if (iUser != -1)
					urights = static_cast<int>(m_users[iUser].userrights);
			}
			root[""statuscode""] = urights;

			root[""status""] = ""OK"";
			root[""title""] = ""CheckForUpdate"";
			root[""HaveUpdate""] = false;
			root[""Revision""] = m_mainworker.m_iRevision;

			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin users may update
			}

			bool bIsForced = (request::findValue(&req, ""forced"") == ""true"");

			if (!bIsForced)
			{
				int nValue = 0;
				m_sql.GetPreferencesVar(""UseAutoUpdate"", nValue);
				if (nValue != 1)
				{
					return;
				}
			}

			root[""HaveUpdate""] = m_mainworker.IsUpdateAvailable(bIsForced);
			root[""DomoticzUpdateURL""] = m_mainworker.m_szDomoticzUpdateURL;
			root[""SystemName""] = m_mainworker.m_szSystemName;
			root[""Revision""] = m_mainworker.m_iRevision;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,40004635329424490244470756599716595253,,
"		void CWebServer::Cmd_ClearLog(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""ClearLog"";
			_log.ClearLog();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,338156621096850723491873963742778846992,,
"		void CWebServer::Cmd_ClearSceneCodes(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sceneidx = request::findValue(&req, ""sceneidx"");
			if (sceneidx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""ClearSceneCode"";

			m_sql.safe_query(""UPDATE Scenes SET Activators='' WHERE (ID==%q)"", sceneidx.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,27219881537456734604125629504227480699,,
"		void CWebServer::Cmd_ClearShortLog(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			root[""status""] = ""OK"";
			root[""title""] = ""ClearShortLog"";

			_log.Log(LOG_STATUS, ""Clearing Short Log..."");

			m_sql.ClearShortLog();

			_log.Log(LOG_STATUS, ""Short Log Cleared!"");
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,330449578341281072344753787676550863350,,
"		void CWebServer::Cmd_DeleteAllPlanDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""DeleteAllPlanDevices"";
			m_sql.safe_query(""DELETE FROM DeviceToPlansMap WHERE (PlanID == '%q')"", idx.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,338151553431380689912920930640906359606,,
"		void CWebServer::Cmd_DeleteCustomIcon(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""DeleteCustomIcon"";

			m_sql.safe_query(""DELETE FROM CustomImages WHERE (ID == %d)"", idx);

			for (const auto & itt : m_custom_light_icons)
			{
				if (itt.idx == idx + 100)
				{
					std::string IconFile16 = szWWWFolder + ""/images/"" + itt.RootFile + "".png"";
					std::string IconFile48On = szWWWFolder + ""/images/"" + itt.RootFile + ""48_On.png"";
					std::string IconFile48Off = szWWWFolder + ""/images/"" + itt.RootFile + ""48_Off.png"";
					std::remove(IconFile16.c_str());
					std::remove(IconFile48On.c_str());
					std::remove(IconFile48Off.c_str());
					break;
				}
			}
			ReloadCustomSwitchIcons();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,175782029270838171715569579097787266497,,
"		void CWebServer::Cmd_DeleteDatePoint(WebEmSession & session, const request& req, Json::Value &root)
		{
			const std::string idx = request::findValue(&req, ""idx"");
			const std::string Date = request::findValue(&req, ""date"");
			if (
				(idx.empty()) ||
				(Date.empty())
				)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""deletedatapoint"";
			m_sql.DeleteDataPoint(idx.c_str(), Date);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,171950916147113777389924565007353283680,,
"		void CWebServer::Cmd_DeleteMobileDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string suuid = request::findValue(&req, ""uuid"");
			if (suuid.empty())
				return;
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID FROM MobileDevices WHERE (UUID=='%q')"", suuid.c_str());
			if (result.empty())
				return;
			m_sql.safe_query(""DELETE FROM MobileDevices WHERE (UUID == '%q')"", suuid.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""DeleteMobileDevice"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,290336233516144742748075636371777266023,,
"		void CWebServer::Cmd_DeletePlan(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""DeletePlan"";
			m_sql.safe_query(
				""DELETE FROM DeviceToPlansMap WHERE (PlanID == '%q')"",
				idx.c_str()
			);
			m_sql.safe_query(
				""DELETE FROM Plans WHERE (ID == '%q')"",
				idx.c_str()
			);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,81669779681119154561752846864548553589,,
"		void CWebServer::Cmd_DeletePlanDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""DeletePlanDevice"";
			m_sql.safe_query(""DELETE FROM DeviceToPlansMap WHERE (ID == '%q')"", idx.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,226804600108611953937393747659130821865,,
"		void CWebServer::Cmd_DeleteUserVariable(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;

			m_sql.DeleteUserVariable(idx);
			root[""status""] = ""OK"";
			root[""title""] = ""DeleteUserVariable"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,259553956284443036072028555812041029403,,
"		void CWebServer::Cmd_DownloadReady(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (!m_mainworker.m_bHaveDownloadedDomoticzUpdate)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""DownloadReady"";
			root[""downloadok""] = (m_mainworker.m_bHaveDownloadedDomoticzUpdateSuccessFull) ? true : false;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,101636198631298952234697575787514202577,,
"		void CWebServer::Cmd_DownloadUpdate(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (!m_mainworker.StartDownloadUpdate())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""DownloadUpdate"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,259216870873041030855687106679111109090,,
"		void CWebServer::Cmd_ExcecuteScript(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string scriptname = request::findValue(&req, ""scriptname"");
			if (scriptname.empty())
				return;
			if (scriptname.find("".."") != std::string::npos)
				return;
#ifdef WIN32
			scriptname = szUserDataFolder + ""scripts\\"" + scriptname;
#else
			scriptname = szUserDataFolder + ""scripts/"" + scriptname;
#endif
			if (!file_exist(scriptname.c_str()))
				return;
			std::string script_params = request::findValue(&req, ""scriptparams"");
			std::string strparm = szUserDataFolder;
			if (!script_params.empty())
			{
				if (strparm.size() > 0)
					strparm += "" "" + script_params;
				else
					strparm = script_params;
			}
			std::string sdirect = request::findValue(&req, ""direct"");
			if (sdirect == ""true"")
			{
				_log.Log(LOG_STATUS, ""Executing script: %s"", scriptname.c_str());
#ifdef WIN32
				ShellExecute(NULL, ""open"", scriptname.c_str(), strparm.c_str(), NULL, SW_SHOWNORMAL);
#else
				std::string lscript = scriptname + "" "" + strparm;
				int ret = system(lscript.c_str());
				if (ret != 0)
				{
					_log.Log(LOG_ERROR, ""Error executing script command (%s). returned: %d"", lscript.c_str(), ret);
					return;
			}
#endif
		}
			else
			{
				m_sql.AddTaskItem(_tTaskItem::ExecuteScript(0.2f, scriptname, strparm));
			}
			root[""title""] = ""ExecuteScript"";
			root[""status""] = ""OK"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,196638826835139245907378592220585658870,,
"		void CWebServer::Cmd_GetActualHistory(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetActualHistory"";

			std::string historyfile = szUserDataFolder + ""History.txt"";

			std::ifstream infile;
			int ii = 0;
			infile.open(historyfile.c_str());
			std::string sLine;
			if (infile.is_open())
			{
				while (!infile.eof())
				{
					getline(infile, sLine);
					root[""LastLogTime""] = """";
					if (sLine.find(""Version "") == 0)
						root[""result""][ii][""level""] = 1;
					else
						root[""result""][ii][""level""] = 0;
					root[""result""][ii][""message""] = sLine;
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,42094417521530856861511970885926618063,,
"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,140565976440674751039928089230652393562,,
"		void CWebServer::Cmd_GetConfig(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights == -1)
			{
				session.reply_status = reply::forbidden;
				return;//Only auth user allowed
			}

			root[""status""] = ""OK"";
			root[""title""] = ""GetConfig"";

			bool bHaveUser = (session.username != """");
			int urights = 3;
			unsigned long UserID = 0;
			if (bHaveUser)
			{
				int iUser = FindUser(session.username.c_str());
				if (iUser != -1)
				{
					urights = static_cast<int>(m_users[iUser].userrights);
					UserID = m_users[iUser].ID;
				}

			}

			int nValue;
			std::string sValue;

			if (m_sql.GetPreferencesVar(""Language"", sValue))
			{
				root[""language""] = sValue;
			}
			if (m_sql.GetPreferencesVar(""DegreeDaysBaseTemperature"", sValue))
			{
				root[""DegreeDaysBaseTemperature""] = atof(sValue.c_str());
			}

			nValue = 0;
			int iDashboardType = 0;
			m_sql.GetPreferencesVar(""DashboardType"", iDashboardType);
			root[""DashboardType""] = iDashboardType;
			m_sql.GetPreferencesVar(""MobileType"", nValue);
			root[""MobileType""] = nValue;

			nValue = 1;
			m_sql.GetPreferencesVar(""5MinuteHistoryDays"", nValue);
			root[""FiveMinuteHistoryDays""] = nValue;

			nValue = 1;
			m_sql.GetPreferencesVar(""ShowUpdateEffect"", nValue);
			root[""result""][""ShowUpdatedEffect""] = (nValue == 1);

			root[""AllowWidgetOrdering""] = m_sql.m_bAllowWidgetOrdering;

			root[""WindScale""] = m_sql.m_windscale*10.0f;
			root[""WindSign""] = m_sql.m_windsign;
			root[""TempScale""] = m_sql.m_tempscale;
			root[""TempSign""] = m_sql.m_tempsign;

			std::string Latitude = ""1"";
			std::string Longitude = ""1"";
			if (m_sql.GetPreferencesVar(""Location"", nValue, sValue))
			{
				std::vector<std::string> strarray;
				StringSplit(sValue, "";"", strarray);

				if (strarray.size() == 2)
				{
					Latitude = strarray[0];
					Longitude = strarray[1];
				}
			}
			root[""Latitude""] = Latitude;
			root[""Longitude""] = Longitude;

#ifndef NOCLOUD
			bool bEnableTabProxy = request::get_req_header(&req, ""X-From-MyDomoticz"") != NULL;
#else
			bool bEnableTabProxy = false;
#endif
			int bEnableTabDashboard = 1;
			int bEnableTabFloorplans = 1;
			int bEnableTabLight = 1;
			int bEnableTabScenes = 1;
			int bEnableTabTemp = 1;
			int bEnableTabWeather = 1;
			int bEnableTabUtility = 1;
			int bEnableTabCustom = 1;

			std::vector<std::vector<std::string> > result;

			if ((UserID != 0) && (UserID != 10000))
			{
				result = m_sql.safe_query(""SELECT TabsEnabled FROM Users WHERE (ID==%lu)"",
					UserID);
				if (!result.empty())
				{
					int TabsEnabled = atoi(result[0][0].c_str());
					bEnableTabLight = (TabsEnabled&(1 << 0));
					bEnableTabScenes = (TabsEnabled&(1 << 1));
					bEnableTabTemp = (TabsEnabled&(1 << 2));
					bEnableTabWeather = (TabsEnabled&(1 << 3));
					bEnableTabUtility = (TabsEnabled&(1 << 4));
					bEnableTabCustom = (TabsEnabled&(1 << 5));
					bEnableTabFloorplans = (TabsEnabled&(1 << 6));
				}
			}
			else
			{
				m_sql.GetPreferencesVar(""EnableTabFloorplans"", bEnableTabFloorplans);
				m_sql.GetPreferencesVar(""EnableTabLights"", bEnableTabLight);
				m_sql.GetPreferencesVar(""EnableTabScenes"", bEnableTabScenes);
				m_sql.GetPreferencesVar(""EnableTabTemp"", bEnableTabTemp);
				m_sql.GetPreferencesVar(""EnableTabWeather"", bEnableTabWeather);
				m_sql.GetPreferencesVar(""EnableTabUtility"", bEnableTabUtility);
				m_sql.GetPreferencesVar(""EnableTabCustom"", bEnableTabCustom);
			}
			if (iDashboardType == 3)
			{
				bEnableTabFloorplans = 0;
			}
			root[""result""][""EnableTabProxy""] = bEnableTabProxy;
			root[""result""][""EnableTabDashboard""] = bEnableTabDashboard != 0;
			root[""result""][""EnableTabFloorplans""] = bEnableTabFloorplans != 0;
			root[""result""][""EnableTabLights""] = bEnableTabLight != 0;
			root[""result""][""EnableTabScenes""] = bEnableTabScenes != 0;
			root[""result""][""EnableTabTemp""] = bEnableTabTemp != 0;
			root[""result""][""EnableTabWeather""] = bEnableTabWeather != 0;
			root[""result""][""EnableTabUtility""] = bEnableTabUtility != 0;
			root[""result""][""EnableTabCustom""] = bEnableTabCustom != 0;

			if (bEnableTabCustom)
			{
				DIR *lDir;
				struct dirent *ent;
				std::string templatesFolder = szWWWFolder + ""/templates"";
				int iFile = 0;
				if ((lDir = opendir(templatesFolder.c_str())) != NULL)
				{
					while ((ent = readdir(lDir)) != NULL)
					{
						std::string filename = ent->d_name;
						size_t pos = filename.find("".htm"");
						if (pos != std::string::npos)
						{
							std::string shortfile = filename.substr(0, pos);
							root[""result""][""templates""][iFile++] = shortfile;
						}
					}
					closedir(lDir);
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,84984482811535464174789119792344964915,,
"		void CWebServer::Cmd_GetCosts(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			char szTmp[100];
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT Type, SubType, nValue, sValue FROM DeviceStatus WHERE (ID=='%q')"",
				idx.c_str());
			if (!result.empty())
			{
				std::vector<std::string> sd = result[0];

				int nValue = 0;
				root[""status""] = ""OK"";
				root[""title""] = ""GetElectraCosts"";
				m_sql.GetPreferencesVar(""CostEnergy"", nValue);
				root[""CostEnergy""] = nValue;
				m_sql.GetPreferencesVar(""CostEnergyT2"", nValue);
				root[""CostEnergyT2""] = nValue;
				m_sql.GetPreferencesVar(""CostEnergyR1"", nValue);
				root[""CostEnergyR1""] = nValue;
				m_sql.GetPreferencesVar(""CostEnergyR2"", nValue);
				root[""CostEnergyR2""] = nValue;
				m_sql.GetPreferencesVar(""CostGas"", nValue);
				root[""CostGas""] = nValue;
				m_sql.GetPreferencesVar(""CostWater"", nValue);
				root[""CostWater""] = nValue;

				int tValue = 1000;
				if (m_sql.GetPreferencesVar(""MeterDividerWater"", tValue))
				{
					root[""DividerWater""] = float(tValue);
				}

				unsigned char dType = atoi(sd[0].c_str());
				std::string sValue = sd[3];

				if (dType == pTypeP1Power)
				{

					std::vector<std::string> splitresults;
					StringSplit(sValue, "";"", splitresults);
					if (splitresults.size() != 6)
						return;

					float EnergyDivider = 1000.0f;
					if (m_sql.GetPreferencesVar(""MeterDividerEnergy"", tValue))
					{
						EnergyDivider = float(tValue);
					}

					unsigned long long powerusage1 = std::strtoull(splitresults[0].c_str(), nullptr, 10);
					unsigned long long powerusage2 = std::strtoull(splitresults[1].c_str(), nullptr, 10);
					unsigned long long powerdeliv1 = std::strtoull(splitresults[2].c_str(), nullptr, 10);
					unsigned long long powerdeliv2 = std::strtoull(splitresults[3].c_str(), nullptr, 10);
					unsigned long long usagecurrent = std::strtoull(splitresults[4].c_str(), nullptr, 10);
					unsigned long long delivcurrent = std::strtoull(splitresults[5].c_str(), nullptr, 10);

					powerdeliv1 = (powerdeliv1 < 10) ? 0 : powerdeliv1;
					powerdeliv2 = (powerdeliv2 < 10) ? 0 : powerdeliv2;

					sprintf(szTmp, ""%.03f"", float(powerusage1) / EnergyDivider);
					root[""CounterT1""] = szTmp;
					sprintf(szTmp, ""%.03f"", float(powerusage2) / EnergyDivider);
					root[""CounterT2""] = szTmp;
					sprintf(szTmp, ""%.03f"", float(powerdeliv1) / EnergyDivider);
					root[""CounterR1""] = szTmp;
					sprintf(szTmp, ""%.03f"", float(powerdeliv2) / EnergyDivider);
					root[""CounterR2""] = szTmp;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,260354388189883268546351037447504452621,,
"		void CWebServer::Cmd_GetCustomIconSet(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetCustomIconSet"";
			int ii = 0;
			for (const auto & itt : m_custom_light_icons)
			{
				if (itt.idx >= 100)
				{
					std::string IconFile16 = ""images/"" + itt.RootFile + "".png"";
					std::string IconFile48On = ""images/"" + itt.RootFile + ""48_On.png"";
					std::string IconFile48Off = ""images/"" + itt.RootFile + ""48_Off.png"";

					root[""result""][ii][""idx""] = itt.idx - 100;
					root[""result""][ii][""Title""] = itt.Title;
					root[""result""][ii][""Description""] = itt.Description;
					root[""result""][ii][""IconFile16""] = IconFile16;
					root[""result""][ii][""IconFile48On""] = IconFile48On;
					root[""result""][ii][""IconFile48Off""] = IconFile48Off;
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,5225942507711868183598493509587013106,,
"		void CWebServer::Cmd_GetDeviceValueOptionWording(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string idx = request::findValue(&req, ""idx"");
			std::string pos = request::findValue(&req, ""pos"");
			if ((idx.empty()) || (pos.empty()))
				return;
			std::string wording;
			wording = CBasePush::DropdownOptionsValue(atoi(idx.c_str()), atoi(pos.c_str()));
			root[""wording""] = wording;
			root[""status""] = ""OK"";
			root[""title""] = ""GetDeviceValueOptions"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,24444085760894489104607595504923659513,,
"		void CWebServer::Cmd_GetDeviceValueOptions(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			std::vector<std::string> result;
			result = CBasePush::DropdownOptions(atoi(idx.c_str()));
			if ((result.size() == 1) && result[0] == ""Status"") {
				root[""result""][0][""Value""] = 0;
				root[""result""][0][""Wording""] = result[0];
			}
			else {
				int ii = 0;
				for (const auto & itt : result)
				{
					std::string ddOption = itt;
					root[""result""][ii][""Value""] = ii + 1;
					root[""result""][ii][""Wording""] = ddOption.c_str();
					ii++;
				}

			}
			root[""status""] = ""OK"";
			root[""title""] = ""GetDeviceValueOptions"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,179085036940672319886086036322559184643,,
"		void CWebServer::Cmd_GetHardwareTypes(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			root[""status""] = ""OK"";
			root[""title""] = ""GetHardwareTypes"";
			std::map<std::string, int> _htypes;
			for (int ii = 0; ii < HTYPE_END; ii++)
			{
				bool bDoAdd = true;
#ifndef _DEBUG
#ifdef WIN32
				if (
					(ii == HTYPE_RaspberryBMP085) ||
					(ii == HTYPE_RaspberryHTU21D) ||
					(ii == HTYPE_RaspberryTSL2561) ||
					(ii == HTYPE_RaspberryPCF8574) ||
					(ii == HTYPE_RaspberryBME280) ||
					(ii == HTYPE_RaspberryMCP23017)
					)
				{
					bDoAdd = false;
				}
				else
				{
#ifndef WITH_LIBUSB
					if (
						(ii == HTYPE_VOLCRAFTCO20) ||
						(ii == HTYPE_TE923)
						)
					{
						bDoAdd = false;
					}
#endif

		}
#endif
#endif
#ifndef WITH_OPENZWAVE
				if (ii == HTYPE_OpenZWave)
					bDoAdd = false;
#endif
#ifndef WITH_GPIO
				if (ii == HTYPE_RaspberryGPIO)
				{
					bDoAdd = false;
				}

				if (ii == HTYPE_SysfsGpio)
				{
					bDoAdd = false;
				}
#endif
				if (ii == HTYPE_PythonPlugin)
					bDoAdd = false;
				if (bDoAdd)
					_htypes[Hardware_Type_Desc(ii)] = ii;
	}
			int ii = 0;
			for (const auto & itt : _htypes)
			{
				root[""result""][ii][""idx""] = itt.second;
				root[""result""][ii][""name""] = itt.first;
				ii++;
			}

#ifdef ENABLE_PYTHON
			PluginList(root[""result""]);
#endif
}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,267720109913093530859379052733461853792,,
"		void CWebServer::Cmd_GetLanguage(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string sValue;
			if (m_sql.GetPreferencesVar(""Language"", sValue))
			{
				root[""status""] = ""OK"";
				root[""title""] = ""GetLanguage"";
				root[""language""] = sValue;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,90645282608671539245611942870504569926,,
"		void CWebServer::Cmd_GetLog(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetLog"";

			time_t lastlogtime = 0;
			std::string slastlogtime = request::findValue(&req, ""lastlogtime"");
			if (slastlogtime != """")
			{
				std::stringstream s_str(slastlogtime);
				s_str >> lastlogtime;
			}

			_eLogLevel lLevel = LOG_NORM;
			std::string sloglevel = request::findValue(&req, ""loglevel"");
			if (!sloglevel.empty())
			{
				lLevel = (_eLogLevel)atoi(sloglevel.c_str());
			}

			std::list<CLogger::_tLogLineStruct> logmessages = _log.GetLog(lLevel);
			int ii = 0;
			for (const auto & itt : logmessages)
			{
				if (itt.logtime > lastlogtime)
				{
					std::stringstream szLogTime;
					szLogTime << itt.logtime;
					root[""LastLogTime""] = szLogTime.str();
					root[""result""][ii][""level""] = static_cast<int>(itt.level);
					root[""result""][ii][""message""] = itt.logmessage;
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,234014796222827568946010474488772257336,,
"		void CWebServer::Cmd_GetNewHistory(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetNewHistory"";

			std::string historyfile;
			int nValue;
			m_sql.GetPreferencesVar(""ReleaseChannel"", nValue);
			bool bIsBetaChannel = (nValue != 0);

			std::string szHistoryURL = ""https://www.domoticz.com/download.php?channel=stable&type=history"";
			if (bIsBetaChannel)
			{
				utsname my_uname;
				if (uname(&my_uname) < 0)
					return;

				std::string systemname = my_uname.sysname;
				std::string machine = my_uname.machine;
				std::transform(systemname.begin(), systemname.end(), systemname.begin(), ::tolower);

				if (machine == ""armv6l"")
				{
					machine = ""armv7l"";
				}

				if (((machine != ""armv6l"") && (machine != ""armv7l"") && (systemname != ""windows"") && (machine != ""x86_64"") && (machine != ""aarch64"")) || (strstr(my_uname.release, ""ARCH+"") != NULL))
					szHistoryURL = ""https://www.domoticz.com/download.php?channel=beta&type=history"";
				else
					szHistoryURL = ""https://www.domoticz.com/download.php?channel=beta&type=history&system="" + systemname + ""&machine="" + machine;
			}
			if (!HTTPClient::GET(szHistoryURL, historyfile))
			{
				historyfile = ""Unable to get Online History document !!"";
			}

			std::istringstream stream(historyfile);
			std::string sLine;
			int ii = 0;
			while (std::getline(stream, sLine))
			{
				root[""LastLogTime""] = """";
				if (sLine.find(""Version "") == 0)
					root[""result""][ii][""level""] = 1;
				else
					root[""result""][ii][""level""] = 0;
				root[""result""][ii][""message""] = sLine;
				ii++;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,266356571615558740694609038070718267927,,
"		void CWebServer::Cmd_GetPlanDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""GetPlanDevices"";

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, DevSceneType, DeviceRowID, [Order] FROM DeviceToPlansMap WHERE (PlanID=='%q') ORDER BY [Order]"",
				idx.c_str());
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					std::string ID = sd[0];
					int DevSceneType = atoi(sd[1].c_str());
					std::string DevSceneRowID = sd[2];

					std::string Name = """";
					if (DevSceneType == 0)
					{
						std::vector<std::vector<std::string> > result2;
						result2 = m_sql.safe_query(""SELECT Name FROM DeviceStatus WHERE (ID=='%q')"",
							DevSceneRowID.c_str());
						if (!result2.empty())
						{
							Name = result2[0][0];
						}
					}
					else
					{
						std::vector<std::vector<std::string> > result2;
						result2 = m_sql.safe_query(""SELECT Name FROM Scenes WHERE (ID=='%q')"",
							DevSceneRowID.c_str());
						if (!result2.empty())
						{
							Name = ""[Scene] "" + result2[0][0];
						}
					}
					if (Name != """")
					{
						root[""result""][ii][""idx""] = ID;
						root[""result""][ii][""devidx""] = DevSceneRowID;
						root[""result""][ii][""type""] = DevSceneType;
						root[""result""][ii][""DevSceneRowID""] = DevSceneRowID;
						root[""result""][ii][""order""] = sd[3];
						root[""result""][ii][""Name""] = Name;
						ii++;
					}
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,320177853661335332001613169481785988482,,
"		void CWebServer::Cmd_GetSceneActivations(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""GetSceneActivations"";

			std::vector<std::vector<std::string> > result, result2;
			result = m_sql.safe_query(""SELECT Activators, SceneType FROM Scenes WHERE (ID==%q)"", idx.c_str());
			if (result.empty())
				return;
			int ii = 0;
			std::string Activators = result[0][0];
			int SceneType = atoi(result[0][1].c_str());
			if (!Activators.empty())
			{
				std::vector<std::string> arrayActivators;
				StringSplit(Activators, "";"", arrayActivators);
				for (const auto & ittAct : arrayActivators)
				{
					std::string sCodeCmd = ittAct;

					std::vector<std::string> arrayCode;
					StringSplit(sCodeCmd, "":"", arrayCode);

					std::string sID = arrayCode[0];
					int sCode = 0;
					if (arrayCode.size() == 2)
					{
						sCode = atoi(arrayCode[1].c_str());
					}


					result2 = m_sql.safe_query(""SELECT Name, [Type], SubType, SwitchType FROM DeviceStatus WHERE (ID==%q)"", sID.c_str());
					if (!result2.empty())
					{
						std::vector<std::string> sd = result2[0];
						std::string lstatus = ""-"";
						if ((SceneType == 0) && (arrayCode.size() == 2))
						{
							unsigned char devType = (unsigned char)atoi(sd[1].c_str());
							unsigned char subType = (unsigned char)atoi(sd[2].c_str());
							_eSwitchType switchtype = (_eSwitchType)atoi(sd[3].c_str());
							int nValue = sCode;
							std::string sValue = """";
							int llevel = 0;
							bool bHaveDimmer = false;
							bool bHaveGroupCmd = false;
							int maxDimLevel = 0;
							GetLightStatus(devType, subType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);
						}
						uint64_t dID = std::strtoull(sID.c_str(), nullptr, 10);
						root[""result""][ii][""idx""] = dID;
						root[""result""][ii][""name""] = sd[0];
						root[""result""][ii][""code""] = sCode;
						root[""result""][ii][""codestr""] = lstatus;
						ii++;
					}
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,59856436037470373054086947445804594433,,
"		void CWebServer::Cmd_GetSerialDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetSerialDevices"";

			bool bUseDirectPath = false;
			std::vector<std::string> serialports = GetSerialPorts(bUseDirectPath);
			int ii = 0;
			for (const auto & itt : serialports)
			{
				root[""result""][ii][""name""] = itt;
				root[""result""][ii][""value""] = ii;
				ii++;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,186402324045141397529146715551569462096,,
"		void CWebServer::Cmd_GetThemes(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetThemes"";
			m_mainworker.GetAvailableWebThemes();
			int ii = 0;
			for (const auto & itt : m_mainworker.m_webthemes)
			{
				root[""result""][ii][""theme""] = itt;
				ii++;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,306270542320275335121843578507471756250,,
"		void CWebServer::Cmd_GetTitle(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string sValue;
			root[""status""] = ""OK"";
			root[""title""] = ""GetTitle"";
			if (m_sql.GetPreferencesVar(""Title"", sValue))
				root[""Title""] = sValue;
			else
				root[""Title""] = ""Domoticz"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,27463235804506207689212599615740554971,,
"		void CWebServer::Cmd_GetUptime(WebEmSession & session, const request& req, Json::Value &root)
		{
			time_t atime = mytime(NULL);
			time_t tuptime = atime - m_StartTime;
			tuptime = ((tuptime / 5) * 5) + 5;
			int days, hours, minutes, seconds;
			days = (int)(tuptime / 86400);
			tuptime -= (days * 86400);
			hours = (int)(tuptime / 3600);
			tuptime -= (hours * 3600);
			minutes = (int)(tuptime / 60);
			tuptime -= (minutes * 60);
			seconds = (int)tuptime;
			root[""status""] = ""OK"";
			root[""title""] = ""GetUptime"";
			root[""days""] = days;
			root[""hours""] = hours;
			root[""minutes""] = minutes;
			root[""seconds""] = seconds;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,297221803232362284707967316836013827639,,
"		void CWebServer::Cmd_GetUserVariable(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;

			int iVarID = atoi(idx.c_str());

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Name, ValueType, Value, LastUpdate FROM UserVariables WHERE (ID==%d)"", iVarID);
			int ii = 0;
			for (const auto & itt : result)
			{
				std::vector<std::string> sd = itt;
				root[""result""][ii][""idx""] = sd[0];
				root[""result""][ii][""Name""] = sd[1];
				root[""result""][ii][""Type""] = sd[2];
				root[""result""][ii][""Value""] = sd[3];
				root[""result""][ii][""LastUpdate""] = sd[4];
				ii++;
			}
			root[""status""] = ""OK"";
			root[""title""] = ""GetUserVariable"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,26865211040699695985143316568099695061,,
"		void CWebServer::Cmd_GetUserVariables(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Name, ValueType, Value, LastUpdate FROM UserVariables"");
			int ii = 0;
			for (const auto & itt : result)
			{
				std::vector<std::string> sd = itt;
				root[""result""][ii][""idx""] = sd[0];
				root[""result""][ii][""Name""] = sd[1];
				root[""result""][ii][""Type""] = sd[2];
				root[""result""][ii][""Value""] = sd[3];
				root[""result""][ii][""LastUpdate""] = sd[4];
				ii++;
			}
			root[""status""] = ""OK"";
			root[""title""] = ""GetUserVariables"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,36311878009344437864146962855388162576,,
"		void CWebServer::Cmd_GetVersion(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetVersion"";
			root[""version""] = szAppVersion;
			root[""hash""] = szAppHash;
			root[""build_time""] = szAppDate;
			CdzVents* dzvents = CdzVents::GetInstance();
			root[""dzvents_version""] = dzvents->GetVersion();
			root[""python_version""] = szPyVersion;

			if (session.rights != 2)
			{
				root[""UseUpdate""] = false;
				root[""HaveUpdate""] = false;
			}
			else
			{
				root[""UseUpdate""] = g_bUseUpdater;
				root[""HaveUpdate""] = m_mainworker.IsUpdateAvailable(false);
				root[""DomoticzUpdateURL""] = m_mainworker.m_szDomoticzUpdateURL;
				root[""SystemName""] = m_mainworker.m_szSystemName;
				root[""Revision""] = m_mainworker.m_iRevision;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,315419818511500202299637570268796158757,,
"		void CWebServer::Cmd_LoginCheck(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string tmpusrname = request::findValue(&req, ""username"");
			std::string tmpusrpass = request::findValue(&req, ""password"");
			if (
				(tmpusrname.empty()) ||
				(tmpusrpass.empty())
				)
				return;

			std::string rememberme = request::findValue(&req, ""rememberme"");

			std::string usrname;
			std::string usrpass;
			if (request_handler::url_decode(tmpusrname, usrname))
			{
				if (request_handler::url_decode(tmpusrpass, usrpass))
				{
					usrname = base64_decode(usrname);
					int iUser = FindUser(usrname.c_str());
					if (iUser == -1) {
						_log.Log(LOG_ERROR, ""Failed login attempt from %s for user '%s' !"", session.remote_host.c_str(), usrname.c_str());
						return;
					}
					if (m_users[iUser].Password != usrpass) {
						_log.Log(LOG_ERROR, ""Failed login attempt from %s for '%s' !"", session.remote_host.c_str(), m_users[iUser].Username.c_str());
						return;
					}
					_log.Log(LOG_STATUS, ""Login successful from %s for user '%s'"", session.remote_host.c_str(), m_users[iUser].Username.c_str());
					root[""status""] = ""OK"";
					root[""version""] = szAppVersion;
					root[""title""] = ""logincheck"";
					session.isnew = true;
					session.username = m_users[iUser].Username;
					session.rights = m_users[iUser].userrights;
					session.rememberme = (rememberme == ""true"");
					root[""user""] = session.username;
					root[""rights""] = session.rights;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,42759606687756702556124187195680807507,,
"		void CWebServer::Cmd_RemoveSceneCode(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sceneidx = request::findValue(&req, ""sceneidx"");
			std::string idx = request::findValue(&req, ""idx"");
			std::string code = request::findValue(&req, ""code"");
			if (
				(idx.empty()) ||
				(sceneidx.empty()) ||
				(code.empty())
				)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""RemoveSceneCode"";

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT Activators, SceneType FROM Scenes WHERE (ID==%q)"", sceneidx.c_str());
			if (result.empty())
				return;
			std::string Activators = result[0][0];
			int SceneType = atoi(result[0][1].c_str());
			if (!Activators.empty())
			{
				std::vector<std::string> arrayActivators;
				StringSplit(Activators, "";"", arrayActivators);
				std::string newActivation = """";
				for (const auto & ittAct : arrayActivators)
				{
					std::string sCodeCmd = ittAct;

					std::vector<std::string> arrayCode;
					StringSplit(sCodeCmd, "":"", arrayCode);

					std::string sID = arrayCode[0];
					std::string sCode = """";
					if (arrayCode.size() == 2)
					{
						sCode = arrayCode[1];
					}
					bool bFound = false;
					if (sID == idx)
					{
						if ((SceneType == 1) || (sCode.empty()))
						{
							bFound = true;
						}
						else
						{
							bFound = (sCode == code);
						}
					}
					if (!bFound)
					{
						if (!newActivation.empty())
							newActivation += "";"";
						newActivation += sID;
						if ((SceneType == 0) && (!sCode.empty()))
						{
							newActivation += "":"" + sCode;
						}
					}
				}
				if (Activators != newActivation)
				{
					m_sql.safe_query(""UPDATE Scenes SET Activators='%q' WHERE (ID==%q)"", newActivation.c_str(), sceneidx.c_str());
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,19491243884989665629906623794472650435,,
"		void CWebServer::Cmd_RenameDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			std::string sname = request::findValue(&req, ""name"");
			if (
				(sidx.empty()) ||
				(sname.empty())
				)
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""RenameDevice"";

			m_sql.safe_query(""UPDATE DeviceStatus SET Name='%q' WHERE (ID == %d)"", sname.c_str(), idx);
			uint64_t ullidx = std::strtoull(sidx.c_str(), nullptr, 10);
			m_mainworker.m_eventsystem.WWWUpdateSingleState(ullidx, sname, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,125868732530638512948878997304059116328,,
"		void CWebServer::Cmd_SendNotification(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string subject = request::findValue(&req, ""subject"");
			std::string body = request::findValue(&req, ""body"");
			std::string subsystem = request::findValue(&req, ""subsystem"");
			if (
				(subject.empty()) ||
				(body.empty())
				)
				return;
			if (subsystem.empty()) subsystem = NOTIFYALL;
			if (m_notifications.SendMessage(0, std::string(""""), subsystem, subject, body, std::string(""""), 1, std::string(""""), false)) {
				root[""status""] = ""OK"";
			}
			root[""title""] = ""SendNotification"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,50861748634213104351222541525821839479,,
"		void CWebServer::Cmd_SetPlanDeviceCoords(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			std::string planidx = request::findValue(&req, ""planidx"");
			std::string xoffset = request::findValue(&req, ""xoffset"");
			std::string yoffset = request::findValue(&req, ""yoffset"");
			std::string type = request::findValue(&req, ""DevSceneType"");
			if ((idx.empty()) || (planidx.empty()) || (xoffset.empty()) || (yoffset.empty()))
				return;
			if (type != ""1"") type = ""0"";  // 0 = Device, 1 = Scene/Group
			root[""status""] = ""OK"";
			root[""title""] = ""SetPlanDeviceCoords"";
			m_sql.safe_query(""UPDATE DeviceToPlansMap SET [XOffset] = '%q', [YOffset] = '%q' WHERE (DeviceRowID='%q') and (PlanID='%q') and (DevSceneType='%q')"",
				xoffset.c_str(), yoffset.c_str(), idx.c_str(), planidx.c_str(), type.c_str());
			_log.Log(LOG_STATUS, ""(Floorplan) Device '%s' coordinates set to '%s,%s' in plan '%s'."", idx.c_str(), xoffset.c_str(), yoffset.c_str(), planidx.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,227320739895162622068632066975227736147,,
"		void CWebServer::Cmd_SetSetpoint(WebEmSession & session, const request& req, Json::Value &root)
		{
			bool bHaveUser = (session.username != """");
			int iUser = -1;
			int urights = 3;
			if (bHaveUser)
			{
				iUser = FindUser(session.username.c_str());
				if (iUser != -1)
				{
					urights = static_cast<int>(m_users[iUser].userrights);
				}
			}
			if (urights < 1)
				return;

			std::string idx = request::findValue(&req, ""idx"");
			std::string setpoint = request::findValue(&req, ""setpoint"");
			if (
				(idx.empty()) ||
				(setpoint.empty())
				)
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""SetSetpoint"";
			if (iUser != -1)
			{
				_log.Log(LOG_STATUS, ""User: %s initiated a SetPoint command"", m_users[iUser].Username.c_str());
			}
			m_mainworker.SetSetPoint(idx, static_cast<float>(atof(setpoint.c_str())));
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,290247411312599173166094139404657180716,,
"		void CWebServer::Cmd_SetThermostatState(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string sstate = request::findValue(&req, ""state"");
			std::string idx = request::findValue(&req, ""idx"");
			std::string name = request::findValue(&req, ""name"");

			if (
				(idx.empty()) ||
				(sstate.empty())
				)
				return;
			int iState = atoi(sstate.c_str());

			int urights = 3;
			bool bHaveUser = (session.username != """");
			if (bHaveUser)
			{
				int iUser = FindUser(session.username.c_str());
				if (iUser != -1)
				{
					urights = static_cast<int>(m_users[iUser].userrights);
					_log.Log(LOG_STATUS, ""User: %s initiated a Thermostat State change command"", m_users[iUser].Username.c_str());
				}
			}
			if (urights < 1)
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""Set Thermostat State"";
			_log.Log(LOG_NORM, ""Setting Thermostat State...."");
			m_mainworker.SetThermostatState(idx, iState);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,63714659410676824744220964181695646420,,
"		void CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""SetUnused"";
			m_sql.safe_query(""UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)"", idx);
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);

#ifdef ENABLE_PYTHON
			m_mainworker.m_pluginsystem.DeviceModified(idx);
#endif
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,144103580184099603316680113534096518450,,
"		void CWebServer::Cmd_SystemReboot(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
#ifdef WIN32
			int ret = system(""shutdown -r -f -t 1 -d up:125:1"");
#else
			int ret = system(""sudo shutdown -r now"");
#endif
			if (ret != 0)
			{
				_log.Log(LOG_ERROR, ""Error executing reboot command. returned: %d"", ret);
				return;
			}
			root[""title""] = ""SystemReboot"";
			root[""status""] = ""OK"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,150877557865434748682107873388753852772,,
"		void CWebServer::Cmd_SystemShutdown(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
#ifdef WIN32
			int ret = system(""shutdown -s -f -t 1 -d up:125:1"");
#else
			int ret = system(""sudo shutdown -h now"");
#endif
			if (ret != 0)
			{
				_log.Log(LOG_ERROR, ""Error executing shutdown command. returned: %d"", ret);
				return;
			}
			root[""title""] = ""SystemShutdown"";
			root[""status""] = ""OK"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,66048904934580376614148602731837578453,,
"		void CWebServer::Cmd_UpdateDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights < 1)
			{
				session.reply_status = reply::forbidden;
				return; //only user or higher allowed
			}

			std::string idx = request::findValue(&req, ""idx"");

			if (!IsIdxForUser(&session, atoi(idx.c_str())))
			{
				_log.Log(LOG_ERROR, ""User: %s tried to update an Unauthorized device!"", session.username.c_str());
				session.reply_status = reply::forbidden;
				return;
			}

			std::string hid = request::findValue(&req, ""hid"");
			std::string did = request::findValue(&req, ""did"");
			std::string dunit = request::findValue(&req, ""dunit"");
			std::string dtype = request::findValue(&req, ""dtype"");
			std::string dsubtype = request::findValue(&req, ""dsubtype"");

			std::string nvalue = request::findValue(&req, ""nvalue"");
			std::string svalue = request::findValue(&req, ""svalue"");

			if ((nvalue.empty() && svalue.empty()))
			{
				return;
			}

			int signallevel = 12;
			int batterylevel = 255;

			if (idx.empty())
			{
				if (
					(hid.empty()) ||
					(did.empty()) ||
					(dunit.empty()) ||
					(dtype.empty()) ||
					(dsubtype.empty())
					)
					return;
			}
			else
			{
				std::vector<std::vector<std::string> > result;
				result = m_sql.safe_query(""SELECT HardwareID, DeviceID, Unit, Type, SubType FROM DeviceStatus WHERE (ID=='%q')"",
					idx.c_str());
				if (result.empty())
					return;
				hid = result[0][0];
				did = result[0][1];
				dunit = result[0][2];
				dtype = result[0][3];
				dsubtype = result[0][4];
			}

			int HardwareID = atoi(hid.c_str());
			std::string DeviceID = did;
			int unit = atoi(dunit.c_str());
			int devType = atoi(dtype.c_str());
			int subType = atoi(dsubtype.c_str());

			uint64_t ulIdx = std::strtoull(idx.c_str(), nullptr, 10);

			int invalue = atoi(nvalue.c_str());

			std::string sSignalLevel = request::findValue(&req, ""rssi"");
			if (sSignalLevel != """")
			{
				signallevel = atoi(sSignalLevel.c_str());
			}
			std::string sBatteryLevel = request::findValue(&req, ""battery"");
			if (sBatteryLevel != """")
			{
				batterylevel = atoi(sBatteryLevel.c_str());
			}
			if (m_mainworker.UpdateDevice(HardwareID, DeviceID, unit, devType, subType, invalue, svalue, signallevel, batterylevel))
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Update Device"";
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,193820761342060251358834927311655140536,,
"		void CWebServer::Cmd_UpdateDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string script = request::findValue(&req, ""script"");
			if (script.empty())
			{
				return;
			}
			std::string content = req.content;

			std::vector<std::string> allParameters;

			std::vector<std::string> allParts;
			StringSplit(req.uri, ""?"", allParts);
			if (!allParts.empty())
			{
				StringSplit(allParts[1], ""&"", allParameters);
			}

			CLuaHandler luaScript;
			bool ret = luaScript.executeLuaScript(script, content, allParameters);
			if (ret)
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Update Device"";
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,44078256413820531537241421112804415043,,
"		void CWebServer::Cmd_UpdateHardware(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			std::string name = CURLEncode::URLDecode(request::findValue(&req, ""name""));
			std::string senabled = request::findValue(&req, ""enabled"");
			std::string shtype = request::findValue(&req, ""htype"");
			std::string address = request::findValue(&req, ""address"");
			std::string sport = request::findValue(&req, ""port"");
			std::string username = CURLEncode::URLDecode(request::findValue(&req, ""username""));
			std::string password = CURLEncode::URLDecode(request::findValue(&req, ""password""));
			std::string extra = CURLEncode::URLDecode(request::findValue(&req, ""extra""));
			std::string sdatatimeout = request::findValue(&req, ""datatimeout"");

			if (
				(name.empty()) ||
				(senabled.empty()) ||
				(shtype.empty())
				)
				return;

			int mode1 = atoi(request::findValue(&req, ""Mode1"").c_str());
			int mode2 = atoi(request::findValue(&req, ""Mode2"").c_str());
			int mode3 = atoi(request::findValue(&req, ""Mode3"").c_str());
			int mode4 = atoi(request::findValue(&req, ""Mode4"").c_str());
			int mode5 = atoi(request::findValue(&req, ""Mode5"").c_str());
			int mode6 = atoi(request::findValue(&req, ""Mode6"").c_str());

			bool bEnabled = (senabled == ""true"") ? true : false;

			_eHardwareTypes htype = (_eHardwareTypes)atoi(shtype.c_str());
			int iDataTimeout = atoi(sdatatimeout.c_str());

			int port = atoi(sport.c_str());

			bool bIsSerial = false;

			if (IsSerialDevice(htype))
			{
				bIsSerial = true;
				if (bEnabled)
				{
					if (sport.empty())
						return; //need to have a serial port
				}
			}
			else if (
				(htype == HTYPE_RFXLAN) || (htype == HTYPE_P1SmartMeterLAN) ||
				(htype == HTYPE_YouLess) || (htype == HTYPE_OpenThermGatewayTCP) || (htype == HTYPE_LimitlessLights) ||
				(htype == HTYPE_SolarEdgeTCP) || (htype == HTYPE_WOL) || (htype == HTYPE_S0SmartMeterTCP) || (htype == HTYPE_ECODEVICES) || (htype == HTYPE_Mochad) ||
				(htype == HTYPE_MySensorsTCP) || (htype == HTYPE_MySensorsMQTT) || (htype == HTYPE_MQTT) || (htype == HTYPE_TTN_MQTT) || (htype == HTYPE_FRITZBOX) || (htype == HTYPE_ETH8020) || (htype == HTYPE_Sterbox) ||
				(htype == HTYPE_KMTronicTCP) || (htype == HTYPE_KMTronicUDP) || (htype == HTYPE_SOLARMAXTCP) || (htype == HTYPE_RelayNet) || (htype == HTYPE_SatelIntegra) || (htype == HTYPE_eHouseTCP) || (htype == HTYPE_RFLINKTCP) ||
				(htype == HTYPE_Comm5TCP || (htype == HTYPE_Comm5SMTCP) || (htype == HTYPE_CurrentCostMeterLAN)) ||
				(htype == HTYPE_NefitEastLAN) || (htype == HTYPE_DenkoviHTTPDevices) || (htype == HTYPE_DenkoviTCPDevices) || (htype == HTYPE_Ec3kMeterTCP) || (htype == HTYPE_MultiFun) || (htype == HTYPE_ZIBLUETCP) || (htype == HTYPE_OnkyoAVTCP)
				) {
				if (address.empty())
					return;
			}
			else if (htype == HTYPE_DomoticzInternal) {
				return;
			}
			else if (htype == HTYPE_Domoticz) {
				if (address.empty())
					return;
			}
			else if (htype == HTYPE_System) {
				std::vector<std::vector<std::string> > result;
				result = m_sql.safe_query(""SELECT ID FROM Hardware WHERE (Type==%d)"", HTYPE_System);
				if (!result.empty())
				{
					int hID = atoi(result[0][0].c_str());
					int aID = atoi(idx.c_str());
					if (hID != aID)
						return;
				}
			}
			else if (htype == HTYPE_TE923) {
			}
			else if (htype == HTYPE_VOLCRAFTCO20) {
			}
			else if (htype == HTYPE_1WIRE) {
			}
			else if (htype == HTYPE_Pinger) {
			}
			else if (htype == HTYPE_Kodi) {
			}
			else if (htype == HTYPE_PanasonicTV) {
			}
			else if (htype == HTYPE_LogitechMediaServer) {
			}
			else if (htype == HTYPE_RaspberryBMP085) {
			}
			else if (htype == HTYPE_RaspberryHTU21D) {
			}
			else if (htype == HTYPE_RaspberryTSL2561) {
			}
			else if (htype == HTYPE_RaspberryBME280) {
			}
			else if (htype == HTYPE_RaspberryMCP23017) {
			}
			else if (htype == HTYPE_Dummy) {
			}
			else if (htype == HTYPE_EVOHOME_SCRIPT || htype == HTYPE_EVOHOME_SERIAL || htype == HTYPE_EVOHOME_WEB || htype == HTYPE_EVOHOME_TCP) {
			}
			else if (htype == HTYPE_PiFace) {
			}
			else if (htype == HTYPE_HTTPPOLLER) {
			}
			else if (htype == HTYPE_BleBox) {
			}
			else if (htype == HTYPE_HEOS) {
			}
			else if (htype == HTYPE_Yeelight) {
			}
			else if (htype == HTYPE_XiaomiGateway) {
			}
			else if (htype == HTYPE_Arilux) {
			}
			else if (htype == HTYPE_USBtinGateway) {
			}
			else if (
				(htype == HTYPE_Wunderground) ||
				(htype == HTYPE_DarkSky) ||
				(htype == HTYPE_AccuWeather) ||
				(htype == HTYPE_OpenWeatherMap) ||
				(htype == HTYPE_ICYTHERMOSTAT) ||
				(htype == HTYPE_TOONTHERMOSTAT) ||
				(htype == HTYPE_AtagOne) ||
				(htype == HTYPE_PVOUTPUT_INPUT) ||
				(htype == HTYPE_NEST) ||
				(htype == HTYPE_ANNATHERMOSTAT) ||
				(htype == HTYPE_THERMOSMART) ||
				(htype == HTYPE_Tado) ||
				(htype == HTYPE_Netatmo)
				)
			{
				if (
					(username.empty()) ||
					(password.empty())
					)
					return;
			}
			else if (htype == HTYPE_SolarEdgeAPI)
			{
				if (
					(username.empty())
					)
					return;
			}
			else if (htype == HTYPE_Nest_OAuthAPI) {
				if (
					(username == """") &&
					(extra == ""||"")
					)
					return;
			}
			else if (htype == HTYPE_HARMONY_HUB) {
				if (
					(address.empty())
					)
					return;
			}
			else if (htype == HTYPE_Philips_Hue) {
				if (
					(username.empty()) ||
					(address.empty())
					)
					return;
				if (port == 0)
					port = 80;
			}
			else if (htype == HTYPE_RaspberryGPIO) {
			}
			else if (htype == HTYPE_SysfsGpio) {
			}
			else if (htype == HTYPE_Rtl433) {
			}
			else if (htype == HTYPE_Daikin) {
			}
			else if (htype == HTYPE_SBFSpot) {
				if (username.empty())
					return;
			}
			else if (htype == HTYPE_WINDDELEN) {
				std::string mill_id = request::findValue(&req, ""Mode1"");
				if (
					(mill_id.empty()) ||
					(sport.empty())
					)
					return;
			}
			else if (htype == HTYPE_Honeywell) {
			}
			else if (htype == HTYPE_OpenWebNetTCP) {
			}
			else if (htype == HTYPE_PythonPlugin) {
			}
			else if (htype == HTYPE_GoodweAPI) {
				if (username.empty()) {
					return;
				}
			}
			else if (htype == HTYPE_RaspberryPCF8574) {
			}
			else if (htype == HTYPE_OpenWebNetUSB) {
			}
			else if (htype == HTYPE_IntergasInComfortLAN2RF) {
			}
			else if (htype == HTYPE_EnphaseAPI) {
			}
			else
				return;

			std::string mode1Str;
			std::string mode2Str;
			std::string mode3Str;
			std::string mode4Str;
			std::string mode5Str;
			std::string mode6Str;

			root[""status""] = ""OK"";
			root[""title""] = ""UpdateHardware"";

			if (htype == HTYPE_Domoticz)
			{
				if (password.size() != 32)
				{
					password = GenerateMD5Hash(password);
				}
			}

			if ((bIsSerial) && (!bEnabled) && (sport.empty()))
			{
				m_sql.safe_query(
					""UPDATE Hardware SET Enabled=%d WHERE (ID == '%q')"",
					(bEnabled == true) ? 1 : 0,
					idx.c_str()
				);
			}
			else
			{
				if (htype == HTYPE_HTTPPOLLER) {
					m_sql.safe_query(
						""UPDATE Hardware SET Name='%q', Enabled=%d, Type=%d, Address='%q', Port=%d, SerialPort='%q', Username='%q', Password='%q', Extra='%q', DataTimeout=%d WHERE (ID == '%q')"",
						name.c_str(),
						(senabled == ""true"") ? 1 : 0,
						htype,
						address.c_str(),
						port,
						sport.c_str(),
						username.c_str(),
						password.c_str(),
						extra.c_str(),
						iDataTimeout,
						idx.c_str()
					);
				}
				else if (htype == HTYPE_PythonPlugin) {
					mode1Str = request::findValue(&req, ""Mode1"");
					mode2Str = request::findValue(&req, ""Mode2"");
					mode3Str = request::findValue(&req, ""Mode3"");
					mode4Str = request::findValue(&req, ""Mode4"");
					mode5Str = request::findValue(&req, ""Mode5"");
					mode6Str = request::findValue(&req, ""Mode6"");
					sport = request::findValue(&req, ""serialport"");
					m_sql.safe_query(
						""UPDATE Hardware SET Name='%q', Enabled=%d, Type=%d, Address='%q', Port=%d, SerialPort='%q', Username='%q', Password='%q', Extra='%q', Mode1='%q', Mode2='%q', Mode3='%q', Mode4='%q', Mode5='%q', Mode6='%q', DataTimeout=%d WHERE (ID == '%q')"",
						name.c_str(),
						(senabled == ""true"") ? 1 : 0,
						htype,
						address.c_str(),
						port,
						sport.c_str(),
						username.c_str(),
						password.c_str(),
						extra.c_str(),
						mode1Str.c_str(), mode2Str.c_str(), mode3Str.c_str(), mode4Str.c_str(), mode5Str.c_str(), mode6Str.c_str(),
						iDataTimeout,
						idx.c_str()
					);
				}
				else if (
					(htype == HTYPE_RFXtrx433) ||
					(htype == HTYPE_RFXtrx868)
					)
				{
					m_sql.safe_query(
						""UPDATE Hardware SET Name='%q', Enabled=%d, Type=%d, Address='%q', Port=%d, SerialPort='%q', Username='%q', Password='%q', Mode1=%d, Mode2=%d, Mode3=%d, Mode4=%d, Mode5=%d, Mode6=%d, DataTimeout=%d WHERE (ID == '%q')"",
						name.c_str(),
						(bEnabled == true) ? 1 : 0,
						htype,
						address.c_str(),
						port,
						sport.c_str(),
						username.c_str(),
						password.c_str(),
						mode1, mode2, mode3, mode4, mode5, mode6,
						iDataTimeout,
						idx.c_str()
					);
					std::vector<std::vector<std::string> > result;
					result = m_sql.safe_query(""SELECT Extra FROM Hardware WHERE ID=%q"", idx.c_str());
					if (!result.empty())
						extra = result[0][0];
				}
				else {
					m_sql.safe_query(
						""UPDATE Hardware SET Name='%q', Enabled=%d, Type=%d, Address='%q', Port=%d, SerialPort='%q', Username='%q', Password='%q', Extra='%q', Mode1=%d, Mode2=%d, Mode3=%d, Mode4=%d, Mode5=%d, Mode6=%d, DataTimeout=%d WHERE (ID == '%q')"",
						name.c_str(),
						(bEnabled == true) ? 1 : 0,
						htype,
						address.c_str(),
						port,
						sport.c_str(),
						username.c_str(),
						password.c_str(),
						extra.c_str(),
						mode1, mode2, mode3, mode4, mode5, mode6,
						iDataTimeout,
						idx.c_str()
					);
				}
			}

			int ID = atoi(idx.c_str());
			m_mainworker.AddHardwareFromParams(ID, name, bEnabled, htype, address, port, sport, username, password, extra, mode1, mode2, mode3, mode4, mode5, mode6, iDataTimeout, true);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,27086096177142735983139080879427177451,,
"		void CWebServer::Cmd_UpdateMobileDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string sidx = request::findValue(&req, ""idx"");
			std::string enabled = request::findValue(&req, ""enabled"");
			std::string name = request::findValue(&req, ""name"");

			if (
				(sidx.empty()) ||
				(enabled.empty()) ||
				(name.empty())
				)
				return;
			uint64_t idx = std::strtoull(sidx.c_str(), nullptr, 10);

			m_sql.safe_query(""UPDATE MobileDevices SET Name='%q', Active=%d WHERE (ID==%"" PRIu64 "")"",
				name.c_str(), (enabled == ""true"") ? 1 : 0, idx);

			root[""status""] = ""OK"";
			root[""title""] = ""UpdateMobile"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,108091401031976287469991064493744531510,,
"		void CWebServer::Cmd_UpdatePlan(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			std::string name = request::findValue(&req, ""name"");
			if (
				(name.empty())
				)
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""UpdatePlan"";

			m_sql.safe_query(
				""UPDATE Plans SET Name='%q' WHERE (ID == '%q')"",
				name.c_str(),
				idx.c_str()
			);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,135220036154060111577589757434843973726,,
"		void CWebServer::DisplayLanguageCombo(std::string & content_part)
		{
			std::map<std::string, std::string> _ltypes;
			char szTmp[200];
			int ii = 0;
			while (guiLanguage[ii].szShort != NULL)
			{
				_ltypes[guiLanguage[ii].szLong] = guiLanguage[ii].szShort;
				ii++;
			}
			for (const auto & itt : _ltypes)
			{
				sprintf(szTmp, ""<option value=\""%s\"">%s</option>\n"", itt.second.c_str(), itt.first.c_str());
				content_part += szTmp;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,10828884860743858799254402631849388978,,
"		void CWebServer::DisplayMeterTypesCombo(std::string & content_part)
		{
			char szTmp[200];
			for (int ii = 0; ii < MTYPE_END; ii++)
			{
				sprintf(szTmp, ""<option value=\""%d\"">%s</option>\n"", ii, Meter_Type_Desc((_eMeterType)ii));
				content_part += szTmp;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,37400778513091301898340759616965761059,,
"		void CWebServer::DisplaySwitchTypesCombo(std::string & content_part)
		{
			char szTmp[200];

			std::map<std::string, int> _switchtypes;

			for (int ii = 0; ii < STYPE_END; ii++)
			{
				_switchtypes[Switch_Type_Desc((_eSwitchType)ii)] = ii;
			}
			for (const auto & itt : _switchtypes)
			{
				sprintf(szTmp, ""<option value=\""%d\"">%s</option>\n"", itt.second, itt.first.c_str());
				content_part += szTmp;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,298833712953552834217817841879764828496,,
"		void CWebServer::Do_Work()
		{
			bool exception_thrown = false;
			while (!m_bDoStop)
			{
				exception_thrown = false;
				try {
					if (m_pWebEm) {
						m_pWebEm->Run();
					}
				}
				catch (std::exception& e) {
					_log.Log(LOG_ERROR, ""WebServer(%s) exception occurred : '%s'"", m_server_alias.c_str(), e.what());
					exception_thrown = true;
				}
				catch (...) {
					_log.Log(LOG_ERROR, ""WebServer(%s) unknown exception occurred"", m_server_alias.c_str());
					exception_thrown = true;
				}
				if (exception_thrown) {
					_log.Log(LOG_STATUS, ""WebServer(%s) restart server in 5 seconds"", m_server_alias.c_str());
					sleep_milliseconds(5000); // prevents from an exception flood
					continue;
				}
				break;
			}
			_log.Log(LOG_STATUS, ""WebServer(%s) stopped"", m_server_alias.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,248723446087578005773212065956497209875,,
"		int CWebServer::FindUser(const char* szUserName)
		{
			int iUser = 0;
			for (const auto & itt : m_users)
			{
				if (itt.Username == szUserName)
					return iUser;
				iUser++;
			}
			return -1;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,31989177838971521386834549649609273626,,
"		void CWebServer::GetAppCache(WebEmSession & session, const request& req, reply & rep)
		{
			std::string response = """";
			if (g_bDontCacheWWW)
			{
				return;
			}
			std::string sLine;
			std::string filename = szWWWFolder + ""/html5.appcache"";


			std::string sWebTheme = ""default"";
			m_sql.GetPreferencesVar(""WebTheme"", sWebTheme);

			std::map<std::string, int> _ThemeFiles;
			GetDirFilesRecursive(szWWWFolder + ""/styles/"" + sWebTheme + ""/"", _ThemeFiles);

			std::map<std::string, int> _FloorplanFiles;
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID FROM Floorplans ORDER BY [Order]"");
			if (!result.empty())
			{
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;
					std::string ImageURL = ""images/floorplans/plan?idx="" + sd[0];
					_FloorplanFiles[ImageURL] = 1;
				}
			}

			std::ifstream is(filename.c_str());
			if (is)
			{
				while (!is.eof())
				{
					getline(is, sLine);
					if (!sLine.empty())
					{
						if (sLine.find(""#BuildHash"") != std::string::npos)
						{
							stdreplace(sLine, ""#BuildHash"", szAppHash);
						}
						else if (sLine.find(""#ThemeFiles"") != std::string::npos)
						{
							response += ""#Theme="" + sWebTheme + '\n';
							for (const auto & itt : _ThemeFiles)
							{
								std::string tfname = itt.first.substr(szWWWFolder.size() + 1);
								stdreplace(tfname, ""styles/"" + sWebTheme, ""acttheme"");
								response += tfname + '\n';
							}
							continue;
						}
						else if (sLine.find(""#Floorplans"") != std::string::npos)
						{
							for (const auto & itt : _FloorplanFiles)
							{
								std::string tfname = itt.first;
								response += tfname + '\n';
							}
							continue;
						}
						else if (sLine.find(""#SwitchIcons"") != std::string::npos)
						{
							for (const auto & itt : m_custom_light_icons)
							{
								if (itt.idx >= 100)
								{
									std::string IconFile16 = itt.RootFile + "".png"";
									std::string IconFile48On = itt.RootFile + ""48_On.png"";
									std::string IconFile48Off = itt.RootFile + ""48_Off.png"";

									response += ""images/"" + CURLEncode::URLEncode(IconFile16) + '\n';
									response += ""images/"" + CURLEncode::URLEncode(IconFile48On) + '\n';
									response += ""images/"" + CURLEncode::URLEncode(IconFile48Off) + '\n';
								}
							}
						}
					}
					response += sLine + '\n';
				}
			}
			reply::set_content(&rep, response);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,284964221904417699282347765938703891018,,
"		void CWebServer::GetJSonPage(WebEmSession & session, const request& req, reply & rep)
		{
			Json::Value root;
			root[""status""] = ""ERR"";

			std::string rtype = request::findValue(&req, ""type"");
			if (rtype == ""command"")
			{
				std::string cparam = request::findValue(&req, ""param"");
				if (cparam.empty())
				{
					cparam = request::findValue(&req, ""dparam"");
					if (cparam.empty())
					{
						goto exitjson;
					}
				}
				if (cparam == ""dologout"")
				{
					session.forcelogin = true;
					root[""status""] = ""OK"";
					root[""title""] = ""Logout"";
					goto exitjson;

				}
				_log.Debug(DEBUG_WEBSERVER, ""WEBS GetJSon :%s :%s "", cparam.c_str(), req.uri.c_str());
				HandleCommand(cparam, session, req, root);
			} //(rtype==""command"")
			else {
				HandleRType(rtype, session, req, root);
			}
		exitjson:
			std::string jcallback = request::findValue(&req, ""jsoncallback"");
			if (jcallback.size() == 0) {
				reply::set_content(&rep, root.toStyledString());
				return;
			}
			reply::set_content(&rep, ""var data="" + root.toStyledString() + '\n' + jcallback + ""(data);"");
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,78189267690982656174131591003284422584,,
"		void CWebServer::HandleCommand(const std::string &cparam, WebEmSession & session, const request& req, Json::Value &root)
		{
			std::map < std::string, webserver_response_function >::iterator pf = m_webcommands.find(cparam);
			if (pf != m_webcommands.end())
			{
				pf->second(session, req, root);
				return;
			}

			std::vector<std::vector<std::string> > result;
			char szTmp[300];

			bool bHaveUser = (session.username != """");
			int iUser = -1;
			if (bHaveUser)
			{
				iUser = FindUser(session.username.c_str());
			}

			if (cparam == ""deleteallsubdevices"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteAllSubDevices"";
				result = m_sql.safe_query(""DELETE FROM LightSubDevices WHERE (ParentID == '%q')"", idx.c_str());
			}
			else if (cparam == ""deletesubdevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteSubDevice"";
				result = m_sql.safe_query(""DELETE FROM LightSubDevices WHERE (ID == '%q')"", idx.c_str());
			}
			else if (cparam == ""addsubdevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string subidx = request::findValue(&req, ""subidx"");
				if ((idx.empty()) || (subidx.empty()))
					return;
				if (idx == subidx)
					return;

				result = m_sql.safe_query(""SELECT ID FROM LightSubDevices WHERE (DeviceRowID=='%q') AND (ParentID =='%q')"",
					subidx.c_str(), idx.c_str());
				if (result.empty())
				{
					root[""status""] = ""OK"";
					root[""title""] = ""AddSubDevice"";
					result = m_sql.safe_query(
						""INSERT INTO LightSubDevices (DeviceRowID, ParentID) VALUES ('%q','%q')"",
						subidx.c_str(),
						idx.c_str()
					);
				}
			}
			else if (cparam == ""addscenedevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string devidx = request::findValue(&req, ""devidx"");
				std::string isscene = request::findValue(&req, ""isscene"");
				std::string scommand = request::findValue(&req, ""command"");
				int ondelay = atoi(request::findValue(&req, ""ondelay"").c_str());
				int offdelay = atoi(request::findValue(&req, ""offdelay"").c_str());

				if (
					(idx.empty()) ||
					(devidx.empty()) ||
					(isscene.empty())
					)
					return;
				int level = -1;
				if (request::hasValue(&req, ""level""))
					level = atoi(request::findValue(&req, ""level"").c_str());
				std::string color = _tColor(request::findValue(&req, ""color"")).toJSONString(); //Parse the color to detect incorrectly formatted color data

				unsigned char command = 0;
				result = m_sql.safe_query(""SELECT HardwareID, DeviceID, Unit, Type, SubType, SwitchType, Options FROM DeviceStatus WHERE (ID=='%q')"",
					devidx.c_str());
				if (!result.empty())
				{
					int dType = atoi(result[0][3].c_str());
					int sType = atoi(result[0][4].c_str());
					_eSwitchType switchtype = (_eSwitchType)atoi(result[0][5].c_str());
					std::map<std::string, std::string> options = m_sql.BuildDeviceOptions(result[0][6].c_str());
					GetLightCommand(dType, sType, switchtype, scommand, command, options);
				}

				result = m_sql.safe_query(""SELECT Activators, SceneType FROM Scenes WHERE (ID=='%q')"", idx.c_str());
				if (!result.empty())
				{
					int SceneType = atoi(result[0][1].c_str());

					std::vector<std::string> arrayActivators;
					StringSplit(result[0][0], "";"", arrayActivators);
					for (const auto & ittAct : arrayActivators)
					{
						std::string sCodeCmd = ittAct;

						std::vector<std::string> arrayCode;
						StringSplit(sCodeCmd, "":"", arrayCode);

						std::string sID = arrayCode[0];
						std::string sCode = """";
						if (arrayCode.size() == 2)
						{
							sCode = arrayCode[1];
						}

						if (sID == devidx)
						{
							return; //Group does not work with separate codes, so already there
						}
					}
				}
				if (isscene == ""true"") {
					result = m_sql.safe_query(""SELECT ID FROM SceneDevices WHERE (DeviceRowID=='%q') AND (SceneRowID =='%q') AND (OnDelay == %d) AND (OffDelay == %d) AND (Cmd == %d)"",
						devidx.c_str(), idx.c_str(), ondelay, offdelay, command);
				}
				else {
					result = m_sql.safe_query(""SELECT ID FROM SceneDevices WHERE (DeviceRowID=='%q') AND (SceneRowID =='%q') AND (OnDelay == %d)"",
						devidx.c_str(), idx.c_str(), ondelay);
				}
				if (result.empty())
				{
					root[""status""] = ""OK"";
					root[""title""] = ""AddSceneDevice"";
					if (isscene == ""true"")
					{
						m_sql.safe_query(
							""INSERT INTO SceneDevices (DeviceRowID, SceneRowID, Cmd, Level, Color, OnDelay, OffDelay) VALUES ('%q','%q',%d,%d,'%q',%d,%d)"",
							devidx.c_str(),
							idx.c_str(),
							command,
							level,
							color.c_str(),
							ondelay,
							offdelay
						);
					}
					else
					{
						m_sql.safe_query(
							""INSERT INTO SceneDevices (DeviceRowID, SceneRowID, Level, Color, OnDelay, OffDelay) VALUES ('%q','%q',%d,'%q',%d,%d)"",
							devidx.c_str(),
							idx.c_str(),
							level,
							color.c_str(),
							ondelay,
							offdelay
						);
					}
					if (m_sql.m_bEnableEventSystem)
						m_mainworker.m_eventsystem.GetCurrentScenesGroups();
				}
			}
			else if (cparam == ""updatescenedevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string devidx = request::findValue(&req, ""devidx"");
				std::string scommand = request::findValue(&req, ""command"");
				int ondelay = atoi(request::findValue(&req, ""ondelay"").c_str());
				int offdelay = atoi(request::findValue(&req, ""offdelay"").c_str());

				if (
					(idx.empty()) ||
					(devidx.empty())
					)
					return;

				unsigned char command = 0;

				result = m_sql.safe_query(""SELECT HardwareID, DeviceID, Unit, Type, SubType, SwitchType, Options FROM DeviceStatus WHERE (ID=='%q')"",
					devidx.c_str());
				if (!result.empty())
				{
					int dType = atoi(result[0][3].c_str());
					int sType = atoi(result[0][4].c_str());
					_eSwitchType switchtype = (_eSwitchType)atoi(result[0][5].c_str());
					std::map<std::string, std::string> options = m_sql.BuildDeviceOptions(result[0][6].c_str());
					GetLightCommand(dType, sType, switchtype, scommand, command, options);
				}
				int level = -1;
				if (request::hasValue(&req, ""level""))
					level = atoi(request::findValue(&req, ""level"").c_str());
				std::string color = _tColor(request::findValue(&req, ""color"")).toJSONString(); //Parse the color to detect incorrectly formatted color data
				root[""status""] = ""OK"";
				root[""title""] = ""UpdateSceneDevice"";
				result = m_sql.safe_query(
					""UPDATE SceneDevices SET Cmd=%d, Level=%d, Color='%q', OnDelay=%d, OffDelay=%d  WHERE (ID == '%q')"",
					command, level, color.c_str(), ondelay, offdelay, idx.c_str());
			}
			else if (cparam == ""deletescenedevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteSceneDevice"";
				m_sql.safe_query(""DELETE FROM SceneDevices WHERE (ID == '%q')"", idx.c_str());
				m_sql.safe_query(""DELETE FROM CamerasActiveDevices WHERE (DevSceneType==1) AND (DevSceneRowID == '%q')"", idx.c_str());
				if (m_sql.m_bEnableEventSystem)
					m_mainworker.m_eventsystem.GetCurrentScenesGroups();
			}
			else if (cparam == ""getsubdevices"")
			{
				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""GetSubDevices"";
				result = m_sql.safe_query(""SELECT a.ID, b.Name FROM LightSubDevices a, DeviceStatus b WHERE (a.ParentID=='%q') AND (b.ID == a.DeviceRowID)"",
					idx.c_str());
				if (!result.empty())
				{
					int ii = 0;
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						root[""result""][ii][""ID""] = sd[0];
						root[""result""][ii][""Name""] = sd[1];
						ii++;
					}
				}
			}
			else if (cparam == ""getscenedevices"")
			{
				std::string idx = request::findValue(&req, ""idx"");
				std::string isscene = request::findValue(&req, ""isscene"");

				if (
					(idx.empty()) ||
					(isscene.empty())
					)
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""GetSceneDevices"";

				result = m_sql.safe_query(""SELECT a.ID, b.Name, a.DeviceRowID, b.Type, b.SubType, b.nValue, b.sValue, a.Cmd, a.Level, b.ID, a.[Order], a.Color, a.OnDelay, a.OffDelay, b.SwitchType FROM SceneDevices a, DeviceStatus b WHERE (a.SceneRowID=='%q') AND (b.ID == a.DeviceRowID) ORDER BY a.[Order]"",
					idx.c_str());
				if (!result.empty())
				{
					int ii = 0;
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						root[""result""][ii][""ID""] = sd[0];
						root[""result""][ii][""Name""] = sd[1];
						root[""result""][ii][""DevID""] = sd[2];
						root[""result""][ii][""DevRealIdx""] = sd[9];
						root[""result""][ii][""Order""] = atoi(sd[10].c_str());
						root[""result""][ii][""OnDelay""] = atoi(sd[12].c_str());
						root[""result""][ii][""OffDelay""] = atoi(sd[13].c_str());

						_eSwitchType switchtype = (_eSwitchType)atoi(sd[14].c_str());

						unsigned char devType = atoi(sd[3].c_str());

						if (devType != pTypeRFY)
							switchtype = STYPE_OnOff;

						unsigned char subType = atoi(sd[4].c_str());
						unsigned char nValue = (unsigned char)atoi(sd[5].c_str());
						std::string sValue = sd[6];
						int command = atoi(sd[7].c_str());
						int level = atoi(sd[8].c_str());

						std::string lstatus = """";
						int llevel = 0;
						bool bHaveDimmer = false;
						bool bHaveGroupCmd = false;
						int maxDimLevel = 0;
						GetLightStatus(devType, subType, switchtype, command, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);
						root[""result""][ii][""Command""] = lstatus;
						root[""result""][ii][""Level""] = level;
						root[""result""][ii][""Color""] = _tColor(sd[11]).toJSONString();
						root[""result""][ii][""Type""] = RFX_Type_Desc(devType, 1);
						root[""result""][ii][""SubType""] = RFX_Type_SubType_Desc(devType, subType);
						ii++;
					}
				}
			}
			else if (cparam == ""changescenedeviceorder"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				std::string sway = request::findValue(&req, ""way"");
				if (sway.empty())
					return;
				bool bGoUp = (sway == ""0"");

				std::string aScene, aOrder, oID, oOrder;

				result = m_sql.safe_query(""SELECT SceneRowID, [Order] FROM SceneDevices WHERE (ID=='%q')"",
					idx.c_str());
				if (result.empty())
					return;
				aScene = result[0][0];
				aOrder = result[0][1];

				if (!bGoUp)
				{
					result = m_sql.safe_query(""SELECT ID, [Order] FROM SceneDevices WHERE (SceneRowID=='%q' AND [Order]>'%q') ORDER BY [Order] ASC"",
						aScene.c_str(), aOrder.c_str());
					if (result.empty())
						return;
					oID = result[0][0];
					oOrder = result[0][1];
				}
				else
				{
					result = m_sql.safe_query(""SELECT ID, [Order] FROM SceneDevices WHERE (SceneRowID=='%q' AND [Order]<'%q') ORDER BY [Order] DESC"",
						aScene.c_str(), aOrder.c_str());
					if (result.empty())
						return;
					oID = result[0][0];
					oOrder = result[0][1];
				}
				root[""status""] = ""OK"";
				root[""title""] = ""ChangeSceneDeviceOrder"";

				result = m_sql.safe_query(""UPDATE SceneDevices SET [Order] = '%q' WHERE (ID='%q')"",
					oOrder.c_str(), idx.c_str());
				result = m_sql.safe_query(""UPDATE SceneDevices SET [Order] = '%q' WHERE (ID='%q')"",
					aOrder.c_str(), oID.c_str());
			}
			else if (cparam == ""deleteallscenedevices"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteAllSceneDevices"";
				result = m_sql.safe_query(""DELETE FROM SceneDevices WHERE (SceneRowID == %q)"", idx.c_str());
			}
			else if (cparam == ""getmanualhardware"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""GetHardware"";
				result = m_sql.safe_query(""SELECT ID, Name, Type FROM Hardware ORDER BY ID ASC"");
				if (!result.empty())
				{
					int ii = 0;
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						int ID = atoi(sd[0].c_str());
						std::string Name = sd[1];
						_eHardwareTypes Type = (_eHardwareTypes)atoi(sd[2].c_str());

						if (
							(Type == HTYPE_RFXLAN) ||
							(Type == HTYPE_RFXtrx315) ||
							(Type == HTYPE_RFXtrx433) ||
							(Type == HTYPE_RFXtrx868) ||
							(Type == HTYPE_EnOceanESP2) ||
							(Type == HTYPE_EnOceanESP3) ||
							(Type == HTYPE_Dummy) ||
							(Type == HTYPE_Tellstick) ||
							(Type == HTYPE_EVOHOME_SCRIPT) ||
							(Type == HTYPE_EVOHOME_SERIAL) ||
							(Type == HTYPE_EVOHOME_WEB) ||
							(Type == HTYPE_EVOHOME_TCP) ||
							(Type == HTYPE_RaspberryGPIO) ||
							(Type == HTYPE_RFLINKUSB) ||
							(Type == HTYPE_RFLINKTCP) ||
							(Type == HTYPE_ZIBLUEUSB) ||
							(Type == HTYPE_ZIBLUETCP) ||
							(Type == HTYPE_OpenWebNetTCP) ||
							(Type == HTYPE_OpenWebNetUSB) ||
							(Type == HTYPE_SysfsGpio) ||
							(Type == HTYPE_USBtinGateway)
							)
						{
							root[""result""][ii][""idx""] = ID;
							root[""result""][ii][""Name""] = Name;
							ii++;
						}
					}
				}
			}
			else if (cparam == ""getgpio"")
			{
				root[""title""] = ""GetGpio"";
#ifdef WITH_GPIO
				std::vector<CGpioPin> pins = CGpio::GetPinList();
				if (pins.size() == 0) {
					root[""status""] = ""ERROR"";
					root[""result""][0][""idx""] = 0;
					root[""result""][0][""Name""] = ""GPIO INIT ERROR"";
				}
				else {
					int ii = 0;
					for (const auto & it : pins)
					{
						CGpioPin pin = it;
						root[""status""] = ""OK"";
						root[""result""][ii][""idx""] = pin.GetPin();
						root[""result""][ii][""Name""] = pin.ToString();
						ii++;
					}
				}
#else
				root[""status""] = ""OK"";
				root[""result""][0][""idx""] = 0;
				root[""result""][0][""Name""] = ""N/A"";
#endif
			}
			else if (cparam == ""getsysfsgpio"")
			{
				root[""title""] = ""GetSysfsGpio"";
#ifdef WITH_GPIO
				std::vector<int> gpio_ids = CSysfsGpio::GetGpioIds();
				std::vector<std::string> gpio_names = CSysfsGpio::GetGpioNames();

				if (gpio_ids.size() == 0) {
					root[""status""] = ""ERROR"";
					root[""result""][0][""idx""] = 0;
					root[""result""][0][""Name""] = ""No sysfs-gpio exports"";
				}
				else {
					for (int ii = 0; ii < gpio_ids.size(); ii++)
					{
						root[""status""] = ""OK"";
						root[""result""][ii][""idx""] = gpio_ids[ii];
						root[""result""][ii][""Name""] = gpio_names[ii];
			}
				}
#else
				root[""status""] = ""OK"";
				root[""result""][0][""idx""] = 0;
				root[""result""][0][""Name""] = ""N/A"";
#endif
			}
			else if (cparam == ""getlightswitches"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""GetLightSwitches"";
				result = m_sql.safe_query(""SELECT ID, Name, Type, SubType, Used, SwitchType, Options FROM DeviceStatus ORDER BY Name"");
				if (!result.empty())
				{
					int ii = 0;
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						std::string ID = sd[0];
						std::string Name = sd[1];
						int Type = atoi(sd[2].c_str());
						int SubType = atoi(sd[3].c_str());
						int used = atoi(sd[4].c_str());
						_eSwitchType switchtype = (_eSwitchType)atoi(sd[5].c_str());
						std::map<std::string, std::string> options = m_sql.BuildDeviceOptions(sd[6]);
						bool bdoAdd = false;
						switch (Type)
						{
						case pTypeLighting1:
						case pTypeLighting2:
						case pTypeLighting3:
						case pTypeLighting4:
						case pTypeLighting5:
						case pTypeLighting6:
						case pTypeFan:
						case pTypeColorSwitch:
						case pTypeSecurity1:
						case pTypeSecurity2:
						case pTypeEvohome:
						case pTypeEvohomeRelay:
						case pTypeCurtain:
						case pTypeBlinds:
						case pTypeRFY:
						case pTypeChime:
						case pTypeThermostat2:
						case pTypeThermostat3:
						case pTypeThermostat4:
						case pTypeRemote:
						case pTypeRadiator1:
						case pTypeGeneralSwitch:
						case pTypeHomeConfort:
						case pTypeFS20:
							bdoAdd = true;
							if (!used)
							{
								bdoAdd = false;
								bool bIsSubDevice = false;
								std::vector<std::vector<std::string> > resultSD;
								resultSD = m_sql.safe_query(""SELECT ID FROM LightSubDevices WHERE (DeviceRowID=='%q')"",
									sd[0].c_str());
								if (resultSD.size() > 0)
									bdoAdd = true;
							}
							if ((Type == pTypeRadiator1) && (SubType != sTypeSmartwaresSwitchRadiator))
								bdoAdd = false;
							if (bdoAdd)
							{
								int idx = atoi(ID.c_str());
								if (!IsIdxForUser(&session, idx))
									continue;
								root[""result""][ii][""idx""] = ID;
								root[""result""][ii][""Name""] = Name;
								root[""result""][ii][""Type""] = RFX_Type_Desc(Type, 1);
								root[""result""][ii][""SubType""] = RFX_Type_SubType_Desc(Type, SubType);
								bool bIsDimmer = (
									(switchtype == STYPE_Dimmer) ||
									(switchtype == STYPE_BlindsPercentage) ||
									(switchtype == STYPE_BlindsPercentageInverted) ||
									(switchtype == STYPE_Selector)
									);
								root[""result""][ii][""IsDimmer""] = bIsDimmer;

								std::string dimmerLevels = ""none"";

								if (bIsDimmer)
								{
									std::stringstream ss;

									if (switchtype == STYPE_Selector) {
										std::map<std::string, std::string> selectorStatuses;
										GetSelectorSwitchStatuses(options, selectorStatuses);
										bool levelOffHidden = (options[""LevelOffHidden""] == ""true"");
										for (int i = 0; i < (int)selectorStatuses.size(); i++) {
											if (levelOffHidden && (i == 0)) {
												continue;
											}
											if ((levelOffHidden && (i > 1)) || (i > 0)) {
												ss << "","";
											}
											ss << i * 10;
										}
									}
									else
									{
										int nValue = 0;
										std::string sValue = """";
										std::string lstatus = """";
										int llevel = 0;
										bool bHaveDimmer = false;
										int maxDimLevel = 0;
										bool bHaveGroupCmd = false;

										GetLightStatus(Type, SubType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);

										for (int i = 0; i <= maxDimLevel; i++)
										{
											if (i != 0)
											{
												ss << "","";
											}
											ss << (int)float((100.0f / float(maxDimLevel))*i);
										}
									}
									dimmerLevels = ss.str();
								}
								root[""result""][ii][""DimmerLevels""] = dimmerLevels;
								ii++;
							}
							break;
						}
					}
				}
			}
			else if (cparam == ""getlightswitchesscenes"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""GetLightSwitchesScenes"";
				int ii = 0;

				result = m_sql.safe_query(""SELECT ID, Name, Type, SubType, Used FROM DeviceStatus ORDER BY Name"");
				if (!result.empty())
				{
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						std::string ID = sd[0];
						std::string Name = sd[1];
						int Type = atoi(sd[2].c_str());
						int SubType = atoi(sd[3].c_str());
						int used = atoi(sd[4].c_str());
						if (used)
						{
							switch (Type)
							{
							case pTypeLighting1:
							case pTypeLighting2:
							case pTypeLighting3:
							case pTypeLighting4:
							case pTypeLighting5:
							case pTypeLighting6:
							case pTypeFan:
							case pTypeColorSwitch:
							case pTypeSecurity1:
							case pTypeSecurity2:
							case pTypeEvohome:
							case pTypeEvohomeRelay:
							case pTypeCurtain:
							case pTypeBlinds:
							case pTypeRFY:
							case pTypeChime:
							case pTypeThermostat2:
							case pTypeThermostat3:
							case pTypeThermostat4:
							case pTypeRemote:
							case pTypeGeneralSwitch:
							case pTypeHomeConfort:
							case pTypeFS20:
								root[""result""][ii][""type""] = 0;
								root[""result""][ii][""idx""] = ID;
								root[""result""][ii][""Name""] = ""[Light/Switch] "" + Name;
								ii++;
								break;
							case pTypeRadiator1:
								if (SubType == sTypeSmartwaresSwitchRadiator)
								{
									root[""result""][ii][""type""] = 0;
									root[""result""][ii][""idx""] = ID;
									root[""result""][ii][""Name""] = ""[Light/Switch] "" + Name;
									ii++;
								}
								break;
							}
						}
					}
				}//end light/switches

				result = m_sql.safe_query(""SELECT ID, Name FROM Scenes ORDER BY Name"");
				if (!result.empty())
				{
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						std::string ID = sd[0];
						std::string Name = sd[1];

						root[""result""][ii][""type""] = 1;
						root[""result""][ii][""idx""] = ID;
						root[""result""][ii][""Name""] = ""[Scene] "" + Name;
						ii++;
					}
				}//end light/switches
			}
			else if (cparam == ""getcamactivedevices"")
			{
				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""GetCameraActiveDevices"";
				result = m_sql.safe_query(""SELECT ID, DevSceneType, DevSceneRowID, DevSceneWhen, DevSceneDelay FROM CamerasActiveDevices WHERE (CameraRowID=='%q') ORDER BY ID"",
					idx.c_str());
				if (!result.empty())
				{
					int ii = 0;
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						std::string ID = sd[0];
						int DevSceneType = atoi(sd[1].c_str());
						std::string DevSceneRowID = sd[2];
						int DevSceneWhen = atoi(sd[3].c_str());
						int DevSceneDelay = atoi(sd[4].c_str());

						std::string Name = """";
						if (DevSceneType == 0)
						{
							std::vector<std::vector<std::string> > result2;
							result2 = m_sql.safe_query(""SELECT Name FROM DeviceStatus WHERE (ID=='%q')"",
								DevSceneRowID.c_str());
							if (!result2.empty())
							{
								Name = ""[Light/Switches] "" + result2[0][0];
							}
						}
						else
						{
							std::vector<std::vector<std::string> > result2;
							result2 = m_sql.safe_query(""SELECT Name FROM Scenes WHERE (ID=='%q')"",
								DevSceneRowID.c_str());
							if (!result2.empty())
							{
								Name = ""[Scene] "" + result2[0][0];
							}
						}
						if (Name != """")
						{
							root[""result""][ii][""idx""] = ID;
							root[""result""][ii][""type""] = DevSceneType;
							root[""result""][ii][""DevSceneRowID""] = DevSceneRowID;
							root[""result""][ii][""when""] = DevSceneWhen;
							root[""result""][ii][""delay""] = DevSceneDelay;
							root[""result""][ii][""Name""] = Name;
							ii++;
						}
					}
				}
			}
			else if (cparam == ""addcamactivedevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string activeidx = request::findValue(&req, ""activeidx"");
				std::string sactivetype = request::findValue(&req, ""activetype"");
				std::string sactivewhen = request::findValue(&req, ""activewhen"");
				std::string sactivedelay = request::findValue(&req, ""activedelay"");

				if (
					(idx.empty()) ||
					(activeidx.empty()) ||
					(sactivetype.empty()) ||
					(sactivewhen.empty()) ||
					(sactivedelay.empty())
					)
				{
					return;
				}

				int activetype = atoi(sactivetype.c_str());
				int activewhen = atoi(sactivewhen.c_str());
				int activedelay = atoi(sactivedelay.c_str());

				result = m_sql.safe_query(
					""SELECT ID FROM CamerasActiveDevices WHERE (CameraRowID=='%q')""
					"" AND (DevSceneType==%d) AND (DevSceneRowID=='%q')""
					"" AND (DevSceneWhen==%d)"",
					idx.c_str(), activetype, activeidx.c_str(), activewhen);
				if (result.empty())
				{
					root[""status""] = ""OK"";
					root[""title""] = ""AddCameraActiveDevice"";
					result = m_sql.safe_query(
						""INSERT INTO CamerasActiveDevices (CameraRowID, DevSceneType, DevSceneRowID, DevSceneWhen, DevSceneDelay) VALUES ('%q',%d,'%q',%d,%d)"",
						idx.c_str(),
						activetype,
						activeidx.c_str(),
						activewhen,
						activedelay
					);
					m_mainworker.m_cameras.ReloadCameras();
				}
			}
			else if (cparam == ""deleteamactivedevice"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteCameraActiveDevice"";
				result = m_sql.safe_query(""DELETE FROM CamerasActiveDevices WHERE (ID == '%q')"", idx.c_str());
				m_mainworker.m_cameras.ReloadCameras();
			}
			else if (cparam == ""deleteallactivecamdevices"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteAllCameraActiveDevices"";
				result = m_sql.safe_query(""DELETE FROM CamerasActiveDevices WHERE (CameraRowID == '%q')"", idx.c_str());
				m_mainworker.m_cameras.ReloadCameras();
			}
			else if (cparam == ""testnotification"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string notification_Title = ""Domoticz test"";
				std::string notification_Message = ""Domoticz test message!"";
				std::string subsystem = request::findValue(&req, ""subsystem"");

				std::string extraData = request::findValue(&req, ""extradata"");

				m_notifications.ConfigFromGetvars(req, false);
				if (m_notifications.SendMessage(0, std::string(""""), subsystem, notification_Title, notification_Message, extraData, 1, std::string(""""), false)) {
					root[""status""] = ""OK"";
				}
				/* we need to reload the config, because the values that were set were only for testing */
				m_notifications.LoadConfig();
			}
			else if (cparam == ""testswitch"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string hwdid = request::findValue(&req, ""hwdid"");
				std::string sswitchtype = request::findValue(&req, ""switchtype"");
				std::string slighttype = request::findValue(&req, ""lighttype"");

				if (
					(hwdid.empty()) ||
					(sswitchtype.empty()) ||
					(slighttype.empty())
					)
					return;
				_eSwitchType switchtype = (_eSwitchType)atoi(sswitchtype.c_str());
				int lighttype = atoi(slighttype.c_str());
				int dtype;
				int subtype = 0;
				std::string sunitcode;
				std::string devid;

				if (lighttype == 70)
				{
					dtype = pTypeLighting2;
					subtype = sTypeAC;
					std::string sgroupcode = request::findValue(&req, ""groupcode"");
					sunitcode = request::findValue(&req, ""unitcode"");
					int iUnitTest = atoi(sunitcode.c_str());	//only First Rocker_ID at the moment, gives us 128 devices we can control, should be enough!
					if (
						(sunitcode.empty()) ||
						(sgroupcode.empty()) ||
						((iUnitTest < 1) || (iUnitTest > 128))
						)
						return;
					sunitcode = sgroupcode;//Button A or B
					CDomoticzHardwareBase *pBaseHardware = reinterpret_cast<CDomoticzHardwareBase*>(m_mainworker.GetHardware(atoi(hwdid.c_str())));
					if (pBaseHardware == NULL)
						return;
					if ((pBaseHardware->HwdType != HTYPE_EnOceanESP2) && (pBaseHardware->HwdType != HTYPE_EnOceanESP3)
						&& (pBaseHardware->HwdType != HTYPE_USBtinGateway) )
						return;
					unsigned long rID = 0;
					if (pBaseHardware->HwdType == HTYPE_EnOceanESP2)
					{
						CEnOceanESP2 *pEnoceanHardware = reinterpret_cast<CEnOceanESP2 *>(pBaseHardware);
						rID = pEnoceanHardware->m_id_base + iUnitTest;
					}
					else if (pBaseHardware->HwdType == HTYPE_EnOceanESP3)
					{
						CEnOceanESP3 *pEnoceanHardware = reinterpret_cast<CEnOceanESP3 *>(pBaseHardware);
						rID = pEnoceanHardware->m_id_base + iUnitTest;
					}
					else if (pBaseHardware->HwdType == HTYPE_USBtinGateway) //Like EnOcean (Lighting2 with Base_ID offset)
					{
						USBtin *pUSBtinHardware = reinterpret_cast<USBtin *>(pBaseHardware);
						rID = pUSBtinHardware->switch_id_base;
						std::stringstream ssunitcode;
						ssunitcode << iUnitTest;
						sunitcode = ssunitcode.str();
					}
					std::stringstream s_strid;
					s_strid << std::hex << std::uppercase << rID;
					devid = s_strid.str();
				}
				else if (lighttype == 68)
				{
#ifdef WITH_GPIO
					dtype = pTypeLighting1;
					subtype = sTypeIMPULS;
					devid = ""0"";
					sunitcode = request::findValue(&req, ""unitcode""); //Unit code = GPIO number

					if (sunitcode.empty()) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""No GPIO number given"";
						return;
					}
					CGpio *pGpio = reinterpret_cast<CGpio *>(m_mainworker.GetHardware(atoi(hwdid.c_str())));
					if (pGpio == NULL) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""Could not retrieve GPIO hardware pointer"";
						return;
					}
					if (pGpio->HwdType != HTYPE_RaspberryGPIO) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""Given hardware is not GPIO"";
						return;
					}
					CGpioPin *pPin = CGpio::GetPPinById(atoi(sunitcode.c_str()));
					if (pPin == NULL) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""Given pin does not exist on this GPIO hardware"";
						return;
					}
					if (pPin->GetIsInput()) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""Given pin is not configured for output"";
						return;
			}
#else
					root[""status""] = ""ERROR"";
					root[""message""] = ""GPIO support is disabled"";
					return;
#endif
				}
				else if (lighttype == 69)
				{
#ifdef WITH_GPIO

					sunitcode = request::findValue(&req, ""unitcode""); // sysfs-gpio number
					int unitcode = atoi(sunitcode.c_str());
					dtype = pTypeLighting2;
					subtype = sTypeAC;
					std::string sswitchtype = request::findValue(&req, ""switchtype"");
					_eSwitchType switchtype = (_eSwitchType)atoi(sswitchtype.c_str());

					std::string id = request::findValue(&req, ""id"");
					if ((id.empty()) || (sunitcode.empty()))
					{
						return;
					}
					devid = id;

					if (sunitcode.empty())
					{
						root[""status""] = ""ERROR"";
						root[""message""] = ""No GPIO number given"";
						return;
					}

					CSysfsGpio *pSysfsGpio = reinterpret_cast<CSysfsGpio *>(m_mainworker.GetHardware(atoi(hwdid.c_str())));

					if (pSysfsGpio == NULL) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""Could not retrieve SysfsGpio hardware pointer"";
						return;
					}

					if (pSysfsGpio->HwdType != HTYPE_SysfsGpio) {
						root[""status""] = ""ERROR"";
						root[""message""] = ""Given hardware is not SysfsGpio"";
						return;
					}
#else
					root[""status""] = ""ERROR"";
					root[""message""] = ""GPIO support is disabled"";
					return;
#endif
				}
				else if (lighttype < 20)
				{
					dtype = pTypeLighting1;
					subtype = lighttype;
					std::string shousecode = request::findValue(&req, ""housecode"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(shousecode.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = shousecode;
				}
				else if (lighttype < 30)
				{
					dtype = pTypeLighting2;
					subtype = lighttype - 20;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = id;
				}
				else if (lighttype < 70)
				{
					dtype = pTypeLighting5;
					subtype = lighttype - 50;
					if (lighttype == 59)
						subtype = sTypeIT;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					if ((subtype != sTypeEMW100) && (subtype != sTypeLivolo) && (subtype != sTypeLivolo1to10) && (subtype != sTypeRGB432W) && (subtype != sTypeIT))
						devid = ""00"" + id;
					else
						devid = id;
				}
				else
				{
					if (lighttype == 100)
					{
						dtype = pTypeChime;
						subtype = sTypeByronSX;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						int iUnitCode = atoi(sunitcode.c_str()) - 1;
						switch (iUnitCode)
						{
						case 0:
							iUnitCode = chime_sound0;
							break;
						case 1:
							iUnitCode = chime_sound1;
							break;
						case 2:
							iUnitCode = chime_sound2;
							break;
						case 3:
							iUnitCode = chime_sound3;
							break;
						case 4:
							iUnitCode = chime_sound4;
							break;
						case 5:
							iUnitCode = chime_sound5;
							break;
						case 6:
							iUnitCode = chime_sound6;
							break;
						case 7:
							iUnitCode = chime_sound7;
							break;
						}
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						devid = id;
					}
					else if (lighttype == 101)
					{
						dtype = pTypeCurtain;
						subtype = sTypeHarrison;
						std::string shousecode = request::findValue(&req, ""housecode"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(shousecode.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = shousecode;
					}
					else if (lighttype == 102)
					{
						dtype = pTypeRFY;
						subtype = sTypeRFY;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = id;
					}
					else if (lighttype == 103)
					{
						dtype = pTypeSecurity1;
						subtype = sTypeMeiantech;
						std::string id = request::findValue(&req, ""id"");
						if (
							(id.empty())
							)
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 104)
					{
						dtype = pTypeThermostat2;
						subtype = sTypeHE105;
						sunitcode = request::findValue(&req, ""unitcode"");
						if (sunitcode.empty())
							return;
						std::stringstream s_strid;
						s_strid << std::hex << std::uppercase << sunitcode;
						int iUnitCode;
						s_strid >> iUnitCode;
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						devid = ""1"";
					}
					else if (lighttype == 105)
					{
						dtype = pTypeRFY;
						subtype = sTypeASA;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = id;
					}
					else if (lighttype == 106)
					{
						dtype = pTypeLighting6;
						subtype = sTypeBlyss;
						std::string sgroupcode = request::findValue(&req, ""groupcode"");
						sunitcode = request::findValue(&req, ""unitcode"");
						std::string id = request::findValue(&req, ""id"");
						if (
							(sgroupcode.empty()) ||
							(sunitcode.empty()) ||
							(id.empty())
							)
							return;
						devid = id + sgroupcode;
					}
					else if (lighttype == 107)
					{
						dtype = pTypeRFY;
						subtype = sTypeRFY2;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = id;
					}
					else if ((lighttype >= 200) && (lighttype < 300))
					{
						dtype = pTypeBlinds;
						subtype = lighttype - 200;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						int iUnitCode = atoi(sunitcode.c_str());
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						devid = id;
					}
					else if (lighttype == 301)
					{
						dtype = pTypeRadiator1;
						subtype = sTypeSmartwaresSwitchRadiator;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = id;
					}
					else if (lighttype == 302)
					{
						dtype = pTypeHomeConfort;
						subtype = sTypeHomeConfortTEL010;
						std::string id = request::findValue(&req, ""id"");

						std::string shousecode = request::findValue(&req, ""housecode"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(shousecode.empty()) ||
							(sunitcode.empty())
							)
							return;

						int iUnitCode = atoi(sunitcode.c_str());
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						sprintf(szTmp, ""%02X"", atoi(shousecode.c_str()));
						shousecode = szTmp;
						devid = id + shousecode;
					}
					else if (lighttype == 303)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchTypeSelector;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = id;
					}
					else if (lighttype == 304)
					{
						dtype = pTypeFan;
						subtype = sTypeItho;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 305)
					{
						dtype = pTypeFan;
						subtype = sTypeLucciAir;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 306)
					{
						dtype = pTypeFan;
						subtype = sTypeLucciAirDC;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 307)
					{
						dtype = pTypeFan;
						subtype = sTypeWestinghouse;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 400) {
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchBlindsT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 401) {
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchLightT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 402)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchAuxiliaryT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 403) {
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchBlindsT2;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 404) {
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchLightT2;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if ((lighttype == 405) || (lighttype == 406)) {
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchContactT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
				}
				CDomoticzHardwareBase *pBaseHardware = reinterpret_cast<CDomoticzHardwareBase*>(m_mainworker.GetHardware(atoi(hwdid.c_str())));
				if (pBaseHardware != NULL)
				{
					if ((pBaseHardware->HwdType == HTYPE_RFLINKUSB) || (pBaseHardware->HwdType == HTYPE_RFLINKTCP)) {
						ConvertToGeneralSwitchType(devid, dtype, subtype);
					}
				}

				root[""status""] = ""OK"";
				root[""message""] = ""OK"";
				root[""title""] = ""TestSwitch"";
				std::vector<std::string> sd;

				sd.push_back(hwdid);
				sd.push_back(devid);
				sd.push_back(sunitcode);
				sprintf(szTmp, ""%d"", dtype);
				sd.push_back(szTmp);
				sprintf(szTmp, ""%d"", subtype);
				sd.push_back(szTmp);
				sprintf(szTmp, ""%d"", switchtype);
				sd.push_back(szTmp);
				sd.push_back(""""); //AddjValue2
				sd.push_back(""""); //nValue
				sd.push_back(""""); //sValue
				sd.push_back(""""); //Name
				sd.push_back(""""); //Options

				std::string switchcmd = ""On"";
				int level = 0;
				if (lighttype == 70)
				{
					if (switchtype == STYPE_Dimmer)
						level = 5;
				}
				m_mainworker.SwitchLightInt(sd, switchcmd, level, NoColor, true);
			}
			else if (cparam == ""addswitch"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string hwdid = request::findValue(&req, ""hwdid"");
				std::string name = request::findValue(&req, ""name"");
				std::string sswitchtype = request::findValue(&req, ""switchtype"");
				std::string slighttype = request::findValue(&req, ""lighttype"");
				std::string maindeviceidx = request::findValue(&req, ""maindeviceidx"");
				std::string deviceoptions;

				if (
					(hwdid.empty()) ||
					(sswitchtype.empty()) ||
					(slighttype.empty()) ||
					(name.empty())
					)
					return;
				_eSwitchType switchtype = (_eSwitchType)atoi(sswitchtype.c_str());
				int lighttype = atoi(slighttype.c_str());
				int dtype = 0;
				int subtype = 0;
				std::string sunitcode;
				std::string devid;

#ifdef ENABLE_PYTHON
				{
					result = m_sql.safe_query(""SELECT Type FROM Hardware WHERE (ID == '%q')"", hwdid.c_str());
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];
						_eHardwareTypes Type = (_eHardwareTypes)atoi(sd[0].c_str());
						if (Type == HTYPE_PythonPlugin)
						{
							_log.Log(LOG_ERROR, ""CWebServer::HandleCommand addswitch: Not allowed to add device owned by plugin %u!"", atoi(hwdid.c_str()));
							root[""message""] = ""Not allowed to add switch to plugin HW!"";
							return;
						}
					}
				}
#endif

				if (lighttype == 70)
				{
					dtype = pTypeLighting2;
					subtype = sTypeAC;
					sunitcode = request::findValue(&req, ""unitcode"");
					std::string sgroupcode = request::findValue(&req, ""groupcode"");
					int iUnitTest = atoi(sunitcode.c_str());	//gives us 128 devices we can control, should be enough!
					if (
						(sunitcode.empty()) ||
						(sgroupcode.empty()) ||
						((iUnitTest < 1) || (iUnitTest > 128))
						)
						return;
					sunitcode = sgroupcode;//Button A/B
					CDomoticzHardwareBase *pBaseHardware = reinterpret_cast<CDomoticzHardwareBase*>(m_mainworker.GetHardware(atoi(hwdid.c_str())));
					if (pBaseHardware == NULL)
						return;
					if ((pBaseHardware->HwdType != HTYPE_EnOceanESP2) && (pBaseHardware->HwdType != HTYPE_EnOceanESP3)
						&& (pBaseHardware->HwdType != HTYPE_USBtinGateway) )
						return;
					unsigned long rID = 0;
					if (pBaseHardware->HwdType == HTYPE_EnOceanESP2)
					{
						CEnOceanESP2 *pEnoceanHardware = reinterpret_cast<CEnOceanESP2*>(pBaseHardware);
						if (pEnoceanHardware->m_id_base == 0)
						{
							root[""message""] = ""BaseID not found, is the hardware running?"";
							return;
						}
						rID = pEnoceanHardware->m_id_base + iUnitTest;
					}
					else if (pBaseHardware->HwdType == HTYPE_EnOceanESP3)
					{
						CEnOceanESP3 *pEnoceanHardware = reinterpret_cast<CEnOceanESP3*>(pBaseHardware);
						if (pEnoceanHardware->m_id_base == 0)
						{
							root[""message""] = ""BaseID not found, is the hardware running?"";
							return;
						}
						rID = pEnoceanHardware->m_id_base + iUnitTest;
					}
					else if (pBaseHardware->HwdType == HTYPE_USBtinGateway)
					{
						USBtin *pUSBtinHardware = reinterpret_cast<USBtin *>(pBaseHardware);
						rID = pUSBtinHardware->switch_id_base;
						std::stringstream ssunitcode;
						ssunitcode << iUnitTest;
						sunitcode = ssunitcode.str();
					}
					std::stringstream s_strid;
					s_strid << std::hex << std::uppercase << rID;
					devid = s_strid.str();
				}
				else if (lighttype == 68)
				{
#ifdef WITH_GPIO
					dtype = pTypeLighting1;
					subtype = sTypeIMPULS;
					devid = ""0"";
					sunitcode = request::findValue(&req, ""unitcode""); //Unit code = GPIO number

					if (sunitcode.empty()) {
						return;
					}
					CGpio *pGpio = reinterpret_cast<CGpio *>(m_mainworker.GetHardware(atoi(hwdid.c_str())));
					if (pGpio == NULL) {
						return;
					}
					if (pGpio->HwdType != HTYPE_RaspberryGPIO) {
						return;
					}
					CGpioPin *pPin = CGpio::GetPPinById(atoi(sunitcode.c_str()));
					if (pPin == NULL) {
						return;
			}
#else
					return;
#endif
				}
				else if (lighttype == 69)
				{
#ifdef WITH_GPIO
					dtype = pTypeLighting2;
					subtype = sTypeAC;
					devid = ""0"";
					sunitcode = request::findValue(&req, ""unitcode""); // sysfs-gpio number
					int unitcode = atoi(sunitcode.c_str());
					std::string sswitchtype = request::findValue(&req, ""switchtype"");
					_eSwitchType switchtype = (_eSwitchType)atoi(sswitchtype.c_str());
					std::string id = request::findValue(&req, ""id"");
					CSysfsGpio::RequestDbUpdate(unitcode);

					if ((id.empty()) || (sunitcode.empty()))
					{
						return;
					}
					devid = id;

					CSysfsGpio *pSysfsGpio = reinterpret_cast<CSysfsGpio *>(m_mainworker.GetHardware(atoi(hwdid.c_str())));

					if ((pSysfsGpio == NULL) || (pSysfsGpio->HwdType != HTYPE_SysfsGpio))
					{
						return;
					}
#else
					return;
#endif
				}
				else if (lighttype < 20)
				{
					dtype = pTypeLighting1;
					subtype = lighttype;
					std::string shousecode = request::findValue(&req, ""housecode"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(shousecode.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = shousecode;
				}
				else if (lighttype < 30)
				{
					dtype = pTypeLighting2;
					subtype = lighttype - 20;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = id;
				}
				else if (lighttype < 70)
				{
					dtype = pTypeLighting5;
					subtype = lighttype - 50;
					if (lighttype == 59)
						subtype = sTypeIT;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					if ((subtype != sTypeEMW100) && (subtype != sTypeLivolo) && (subtype != sTypeLivolo1to10) && (subtype != sTypeRGB432W) && (subtype != sTypeLightwaveRF) && (subtype != sTypeIT))
						devid = ""00"" + id;
					else
						devid = id;
				}
				else if (lighttype == 101)
				{
					dtype = pTypeCurtain;
					subtype = sTypeHarrison;
					std::string shousecode = request::findValue(&req, ""housecode"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(shousecode.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = shousecode;
				}
				else if (lighttype == 102)
				{
					dtype = pTypeRFY;
					subtype = sTypeRFY;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = id;
				}
				else if (lighttype == 103)
				{
					dtype = pTypeSecurity1;
					subtype = sTypeMeiantech;
					std::string id = request::findValue(&req, ""id"");
					if (
						(id.empty())
						)
						return;
					devid = id;
					sunitcode = ""0"";
				}
				else if (lighttype == 104)
				{
					dtype = pTypeThermostat2;
					subtype = sTypeHE105;
					sunitcode = request::findValue(&req, ""unitcode"");
					if (sunitcode.empty())
						return;
					std::stringstream s_strid;
					s_strid << std::hex << std::uppercase << sunitcode;
					int iUnitCode;
					s_strid >> iUnitCode;
					sprintf(szTmp, ""%d"", iUnitCode);
					sunitcode = szTmp;
					devid = ""1"";
				}
				else if (lighttype == 105)
				{
					dtype = pTypeRFY;
					subtype = sTypeASA;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = id;
				}
				else if (lighttype == 106)
				{
					dtype = pTypeLighting6;
					subtype = sTypeBlyss;
					std::string sgroupcode = request::findValue(&req, ""groupcode"");
					sunitcode = request::findValue(&req, ""unitcode"");
					std::string id = request::findValue(&req, ""id"");
					if (
						(sgroupcode.empty()) ||
						(sunitcode.empty()) ||
						(id.empty())
						)
						return;
					devid = id + sgroupcode;
				}
				else if (lighttype == 107)
				{
					dtype = pTypeRFY;
					subtype = sTypeRFY2;
					std::string id = request::findValue(&req, ""id"");
					sunitcode = request::findValue(&req, ""unitcode"");
					if (
						(id.empty()) ||
						(sunitcode.empty())
						)
						return;
					devid = id;
				}
				else
				{
					if (lighttype == 100)
					{
						dtype = pTypeChime;
						subtype = sTypeByronSX;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						int iUnitCode = atoi(sunitcode.c_str()) - 1;
						switch (iUnitCode)
						{
						case 0:
							iUnitCode = chime_sound0;
							break;
						case 1:
							iUnitCode = chime_sound1;
							break;
						case 2:
							iUnitCode = chime_sound2;
							break;
						case 3:
							iUnitCode = chime_sound3;
							break;
						case 4:
							iUnitCode = chime_sound4;
							break;
						case 5:
							iUnitCode = chime_sound5;
							break;
						case 6:
							iUnitCode = chime_sound6;
							break;
						case 7:
							iUnitCode = chime_sound7;
							break;
						}
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						devid = id;
					}
					else if ((lighttype >= 200) && (lighttype < 300))
					{
						dtype = pTypeBlinds;
						subtype = lighttype - 200;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						int iUnitCode = atoi(sunitcode.c_str());
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						devid = id;
					}
					else if (lighttype == 301)
					{
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = id;

						dtype = pTypeRadiator1;
						subtype = sTypeSmartwares;

						result = m_sql.safe_query(
							""SELECT Name FROM DeviceStatus WHERE (HardwareID=='%q' AND DeviceID=='%q' AND Unit=='%q' AND Type==%d AND SubType==%d)"",
							hwdid.c_str(), devid.c_str(), sunitcode.c_str(), dtype, subtype);
						if (!result.empty())
						{
							root[""message""] = ""Switch already exists!"";
							return;
						}
						bool bActEnabledState = m_sql.m_bAcceptNewHardware;
						m_sql.m_bAcceptNewHardware = true;
						std::string devname;
						m_sql.UpdateValue(atoi(hwdid.c_str()), devid.c_str(), atoi(sunitcode.c_str()), dtype, subtype, 0, -1, 0, ""20.5"", devname);
						m_sql.m_bAcceptNewHardware = bActEnabledState;

						result = m_sql.safe_query(
							""SELECT ID FROM DeviceStatus WHERE (HardwareID=='%q' AND DeviceID=='%q' AND Unit=='%q' AND Type==%d AND SubType==%d)"",
							hwdid.c_str(), devid.c_str(), sunitcode.c_str(), dtype, subtype);
						if (result.empty())
						{
							root[""message""] = ""Error finding switch in Database!?!?"";
							return;
						}
						std::string ID = result[0][0];

						m_sql.safe_query(
							""UPDATE DeviceStatus SET Used=1, Name='%q', SwitchType=%d WHERE (ID == '%q')"",
							name.c_str(), switchtype, ID.c_str());

						dtype = pTypeRadiator1;
						subtype = sTypeSmartwaresSwitchRadiator;
					}
					else if (lighttype == 302)
					{
						dtype = pTypeHomeConfort;
						subtype = sTypeHomeConfortTEL010;
						std::string id = request::findValue(&req, ""id"");

						std::string shousecode = request::findValue(&req, ""housecode"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(shousecode.empty()) ||
							(sunitcode.empty())
							)
							return;

						int iUnitCode = atoi(sunitcode.c_str());
						sprintf(szTmp, ""%d"", iUnitCode);
						sunitcode = szTmp;
						sprintf(szTmp, ""%02X"", atoi(shousecode.c_str()));
						shousecode = szTmp;
						devid = id + shousecode;
					}
					else if (lighttype == 303)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchTypeSelector;
						std::string id = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(id.empty()) ||
							(sunitcode.empty())
							)
							return;
						devid = ""0"" + id;
						switchtype = STYPE_Selector;
						if (!deviceoptions.empty()) {
							deviceoptions.append("";"");
						}
						deviceoptions.append(""SelectorStyle:0;LevelNames:Off|Level1|Level2|Level3"");
					}
					else if (lighttype == 304)
					{
						dtype = pTypeFan;
						subtype = sTypeItho;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 305)
					{
						dtype = pTypeFan;
						subtype = sTypeLucciAir;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 306)
					{
						dtype = pTypeFan;
						subtype = sTypeLucciAirDC;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 307)
					{
						dtype = pTypeFan;
						subtype = sTypeWestinghouse;
						std::string id = request::findValue(&req, ""id"");
						if (id.empty())
							return;
						devid = id;
						sunitcode = ""0"";
					}
					else if (lighttype == 400)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchBlindsT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 401)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchLightT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 402)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchAuxiliaryT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 403)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchBlindsT2;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if (lighttype == 404)
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchLightT2;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
					else if ((lighttype == 405) || (lighttype == 406))
					{
						dtype = pTypeGeneralSwitch;
						subtype = sSwitchContactT1;
						devid = request::findValue(&req, ""id"");
						sunitcode = request::findValue(&req, ""unitcode"");
						if (
							(devid.empty()) ||
							(sunitcode.empty())
							)
							return;
					}
				}

				result = m_sql.safe_query(
					""SELECT Name FROM DeviceStatus WHERE (HardwareID=='%q' AND DeviceID=='%q' AND Unit=='%q' AND Type==%d AND SubType==%d)"",
					hwdid.c_str(), devid.c_str(), sunitcode.c_str(), dtype, subtype);
				if (!result.empty())
				{
					root[""message""] = ""Switch already exists!"";
					return;
				}

				CDomoticzHardwareBase *pBaseHardware = m_mainworker.GetHardware(atoi(hwdid.c_str()));
				if (pBaseHardware != NULL)
				{
					if ((pBaseHardware->HwdType == HTYPE_RFLINKUSB) || (pBaseHardware->HwdType == HTYPE_RFLINKTCP)) {
						ConvertToGeneralSwitchType(devid, dtype, subtype);
					}
				}

				bool bActEnabledState = m_sql.m_bAcceptNewHardware;
				m_sql.m_bAcceptNewHardware = true;
				std::string devname;
				m_sql.UpdateValue(atoi(hwdid.c_str()), devid.c_str(), atoi(sunitcode.c_str()), dtype, subtype, 0, -1, 0, devname);
				m_sql.m_bAcceptNewHardware = bActEnabledState;

				result = m_sql.safe_query(
					""SELECT ID FROM DeviceStatus WHERE (HardwareID=='%q' AND DeviceID=='%q' AND Unit=='%q' AND Type==%d AND SubType==%d)"",
					hwdid.c_str(), devid.c_str(), sunitcode.c_str(), dtype, subtype);
				if (result.empty())
				{
					root[""message""] = ""Error finding switch in Database!?!?"";
					return;
				}
				std::string ID = result[0][0];

				m_sql.safe_query(
					""UPDATE DeviceStatus SET Used=1, Name='%q', SwitchType=%d WHERE (ID == '%q')"",
					name.c_str(), switchtype, ID.c_str());
				m_mainworker.m_eventsystem.GetCurrentStates();

				m_sql.SetDeviceOptions(atoi(ID.c_str()), m_sql.BuildDeviceOptions(deviceoptions, false));

				if (maindeviceidx != """")
				{
					if (maindeviceidx != ID)
					{
						result = m_sql.safe_query(
							""SELECT ID FROM LightSubDevices WHERE (DeviceRowID=='%q') AND (ParentID =='%q')"",
							ID.c_str(), maindeviceidx.c_str());
						if (result.empty())
						{
							result = m_sql.safe_query(
								""INSERT INTO LightSubDevices (DeviceRowID, ParentID) VALUES ('%q','%q')"",
								ID.c_str(),
								maindeviceidx.c_str()
							);
						}
					}
				}

				root[""status""] = ""OK"";
				root[""title""] = ""AddSwitch"";
			}
			else if (cparam == ""getnotificationtypes"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				result = m_sql.safe_query(""SELECT Type, SubType, SwitchType FROM DeviceStatus WHERE (ID == '%q')"",
					idx.c_str());
				if (result.empty())
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""GetNotificationTypes"";
				unsigned char dType = atoi(result[0][0].c_str());
				unsigned char dSubType = atoi(result[0][1].c_str());
				unsigned char switchtype = atoi(result[0][2].c_str());

				int ii = 0;
				if (
					(dType == pTypeLighting1) ||
					(dType == pTypeLighting2) ||
					(dType == pTypeLighting3) ||
					(dType == pTypeLighting4) ||
					(dType == pTypeLighting5) ||
					(dType == pTypeLighting6) ||
					(dType == pTypeColorSwitch) ||
					(dType == pTypeSecurity1) ||
					(dType == pTypeSecurity2) ||
					(dType == pTypeEvohome) ||
					(dType == pTypeEvohomeRelay) ||
					(dType == pTypeCurtain) ||
					(dType == pTypeBlinds) ||
					(dType == pTypeRFY) ||
					(dType == pTypeChime) ||
					(dType == pTypeThermostat2) ||
					(dType == pTypeThermostat3) ||
					(dType == pTypeThermostat4) ||
					(dType == pTypeRemote) ||
					(dType == pTypeGeneralSwitch) ||
					(dType == pTypeHomeConfort) ||
					(dType == pTypeFS20) ||
					((dType == pTypeRadiator1) && (dSubType == sTypeSmartwaresSwitchRadiator))
					)
				{
					if (switchtype != STYPE_PushOff)
					{
						root[""result""][ii][""val""] = NTYPE_SWITCH_ON;
						root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_SWITCH_ON, 0);
						root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_SWITCH_ON, 1);
						ii++;
					}
					if (switchtype != STYPE_PushOn)
					{
						root[""result""][ii][""val""] = NTYPE_SWITCH_OFF;
						root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_SWITCH_OFF, 0);
						root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_SWITCH_OFF, 1);
						ii++;
					}
					if (switchtype == STYPE_Media)
					{
						std::string idx = request::findValue(&req, ""idx"");

						result = m_sql.safe_query(""SELECT HardwareID FROM DeviceStatus WHERE (ID=='%q')"", idx.c_str());
						if (!result.empty())
						{
							std::string hdwid = result[0][0];
							CDomoticzHardwareBase *pBaseHardware = reinterpret_cast<CDomoticzHardwareBase*>(m_mainworker.GetHardware(atoi(hdwid.c_str())));
							if (pBaseHardware != NULL) {
								_eHardwareTypes type = pBaseHardware->HwdType;
								root[""result""][ii][""val""] = NTYPE_PAUSED;
								root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_PAUSED, 0);
								root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_PAUSED, 1);
								ii++;
								if (type == HTYPE_Kodi) {
									root[""result""][ii][""val""] = NTYPE_AUDIO;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AUDIO, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AUDIO, 1);
									ii++;
									root[""result""][ii][""val""] = NTYPE_VIDEO;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_VIDEO, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_VIDEO, 1);
									ii++;
									root[""result""][ii][""val""] = NTYPE_PHOTO;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_PHOTO, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_PHOTO, 1);
									ii++;
								}
								if (type == HTYPE_LogitechMediaServer) {
									root[""result""][ii][""val""] = NTYPE_PLAYING;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_PLAYING, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_PLAYING, 1);
									ii++;
									root[""result""][ii][""val""] = NTYPE_STOPPED;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_STOPPED, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_STOPPED, 1);
									ii++;
								}
								if (type == HTYPE_HEOS) {
									root[""result""][ii][""val""] = NTYPE_PLAYING;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_PLAYING, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_PLAYING, 1);
									ii++;
									root[""result""][ii][""val""] = NTYPE_STOPPED;
									root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_STOPPED, 0);
									root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_STOPPED, 1);
									ii++;
								}
							}
						}
					}
				}
				if (
					(
					(dType == pTypeTEMP) ||
						(dType == pTypeTEMP_HUM) ||
						(dType == pTypeTEMP_HUM_BARO) ||
						(dType == pTypeTEMP_BARO) ||
						(dType == pTypeEvohomeZone) ||
						(dType == pTypeEvohomeWater) ||
						(dType == pTypeThermostat1) ||
						(dType == pTypeRego6XXTemp) ||
						((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp))
						) ||
						((dType == pTypeUV) && (dSubType == sTypeUV3)) ||
					((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
					((dType == pTypeWIND) && (dSubType == sTypeWINDNoTemp)) ||
					((dType == pTypeGeneral) && (dSubType == sTypeSystemTemp))
					)
				{
					root[""result""][ii][""val""] = NTYPE_TEMPERATURE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TEMPERATURE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TEMPERATURE, 1);
					ii++;
				}
				if (
					(dType == pTypeHUM) ||
					(dType == pTypeTEMP_HUM) ||
					(dType == pTypeTEMP_HUM_BARO)
					)
				{
					root[""result""][ii][""val""] = NTYPE_HUMIDITY;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_HUMIDITY, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_HUMIDITY, 1);
					ii++;
				}
				if (
					(dType == pTypeTEMP_HUM) ||
					(dType == pTypeTEMP_HUM_BARO)
					)
				{
					root[""result""][ii][""val""] = NTYPE_DEWPOINT;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_DEWPOINT, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_DEWPOINT, 1);
					ii++;
				}
				if (dType == pTypeRAIN)
				{
					root[""result""][ii][""val""] = NTYPE_RAIN;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_RAIN, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_RAIN, 1);
					ii++;
				}
				if (dType == pTypeWIND)
				{
					root[""result""][ii][""val""] = NTYPE_WIND;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_WIND, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_WIND, 1);
					ii++;
				}
				if (dType == pTypeUV)
				{
					root[""result""][ii][""val""] = NTYPE_UV;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_UV, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_UV, 1);
					ii++;
				}
				if (
					(dType == pTypeTEMP_HUM_BARO) ||
					(dType == pTypeBARO) ||
					(dType == pTypeTEMP_BARO)
					)
				{
					root[""result""][ii][""val""] = NTYPE_BARO;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_BARO, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_BARO, 1);
					ii++;
				}
				if (
					((dType == pTypeRFXMeter) && (dSubType == sTypeRFXMeterCount)) ||
					((dType == pTypeGeneral) && (dSubType == sTypeCounterIncremental)) ||
					(dType == pTypeYouLess) ||
					((dType == pTypeRego6XXValue) && (dSubType == sTypeRego6XXCounter))
					)
				{
					if ((switchtype == MTYPE_ENERGY) || (switchtype == MTYPE_ENERGY_GENERATED))
					{
						root[""result""][ii][""val""] = NTYPE_TODAYENERGY;
						root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TODAYENERGY, 0);
						root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TODAYENERGY, 1);
					}
					else if (switchtype == MTYPE_GAS)
					{
						root[""result""][ii][""val""] = NTYPE_TODAYGAS;
						root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TODAYGAS, 0);
						root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TODAYGAS, 1);
					}
					else if (switchtype == MTYPE_COUNTER)
					{
						root[""result""][ii][""val""] = NTYPE_TODAYCOUNTER;
						root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TODAYCOUNTER, 0);
						root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TODAYCOUNTER, 1);
					}
					else
					{
						root[""result""][ii][""val""] = NTYPE_TODAYGAS;
						root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TODAYGAS, 0);
						root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TODAYGAS, 1);
					}
					ii++;
				}
				if (dType == pTypeYouLess)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if (dType == pTypeAirQuality)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				else if ((dType == pTypeGeneral) && ((dSubType == sTypeSoilMoisture) || (dSubType == sTypeLeafWetness)))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeVisibility))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeDistance))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeSolarRadiation))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeVoltage))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypePressure))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if (dType == pTypeLux)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeSoundLevel))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if (dType == pTypeWEIGHT)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if (dType == pTypeUsage)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if (
					(dType == pTypeENERGY) ||
					((dType == pTypeGeneral) && (dSubType == sTypeKwh))
					)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if (dType == pTypePOWER)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeCURRENT) && (dSubType == sTypeELEC1))
				{
					root[""result""][ii][""val""] = NTYPE_AMPERE1;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AMPERE1, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AMPERE1, 1);
					ii++;
					root[""result""][ii][""val""] = NTYPE_AMPERE2;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AMPERE2, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AMPERE2, 1);
					ii++;
					root[""result""][ii][""val""] = NTYPE_AMPERE3;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AMPERE3, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AMPERE3, 1);
					ii++;
				}
				if ((dType == pTypeCURRENTENERGY) && (dSubType == sTypeELEC4))
				{
					root[""result""][ii][""val""] = NTYPE_AMPERE1;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AMPERE1, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AMPERE1, 1);
					ii++;
					root[""result""][ii][""val""] = NTYPE_AMPERE2;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AMPERE2, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AMPERE2, 1);
					ii++;
					root[""result""][ii][""val""] = NTYPE_AMPERE3;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_AMPERE3, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_AMPERE3, 1);
					ii++;
				}
				if (dType == pTypeP1Power)
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
					root[""result""][ii][""val""] = NTYPE_TODAYENERGY;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TODAYENERGY, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TODAYENERGY, 1);
					ii++;
				}
				if (dType == pTypeP1Gas)
				{
					root[""result""][ii][""val""] = NTYPE_TODAYGAS;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TODAYGAS, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TODAYGAS, 1);
					ii++;
				}
				if ((dType == pTypeThermostat) && (dSubType == sTypeThermSetpoint))
				{
					root[""result""][ii][""val""] = NTYPE_TEMPERATURE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_TEMPERATURE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_TEMPERATURE, 1);
					ii++;
				}
				if (dType == pTypeEvohomeZone)
				{
					root[""result""][ii][""val""] = NTYPE_TEMPERATURE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_SETPOINT, 0); //FIXME NTYPE_SETPOINT implementation?
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_SETPOINT, 1);
					ii++;
				}
				if ((dType == pTypeRFXSensor) && ((dSubType == sTypeRFXSensorAD) || (dSubType == sTypeRFXSensorVolt)))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypePercentage))
				{
					root[""result""][ii][""val""] = NTYPE_PERCENTAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_PERCENTAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_PERCENTAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeWaterflow))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeCustom))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeFan))
				{
					root[""result""][ii][""val""] = NTYPE_RPM;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_RPM, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_RPM, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeAlert))
				{
					root[""result""][ii][""val""] = NTYPE_USAGE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_USAGE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_USAGE, 1);
					ii++;
				}
				if ((dType == pTypeGeneral) && (dSubType == sTypeZWaveAlarm))
				{
					root[""result""][ii][""val""] = NTYPE_VALUE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_VALUE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_VALUE, 1);
					ii++;
				}
				if ((dType == pTypeRego6XXValue) && (dSubType == sTypeRego6XXStatus))
				{
					root[""result""][ii][""val""] = NTYPE_SWITCH_ON;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_SWITCH_ON, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_SWITCH_ON, 1);
					ii++;
					root[""result""][ii][""val""] = NTYPE_SWITCH_OFF;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_SWITCH_OFF, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_SWITCH_OFF, 1);
					ii++;
				}
				if (!IsLightOrSwitch(dType, dSubType))
				{
					root[""result""][ii][""val""] = NTYPE_LASTUPDATE;
					root[""result""][ii][""text""] = Notification_Type_Desc(NTYPE_LASTUPDATE, 0);
					root[""result""][ii][""ptag""] = Notification_Type_Desc(NTYPE_LASTUPDATE, 1);
					ii++;
				}
			}
			else if (cparam == ""addnotification"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;

				std::string stype = request::findValue(&req, ""ttype"");
				std::string swhen = request::findValue(&req, ""twhen"");
				std::string svalue = request::findValue(&req, ""tvalue"");
				std::string scustommessage = request::findValue(&req, ""tmsg"");
				std::string sactivesystems = request::findValue(&req, ""tsystems"");
				std::string spriority = request::findValue(&req, ""tpriority"");
				std::string ssendalways = request::findValue(&req, ""tsendalways"");
				std::string srecovery = (request::findValue(&req, ""trecovery"") == ""true"") ? ""1"" : ""0"";

				if ((stype.empty()) || (swhen.empty()) || (svalue.empty()) || (spriority.empty()) || (ssendalways.empty()) || (srecovery.empty()))
					return;

				_eNotificationTypes ntype = (_eNotificationTypes)atoi(stype.c_str());
				std::string ttype = Notification_Type_Desc(ntype, 1);
				if (
					(ntype == NTYPE_SWITCH_ON) ||
					(ntype == NTYPE_SWITCH_OFF) ||
					(ntype == NTYPE_DEWPOINT)
					)
				{
					if ((ntype == NTYPE_SWITCH_ON) && (swhen == ""2"")) { // '='
						unsigned char twhen = '=';
						sprintf(szTmp, ""%s;%c;%s"", ttype.c_str(), twhen, svalue.c_str());
					}
					else
						strcpy(szTmp, ttype.c_str());
				}
				else
				{
					std::string twhen;
					if (swhen == ""0"")
						twhen = "">"";
					else if (swhen == ""1"")
						twhen = "">="";
					else if (swhen == ""2"")
						twhen = ""="";
					else if (swhen == ""3"")
						twhen = ""!="";
					else if (swhen == ""4"")
						twhen = ""<="";
					else
						twhen = ""<"";
					sprintf(szTmp, ""%s;%s;%s;%s"", ttype.c_str(), twhen.c_str(), svalue.c_str(), srecovery.c_str());
				}
				int priority = atoi(spriority.c_str());
				bool bOK = m_notifications.AddNotification(idx, szTmp, scustommessage, sactivesystems, priority, (ssendalways == ""true"") ? true : false);
				if (bOK) {
					root[""status""] = ""OK"";
					root[""title""] = ""AddNotification"";
				}
			}
			else if (cparam == ""updatenotification"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string devidx = request::findValue(&req, ""devidx"");
				if ((idx.empty()) || (devidx.empty()))
					return;

				std::string stype = request::findValue(&req, ""ttype"");
				std::string swhen = request::findValue(&req, ""twhen"");
				std::string svalue = request::findValue(&req, ""tvalue"");
				std::string scustommessage = request::findValue(&req, ""tmsg"");
				std::string sactivesystems = request::findValue(&req, ""tsystems"");
				std::string spriority = request::findValue(&req, ""tpriority"");
				std::string ssendalways = request::findValue(&req, ""tsendalways"");
				std::string srecovery = (request::findValue(&req, ""trecovery"") == ""true"") ? ""1"" : ""0"";

				if ((stype.empty()) || (swhen.empty()) || (svalue.empty()) || (spriority.empty()) || (ssendalways.empty()) || srecovery.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""UpdateNotification"";

				std::string recoverymsg;
				if ((srecovery == ""1"") && (m_notifications.CustomRecoveryMessage(strtoull(idx.c_str(), NULL, 0), recoverymsg, true)))
				{
					scustommessage.append("";;"");
					scustommessage.append(recoverymsg);
				}
				m_notifications.RemoveNotification(idx);

				_eNotificationTypes ntype = (_eNotificationTypes)atoi(stype.c_str());
				std::string ttype = Notification_Type_Desc(ntype, 1);
				if (
					(ntype == NTYPE_SWITCH_ON) ||
					(ntype == NTYPE_SWITCH_OFF) ||
					(ntype == NTYPE_DEWPOINT)
					)
				{
					if ((ntype == NTYPE_SWITCH_ON) && (swhen == ""2"")) { // '='
						unsigned char twhen = '=';
						sprintf(szTmp, ""%s;%c;%s"", ttype.c_str(), twhen, svalue.c_str());
					}
					else
						strcpy(szTmp, ttype.c_str());
				}
				else
				{
					std::string twhen;
					if (swhen == ""0"")
						twhen = "">"";
					else if (swhen == ""1"")
						twhen = "">="";
					else if (swhen == ""2"")
						twhen = ""="";
					else if (swhen == ""3"")
						twhen = ""!="";
					else if (swhen == ""4"")
						twhen = ""<="";
					else
						twhen = ""<"";
					sprintf(szTmp, ""%s;%s;%s;%s"", ttype.c_str(), twhen.c_str(), svalue.c_str(), srecovery.c_str());
				}
				int priority = atoi(spriority.c_str());
				m_notifications.AddNotification(devidx, szTmp, scustommessage, sactivesystems, priority, (ssendalways == ""true"") ? true : false);
			}
			else if (cparam == ""deletenotification"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""DeleteNotification"";

				m_notifications.RemoveNotification(idx);
			}
			else if (cparam == ""switchdeviceorder"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx1 = request::findValue(&req, ""idx1"");
				std::string idx2 = request::findValue(&req, ""idx2"");
				if ((idx1.empty()) || (idx2.empty()))
					return;
				std::string sroomid = request::findValue(&req, ""roomid"");
				int roomid = atoi(sroomid.c_str());

				std::string Order1, Order2;
				if (roomid == 0)
				{
					result = m_sql.safe_query(""SELECT [Order] FROM DeviceStatus WHERE (ID == '%q')"",
						idx1.c_str());
					if (result.empty())
						return;
					Order1 = result[0][0];

					result = m_sql.safe_query(""SELECT [Order] FROM DeviceStatus WHERE (ID == '%q')"",
						idx2.c_str());
					if (result.empty())
						return;
					Order2 = result[0][0];

					root[""status""] = ""OK"";
					root[""title""] = ""SwitchDeviceOrder"";

					if (atoi(Order1.c_str()) < atoi(Order2.c_str()))
					{
						m_sql.safe_query(
							""UPDATE DeviceStatus SET [Order] = [Order]+1 WHERE ([Order] >= '%q' AND [Order] < '%q')"",
							Order1.c_str(), Order2.c_str());
					}
					else
					{
						m_sql.safe_query(
							""UPDATE DeviceStatus SET [Order] = [Order]-1 WHERE ([Order] > '%q' AND [Order] <= '%q')"",
							Order2.c_str(), Order1.c_str());
					}

					m_sql.safe_query(""UPDATE DeviceStatus SET [Order] = '%q' WHERE (ID == '%q')"",
						Order1.c_str(), idx2.c_str());
				}
				else
				{
					result = m_sql.safe_query(""SELECT [Order] FROM DeviceToPlansMap WHERE (DeviceRowID == '%q') AND (PlanID==%d)"",
						idx1.c_str(), roomid);
					if (result.empty())
						return;
					Order1 = result[0][0];

					result = m_sql.safe_query(""SELECT [Order] FROM DeviceToPlansMap WHERE (DeviceRowID == '%q') AND (PlanID==%d)"",
						idx2.c_str(), roomid);
					if (result.empty())
						return;
					Order2 = result[0][0];

					root[""status""] = ""OK"";
					root[""title""] = ""SwitchDeviceOrder"";

					if (atoi(Order1.c_str()) < atoi(Order2.c_str()))
					{
						m_sql.safe_query(
							""UPDATE DeviceToPlansMap SET [Order] = [Order]+1 WHERE ([Order] >= '%q' AND [Order] < '%q') AND (PlanID==%d)"",
							Order1.c_str(), Order2.c_str(), roomid);
					}
					else
					{
						m_sql.safe_query(
							""UPDATE DeviceToPlansMap SET [Order] = [Order]-1 WHERE ([Order] > '%q' AND [Order] <= '%q') AND (PlanID==%d)"",
							Order2.c_str(), Order1.c_str(), roomid);
					}

					m_sql.safe_query(""UPDATE DeviceToPlansMap SET [Order] = '%q' WHERE (DeviceRowID == '%q') AND (PlanID==%d)"",
						Order1.c_str(), idx2.c_str(), roomid);
				}
			}
			else if (cparam == ""switchsceneorder"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx1 = request::findValue(&req, ""idx1"");
				std::string idx2 = request::findValue(&req, ""idx2"");
				if ((idx1.empty()) || (idx2.empty()))
					return;

				std::string Order1, Order2;
				result = m_sql.safe_query(""SELECT [Order] FROM Scenes WHERE (ID == '%q')"",
					idx1.c_str());
				if (result.empty())
					return;
				Order1 = result[0][0];

				result = m_sql.safe_query(""SELECT [Order] FROM Scenes WHERE (ID == '%q')"",
					idx2.c_str());
				if (result.empty())
					return;
				Order2 = result[0][0];

				root[""status""] = ""OK"";
				root[""title""] = ""SwitchSceneOrder"";

				if (atoi(Order1.c_str()) < atoi(Order2.c_str()))
				{
					m_sql.safe_query(
						""UPDATE Scenes SET [Order] = [Order]+1 WHERE ([Order] >= '%q' AND [Order] < '%q')"",
						Order1.c_str(), Order2.c_str());
				}
				else
				{
					m_sql.safe_query(
						""UPDATE Scenes SET [Order] = [Order]-1 WHERE ([Order] > '%q' AND [Order] <= '%q')"",
						Order2.c_str(), Order1.c_str());
				}

				m_sql.safe_query(""UPDATE Scenes SET [Order] = '%q' WHERE (ID == '%q')"",
					Order1.c_str(), idx2.c_str());
			}
			else if (cparam == ""clearnotifications"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""ClearNotification"";

				m_notifications.RemoveDeviceNotifications(idx);
			}
			else if (cparam == ""adduser"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string senabled = request::findValue(&req, ""enabled"");
				std::string username = request::findValue(&req, ""username"");
				std::string password = request::findValue(&req, ""password"");
				std::string srights = request::findValue(&req, ""rights"");
				std::string sRemoteSharing = request::findValue(&req, ""RemoteSharing"");
				std::string sTabsEnabled = request::findValue(&req, ""TabsEnabled"");
				if (
					(senabled.empty()) ||
					(username.empty()) ||
					(password.empty()) ||
					(srights.empty()) ||
					(sRemoteSharing.empty()) ||
					(sTabsEnabled.empty())
					)
					return;
				int rights = atoi(srights.c_str());
				if (rights != 2)
				{
					if (!FindAdminUser())
					{
						root[""message""] = ""Add a Admin user first! (Or enable Settings/Website Protection)"";
						return;
					}
				}
				root[""status""] = ""OK"";
				root[""title""] = ""AddUser"";
				m_sql.safe_query(
					""INSERT INTO Users (Active, Username, Password, Rights, RemoteSharing, TabsEnabled) VALUES (%d,'%q','%q','%d','%d','%d')"",
					(senabled == ""true"") ? 1 : 0,
					base64_encode(username).c_str(),
					password.c_str(),
					rights,
					(sRemoteSharing == ""true"") ? 1 : 0,
					atoi(sTabsEnabled.c_str())
				);
				LoadUsers();
			}
			else if (cparam == ""updateuser"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				std::string senabled = request::findValue(&req, ""enabled"");
				std::string username = request::findValue(&req, ""username"");
				std::string password = request::findValue(&req, ""password"");
				std::string srights = request::findValue(&req, ""rights"");
				std::string sRemoteSharing = request::findValue(&req, ""RemoteSharing"");
				std::string sTabsEnabled = request::findValue(&req, ""TabsEnabled"");
				if (
					(senabled.empty()) ||
					(username.empty()) ||
					(password.empty()) ||
					(srights.empty()) ||
					(sRemoteSharing.empty()) ||
					(sTabsEnabled.empty())
					)
					return;
				int rights = atoi(srights.c_str());
				if (rights != 2)
				{
					if (!FindAdminUser())
					{
						root[""message""] = ""Add a Admin user first! (Or enable Settings/Website Protection)"";
						return;
					}
				}
				std::string sHashedUsername = base64_encode(username);

				std::string sOldUsername;
				std::string sOldPassword;
				result = m_sql.safe_query(""SELECT Username, Password FROM Users WHERE (ID == '%q')"", idx.c_str());
				if (result.size() == 1)
				{
					sOldUsername = result[0][0];
					sOldPassword = result[0][1];
				}
				if ((sHashedUsername != sOldUsername) || (password != sOldPassword))
					RemoveUsersSessions(sOldUsername, session);

				root[""status""] = ""OK"";
				root[""title""] = ""UpdateUser"";
				m_sql.safe_query(
					""UPDATE Users SET Active=%d, Username='%q', Password='%q', Rights=%d, RemoteSharing=%d, TabsEnabled=%d WHERE (ID == '%q')"",
					(senabled == ""true"") ? 1 : 0,
					sHashedUsername.c_str(),
					password.c_str(),
					rights,
					(sRemoteSharing == ""true"") ? 1 : 0,
					atoi(sTabsEnabled.c_str()),
					idx.c_str()
				);
				LoadUsers();


			}
			else if (cparam == ""deleteuser"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""DeleteUser"";

				result = m_sql.safe_query(""SELECT Username FROM Users WHERE (ID == '%q')"", idx.c_str());
				if (result.size() == 1)
				{
					RemoveUsersSessions(result[0][0], session);
				}

				m_sql.safe_query(""DELETE FROM Users WHERE (ID == '%q')"", idx.c_str());

				m_sql.safe_query(""DELETE FROM SharedDevices WHERE (SharedUserID == '%q')"", idx.c_str());

				LoadUsers();
			}
			else if (cparam == ""clearlightlog"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				result = m_sql.safe_query(""SELECT Type, SubType FROM DeviceStatus WHERE (ID == '%q')"",
					idx.c_str());
				if (result.empty())
					return;

				unsigned char dType = atoi(result[0][0].c_str());
				unsigned char dSubType = atoi(result[0][1].c_str());

				if (
					(dType != pTypeLighting1) &&
					(dType != pTypeLighting2) &&
					(dType != pTypeLighting3) &&
					(dType != pTypeLighting4) &&
					(dType != pTypeLighting5) &&
					(dType != pTypeLighting6) &&
					(dType != pTypeFan) &&
					(dType != pTypeColorSwitch) &&
					(dType != pTypeSecurity1) &&
					(dType != pTypeSecurity2) &&
					(dType != pTypeEvohome) &&
					(dType != pTypeEvohomeRelay) &&
					(dType != pTypeCurtain) &&
					(dType != pTypeBlinds) &&
					(dType != pTypeRFY) &&
					(dType != pTypeChime) &&
					(dType != pTypeThermostat2) &&
					(dType != pTypeThermostat3) &&
					(dType != pTypeThermostat4) &&
					(dType != pTypeRemote) &&
					(dType != pTypeGeneralSwitch) &&
					(dType != pTypeHomeConfort) &&
					(dType != pTypeFS20) &&
					(!((dType == pTypeRadiator1) && (dSubType == sTypeSmartwaresSwitchRadiator))) &&
					(!((dType == pTypeGeneral) && (dSubType == sTypeTextStatus))) &&
					(!((dType == pTypeGeneral) && (dSubType == sTypeAlert)))
					)
					return; //no light device! we should not be here!

				root[""status""] = ""OK"";
				root[""title""] = ""ClearLightLog"";

				result = m_sql.safe_query(""DELETE FROM LightingLog WHERE (DeviceRowID=='%q')"", idx.c_str());
			}
			else if (cparam == ""clearscenelog"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""ClearSceneLog"";

				result = m_sql.safe_query(""DELETE FROM SceneLog WHERE (SceneRowID=='%q')"", idx.c_str());
			}
			else if (cparam == ""learnsw"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				m_sql.AllowNewHardwareTimer(5);
				m_sql.m_LastSwitchID = """";
				bool bReceivedSwitch = false;
				unsigned char cntr = 0;
				while ((!bReceivedSwitch) && (cntr < 50))	//wait for max. 5 seconds
				{
					if (m_sql.m_LastSwitchID != """")
					{
						bReceivedSwitch = true;
						break;
					}
					else
					{
						sleep_milliseconds(100);
						cntr++;
					}
				}
				if (bReceivedSwitch)
				{
					result = m_sql.safe_query(""SELECT Name, Used, nValue FROM DeviceStatus WHERE (ID==%"" PRIu64 "")"",
						m_sql.m_LastSwitchRowID);
					if (!result.empty())
					{
						root[""status""] = ""OK"";
						root[""title""] = ""LearnSW"";
						root[""ID""] = m_sql.m_LastSwitchID;
						root[""idx""] = m_sql.m_LastSwitchRowID;
						root[""Name""] = result[0][0];
						root[""Used""] = atoi(result[0][1].c_str());
						root[""Cmd""] = atoi(result[0][2].c_str());
					}
				}
			} //learnsw
			else if (cparam == ""makefavorite"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string sisfavorite = request::findValue(&req, ""isfavorite"");
				if ((idx.empty()) || (sisfavorite.empty()))
					return;
				int isfavorite = atoi(sisfavorite.c_str());
				m_sql.safe_query(""UPDATE DeviceStatus SET Favorite=%d WHERE (ID == '%q')"",
					isfavorite, idx.c_str());
				root[""status""] = ""OK"";
				root[""title""] = ""MakeFavorite"";
			} //makefavorite
			else if (cparam == ""makescenefavorite"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string sisfavorite = request::findValue(&req, ""isfavorite"");
				if ((idx.empty()) || (sisfavorite.empty()))
					return;
				int isfavorite = atoi(sisfavorite.c_str());
				m_sql.safe_query(""UPDATE Scenes SET Favorite=%d WHERE (ID == '%q')"",
					isfavorite, idx.c_str());
				root[""status""] = ""OK"";
				root[""title""] = ""MakeSceneFavorite"";
			} //makescenefavorite
			else if (cparam == ""resetsecuritystatus"")
			{
				std::string idx = request::findValue(&req, ""idx"");
				std::string switchcmd = request::findValue(&req, ""switchcmd"");

				if ((idx.empty()) || (switchcmd.empty()))
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""ResetSecurityStatus"";

				int nValue = -1;


				if (switchcmd == ""Panic End"") {
					nValue = 7;
				}
				else if (switchcmd == ""Normal"") {
					nValue = 0;
				}

				if (nValue >= 0)
				{
					m_sql.safe_query(""UPDATE DeviceStatus SET nValue=%d WHERE (ID == '%q')"",
						nValue, idx.c_str());
					root[""status""] = ""OK"";
					root[""title""] = ""SwitchLight"";
				}
			}
			else if (cparam == ""verifypasscode"")
			{
				std::string passcode = request::findValue(&req, ""passcode"");
				if (passcode.empty())
					return;
				passcode = GenerateMD5Hash(passcode);
				std::string rpassword;
				int nValue = 1;
				m_sql.GetPreferencesVar(""ProtectionPassword"", nValue, rpassword);
				if (passcode == rpassword)
				{
					root[""title""] = ""VerifyPasscode"";
					root[""status""] = ""OK"";
					return;
				}
			}
			else if (cparam == ""switchmodal"")
			{
				int urights = 3;
				if (bHaveUser)
				{
					int iUser = -1;
					iUser = FindUser(session.username.c_str());
					if (iUser != -1)
					{
						urights = (int)m_users[iUser].userrights;
						_log.Log(LOG_STATUS, ""User: %s initiated a modal command"", m_users[iUser].Username.c_str());
					}
				}
				if (urights < 1)
					return;

				std::string idx = request::findValue(&req, ""idx"");
				std::string switchcmd = request::findValue(&req, ""status"");
				std::string until = request::findValue(&req, ""until"");//optional until date / time as applicable
				std::string action = request::findValue(&req, ""action"");//Run action or not (update status only)
				std::string onlyonchange = request::findValue(&req, ""ooc"");//No update unless the value changed (check if updated)
				if ((idx.empty()) || (switchcmd.empty()))
					return;

				std::string passcode = request::findValue(&req, ""passcode"");
				if (passcode.size() > 0)
				{
					passcode = GenerateMD5Hash(passcode);
					std::string rpassword;
					int nValue = 1;
					m_sql.GetPreferencesVar(""ProtectionPassword"", nValue, rpassword);
					if (passcode != rpassword)
					{
						root[""title""] = ""Modal"";
						root[""status""] = ""ERROR"";
						root[""message""] = ""WRONG CODE"";
						return;
					}
				}

				if (m_mainworker.SwitchModal(idx, switchcmd, action, onlyonchange, until) == true)//FIXME we need to return a status of already set / no update if ooc==""1"" and no status update was performed
				{
					root[""status""] = ""OK"";
					root[""title""] = ""Modal"";
				}
			}
			else if (cparam == ""switchlight"")
			{
				if (session.rights < 1)
				{
					session.reply_status = reply::forbidden;
					return; //Only user/admin allowed
				}
				std::string Username = ""Admin"";
				if (!session.username.empty())
					Username = session.username;

				std::string idx = request::findValue(&req, ""idx"");

				std::string switchcmd = request::findValue(&req, ""switchcmd"");
				std::string level = ""-1"";
				if (switchcmd == ""Set Level"")
					level = request::findValue(&req, ""level"");
				std::string onlyonchange = request::findValue(&req, ""ooc"");//No update unless the value changed (check if updated)
				_log.Debug(DEBUG_WEBSERVER, ""WEBS switchlight idx:%s switchcmd:%s level:%s"", idx.c_str(), switchcmd.c_str(), level.c_str());
				std::string passcode = request::findValue(&req, ""passcode"");
				if ((idx.empty()) || (switchcmd.empty()) || ((switchcmd == ""Set Level"") && (level.empty())) )
					return;

				result = m_sql.safe_query(
					""SELECT [Protected],[Name] FROM DeviceStatus WHERE (ID = '%q')"", idx.c_str());
				if (result.empty())
				{
					return;
				}
				bool bIsProtected = atoi(result[0][0].c_str()) != 0;
				std::string sSwitchName = result[0][1];
				if (session.rights == 1)
				{
					if (!IsIdxForUser(&session, atoi(idx.c_str())))
					{
						_log.Log(LOG_ERROR, ""User: %s initiated a Unauthorized switch command!"", Username.c_str());
						session.reply_status = reply::forbidden;
						return;
					}
				}

				if (bIsProtected)
				{
					if (passcode.empty())
					{
						root[""title""] = ""SwitchLight"";
						root[""status""] = ""ERROR"";
						root[""message""] = ""WRONG CODE"";
						return;
					}
					passcode = GenerateMD5Hash(passcode);
					std::string rpassword;
					int nValue = 1;
					m_sql.GetPreferencesVar(""ProtectionPassword"", nValue, rpassword);
					if (passcode != rpassword)
					{
						_log.Log(LOG_ERROR, ""User: %s initiated a switch command (Wrong code!)"", Username.c_str());
						root[""title""] = ""SwitchLight"";
						root[""status""] = ""ERROR"";
						root[""message""] = ""WRONG CODE"";
						return;
					}
				}

				_log.Log(LOG_STATUS, ""User: %s initiated a switch command (%s/%s/%s)"", Username.c_str(), idx.c_str(), sSwitchName.c_str(), switchcmd.c_str());

				root[""title""] = ""SwitchLight"";
				if (m_mainworker.SwitchLight(idx, switchcmd, level, ""-1"", onlyonchange, 0) == true)
				{
					root[""status""] = ""OK"";
				}
				else
				{
					root[""status""] = ""ERROR"";
					root[""message""] = ""Error sending switch command, check device/hardware !"";
				}
			} //(rtype==""switchlight"")
			else if (cparam == ""switchscene"")
			{
				if (session.rights < 1)
				{
					session.reply_status = reply::forbidden;
					return; //Only user/admin allowed
				}
				std::string Username = ""Admin"";
				if (!session.username.empty())
					Username = session.username;

				std::string idx = request::findValue(&req, ""idx"");
				std::string switchcmd = request::findValue(&req, ""switchcmd"");
				std::string passcode = request::findValue(&req, ""passcode"");
				if ((idx.empty()) || (switchcmd.empty()))
					return;

				result = m_sql.safe_query(
					""SELECT [Protected] FROM Scenes WHERE (ID = '%q')"", idx.c_str());
				if (result.empty())
				{
					return;
				}
				bool bIsProtected = atoi(result[0][0].c_str()) != 0;
				if (bIsProtected)
				{
					if (passcode.empty())
					{
						root[""title""] = ""SwitchScene"";
						root[""status""] = ""ERROR"";
						root[""message""] = ""WRONG CODE"";
						return;
					}
					passcode = GenerateMD5Hash(passcode);
					std::string rpassword;
					int nValue = 1;
					m_sql.GetPreferencesVar(""ProtectionPassword"", nValue, rpassword);
					if (passcode != rpassword)
					{
						root[""title""] = ""SwitchScene"";
						root[""status""] = ""ERROR"";
						root[""message""] = ""WRONG CODE"";
						_log.Log(LOG_ERROR, ""User: %s initiated a scene/group command (Wrong code!)"", Username.c_str());
						return;
					}
				}
				_log.Log(LOG_STATUS, ""User: %s initiated a scene/group command"", Username.c_str());

				if (m_mainworker.SwitchScene(idx, switchcmd) == true)
				{
					root[""status""] = ""OK"";
					root[""title""] = ""SwitchScene"";
				}
			} //(rtype==""switchscene"")
			else if (cparam == ""getSunRiseSet"") {
				if (!m_mainworker.m_LastSunriseSet.empty())
				{
					std::vector<std::string> strarray;
					StringSplit(m_mainworker.m_LastSunriseSet, "";"", strarray);
					if (strarray.size() == 10)
					{
						struct tm loctime;
						time_t now = mytime(NULL);

						localtime_r(&now, &loctime);
						strftime(szTmp, 80, ""%Y-%m-%d %X"", &loctime);

						root[""status""] = ""OK"";
						root[""title""] = ""getSunRiseSet"";
						root[""ServerTime""] = szTmp;
						root[""Sunrise""] = strarray[0];
						root[""Sunset""] = strarray[1];
						root[""SunAtSouth""] = strarray[2];
						root[""CivTwilightStart""] = strarray[3];
						root[""CivTwilightEnd""] = strarray[4];
						root[""NautTwilightStart""] = strarray[5];
						root[""NautTwilightEnd""] = strarray[6];
						root[""AstrTwilightStart""] = strarray[7];
						root[""AstrTwilightEnd""] = strarray[8];
						root[""DayLength""] = strarray[9];
					}
				}
			}
			else if (cparam == ""getServerTime"") {

				struct tm loctime;
				time_t now = mytime(NULL);

				localtime_r(&now, &loctime);
				strftime(szTmp, 80, ""%Y-%m-%d %X"", &loctime);

				root[""status""] = ""OK"";
				root[""title""] = ""getServerTime"";
				root[""ServerTime""] = szTmp;
			}
			else if (cparam == ""getsecstatus"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""GetSecStatus"";

				int secstatus = 0;
				m_sql.GetPreferencesVar(""SecStatus"", secstatus);
				root[""secstatus""] = secstatus;

				int secondelay = 30;
				m_sql.GetPreferencesVar(""SecOnDelay"", secondelay);
				root[""secondelay""] = secondelay;
			}
			else if (cparam == ""setsecstatus"")
			{
				std::string ssecstatus = request::findValue(&req, ""secstatus"");
				std::string seccode = request::findValue(&req, ""seccode"");
				if ((ssecstatus.empty()) || (seccode.empty()))
				{
					root[""message""] = ""WRONG CODE"";
					return;
				}
				root[""title""] = ""SetSecStatus"";
				std::string rpassword;
				int nValue = 1;
				m_sql.GetPreferencesVar(""SecPassword"", nValue, rpassword);
				if (seccode != rpassword)
				{
					root[""status""] = ""ERROR"";
					root[""message""] = ""WRONG CODE"";
					return;
				}
				root[""status""] = ""OK"";
				int iSecStatus = atoi(ssecstatus.c_str());
				m_mainworker.UpdateDomoticzSecurityStatus(iSecStatus);
			}
			else if (cparam == ""setcolbrightnessvalue"")
			{
				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}
				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				_tColor color;

				std::string json = request::findValue(&req, ""color"");
				std::string hex = request::findValue(&req, ""hex"");
				std::string hue = request::findValue(&req, ""hue"");
				std::string sat = request::findValue(&req, ""sat"");
				std::string brightness = request::findValue(&req, ""brightness"");
				std::string iswhite = request::findValue(&req, ""iswhite"");

				int ival = 100;
				float brightnessAdj = 1.0f;

				if (!json.empty())
				{
					color = _tColor(json);
					if (color.mode == ColorModeRGB)
					{
						float hsb[3];
						int r, g, b;
						rgb2hsb(color.r, color.g, color.b, hsb);
						hsb2rgb(hsb[0]*360.0f, hsb[1], 1.0f, r, g, b, 255);
						color.r = r;
						color.g = g;
						color.b = b;
						brightnessAdj = hsb[2];
					}

				}
				else if (!hex.empty())
				{
					uint64_t ihex = hexstrtoui64(hex);
					uint8_t r = 0;
					uint8_t g = 0;
					uint8_t b = 0;
					uint8_t cw = 0;
					uint8_t ww = 0;
					switch (hex.length())
					{
						case 6: //RGB
							r = (uint8_t)((ihex & 0x0000FF0000) >> 16);
							g = (uint8_t)((ihex & 0x000000FF00) >> 8);
							b = (uint8_t)ihex & 0xFF;
							float hsb[3];
							int tr, tg, tb; // tmp of 'int' type so can be passed as references to hsb2rgb
							rgb2hsb(r, g, b, hsb);
							hsb2rgb(hsb[0]*360.0f, hsb[1], 1.0f, tr, tg, tb, 255);
							r = tr;
							g = tg;
							b = tb;
							brightnessAdj = hsb[2];
							iswhite = (hsb[1] < (20.0 / 255.0)) ? ""true"" : ""false"";
							color = _tColor(r, g, b, cw, ww, ColorModeRGB);
							break;
						case 8: //RGB_WW
							r = (uint8_t)((ihex & 0x00FF000000) >> 24);
							g = (uint8_t)((ihex & 0x0000FF0000) >> 16);
							b = (uint8_t)((ihex & 0x000000FF00) >> 8);
							ww = (uint8_t)ihex & 0xFF;
							color = _tColor(r, g, b, cw, ww, ColorModeCustom);
							break;
						case 10: //RGB_CW_WW
							r = (uint8_t)((ihex & 0xFF00000000) >> 32);
							g = (uint8_t)((ihex & 0x00FF000000) >> 24);
							b = (uint8_t)((ihex & 0x0000FF0000) >> 16);
							cw = (uint8_t)((ihex & 0x000000FF00) >> 8);
							ww = (uint8_t)ihex & 0xFF;
							color = _tColor(r, g, b, cw, ww, ColorModeCustom);
							break;
					}
					if (iswhite == ""true"") color.mode = ColorModeWhite;
				}
				else if (!hue.empty())
				{
					int r, g, b;

					float iHue = float(atof(hue.c_str()));
					float iSat = 100.0f;
					if (!sat.empty()) iSat = float(atof(sat.c_str()));
					hsb2rgb(iHue, iSat/100.0f, 1.0f, r, g, b, 255);

					color = _tColor(r, g, b, 0, 0, ColorModeRGB);
					if (iswhite == ""true"") color.mode = ColorModeWhite;
				}

				if (color.mode == ColorModeNone)
				{
					return;
				}

				if (!brightness.empty())
					ival = atoi(brightness.c_str());
				ival = int(ival * brightnessAdj);
				ival = std::max(ival, 0);
				ival = std::min(ival, 100);

				_log.Log(LOG_STATUS, ""setcolbrightnessvalue: ID: %"" PRIx64 "", bri: %d, color: '%s'"", ID, ival, color.toString().c_str());
				m_mainworker.SwitchLight(ID, ""Set Color"", (unsigned char)ival, color, false, 0);

				root[""status""] = ""OK"";
				root[""title""] = ""SetColBrightnessValue"";
			}
			else if (cparam.find(""setkelvinlevel"") == 0)
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set Kelvin Level"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);

				std::string kelvin = request::findValue(&req, ""kelvin"");
				double ival = atof(kelvin.c_str());
				ival = std::max(ival, 0.0);
				ival = std::min(ival, 100.0);
				_tColor color = _tColor(round(ival*255.0f/100.0f), ColorModeTemp);
				_log.Log(LOG_STATUS, ""setkelvinlevel: t: %f, color: '%s'"", ival, color.toString().c_str());

				m_mainworker.SwitchLight(ID, ""Set Color"", -1, color, false, 0);
			}
			else if (cparam == ""brightnessup"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set brightness up!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Bright Up"", 0, NoColor, false, 0);
			}
			else if (cparam == ""brightnessdown"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set brightness down!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Bright Down"", 0, NoColor, false, 0);
			}
			else if (cparam == ""discomode"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set to last known disco mode!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Disco Mode"", 0, NoColor, false, 0);
			}
			else if (cparam.find(""discomodenum"") == 0 && cparam != ""discomode"" && cparam.size() == 13)
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set to disco mode!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				char szTmp[40];
				sprintf(szTmp, ""Disco Mode %s"", cparam.substr(12).c_str());
				m_mainworker.SwitchLight(ID, szTmp, 0, NoColor, false, 0);
			}
			else if (cparam == ""discoup"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set to next disco mode!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Disco Up"", 0, NoColor, false, 0);
			}
			else if (cparam == ""discodown"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set to previous disco mode!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Disco Down"", 0, NoColor, false, 0);
			}
			else if (cparam == ""speedup"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set disco speed up!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Speed Up"", 0, NoColor, false, 0);
			}
			else if (cparam == ""speeduplong"")
			{

				root[""status""] = ""OK"";
				root[""title""] = ""Set speed long!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Speed Up Long"", 0, NoColor, false, 0);
			}
			else if (cparam == ""speeddown"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set disco speed down!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Speed Down"", 0, NoColor, false, 0);
			}
			else if (cparam == ""speedmin"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set disco speed minimal!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Speed Minimal"", 0, NoColor, false, 0);
			}
			else if (cparam == ""speedmax"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set disco speed maximal!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Speed Maximal"", 0, NoColor, false, 0);
			}
			else if (cparam == ""warmer"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set Kelvin up!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Warmer"", 0, NoColor, false, 0);
			}
			else if (cparam == ""cooler"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set Kelvin down!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Cooler"", 0, NoColor, false, 0);
			}
			else if (cparam == ""fulllight"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set Full!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Set Full"", 0, NoColor, false, 0);
			}
			else if (cparam == ""nightlight"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set to nightlight!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Set Night"", 0, NoColor, false, 0);
			}
			else if (cparam == ""whitelight"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""Set to clear white!"";

				std::string idx = request::findValue(&req, ""idx"");

				if (idx.empty())
				{
					return;
				}

				uint64_t ID = std::strtoull(idx.c_str(), nullptr, 10);
				m_mainworker.SwitchLight(ID, ""Set White"", 0, NoColor, false, 0);
			}
			else if (cparam == ""getfloorplanimages"")
			{
				root[""status""] = ""OK"";
				root[""title""] = ""GetFloorplanImages"";

				bool bReturnUnused = atoi(request::findValue(&req, ""unused"").c_str()) != 0;

				if (!bReturnUnused)
					result = m_sql.safe_query(""SELECT ID, Name, ScaleFactor FROM Floorplans ORDER BY [Name]"");
				else
					result = m_sql.safe_query(""SELECT ID, Name, ScaleFactor FROM Floorplans WHERE ID NOT IN(SELECT FloorplanID FROM Plans)"");
				if (!result.empty())
				{
					int ii = 0;
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						root[""result""][ii][""idx""] = sd[0];
						root[""result""][ii][""name""] = sd[1];
						root[""result""][ii][""scalefactor""] = sd[2];
						ii++;
					}
				}
			}
			else if (cparam == ""updatefloorplan"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				std::string name = request::findValue(&req, ""name"");
				std::string scalefactor = request::findValue(&req, ""scalefactor"");
				if (
					(name.empty())
					||(scalefactor.empty())
					)
					return;

				root[""status""] = ""OK"";
				root[""title""] = ""UpdateFloorplan"";

				m_sql.safe_query(
					""UPDATE Floorplans SET Name='%q',ScaleFactor='%q' WHERE (ID == '%q')"",
					name.c_str(),
					scalefactor.c_str(),
					idx.c_str()
				);
			}
			else if (cparam == ""deletefloorplan"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteFloorplan"";
				m_sql.safe_query(""UPDATE DeviceToPlansMap SET XOffset=0,YOffset=0 WHERE (PlanID IN (SELECT ID from Plans WHERE (FloorplanID == '%q')))"", idx.c_str());
				m_sql.safe_query(""UPDATE Plans SET FloorplanID=0,Area='' WHERE (FloorplanID == '%q')"", idx.c_str());
				m_sql.safe_query(""DELETE FROM Floorplans WHERE (ID == '%q')"", idx.c_str());
			}
			else if (cparam == ""changefloorplanorder"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				std::string sway = request::findValue(&req, ""way"");
				if (sway.empty())
					return;
				bool bGoUp = (sway == ""0"");

				std::string aOrder, oID, oOrder;

				result = m_sql.safe_query(""SELECT [Order] FROM Floorplans WHERE (ID=='%q')"",
					idx.c_str());
				if (result.empty())
					return;
				aOrder = result[0][0];

				if (!bGoUp)
				{
					result = m_sql.safe_query(""SELECT ID, [Order] FROM Floorplans WHERE ([Order]>'%q') ORDER BY [Order] ASC"",
						aOrder.c_str());
					if (result.empty())
						return;
					oID = result[0][0];
					oOrder = result[0][1];
				}
				else
				{
					result = m_sql.safe_query(""SELECT ID, [Order] FROM Floorplans WHERE ([Order]<'%q') ORDER BY [Order] DESC"",
						aOrder.c_str());
					if (result.empty())
						return;
					oID = result[0][0];
					oOrder = result[0][1];
				}
				root[""status""] = ""OK"";
				root[""title""] = ""ChangeFloorPlanOrder"";

				m_sql.safe_query(""UPDATE Floorplans SET [Order] = '%q' WHERE (ID='%q')"",
					oOrder.c_str(), idx.c_str());
				m_sql.safe_query(""UPDATE Floorplans SET [Order] = '%q' WHERE (ID='%q')"",
					aOrder.c_str(), oID.c_str());
			}
			else if (cparam == ""getunusedfloorplanplans"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				root[""status""] = ""OK"";
				root[""title""] = ""GetUnusedFloorplanPlans"";
				int ii = 0;

				result = m_sql.safe_query(""SELECT ID, Name FROM Plans WHERE (FloorplanID==0) ORDER BY Name"");
				if (!result.empty())
				{
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						root[""result""][ii][""type""] = 0;
						root[""result""][ii][""idx""] = sd[0];
						root[""result""][ii][""Name""] = sd[1];
						ii++;
					}
				}
			}
			else if (cparam == ""getfloorplanplans"")
			{
				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""GetFloorplanPlans"";
				int ii = 0;
				result = m_sql.safe_query(""SELECT ID, Name, Area FROM Plans WHERE (FloorplanID=='%q') ORDER BY Name"",
					idx.c_str());
				if (!result.empty())
				{
					for (const auto & itt : result)
					{
						std::vector<std::string> sd = itt;

						root[""result""][ii][""idx""] = sd[0];
						root[""result""][ii][""Name""] = sd[1];
						root[""result""][ii][""Area""] = sd[2];
						ii++;
					}
				}
			}
			else if (cparam == ""addfloorplanplan"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				std::string planidx = request::findValue(&req, ""planidx"");
				if (
					(idx.empty()) ||
					(planidx.empty())
					)
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""AddFloorplanPlan"";

				m_sql.safe_query(
					""UPDATE Plans SET FloorplanID='%q' WHERE (ID == '%q')"",
					idx.c_str(),
					planidx.c_str()
				);
				_log.Log(LOG_STATUS, ""(Floorplan) Plan '%s' added to floorplan '%s'."", planidx.c_str(), idx.c_str());
			}
			else if (cparam == ""updatefloorplanplan"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string planidx = request::findValue(&req, ""planidx"");
				std::string planarea = request::findValue(&req, ""area"");
				if (planidx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""UpdateFloorplanPlan"";

				m_sql.safe_query(
					""UPDATE Plans SET Area='%q' WHERE (ID == '%q')"",
					planarea.c_str(),
					planidx.c_str()
				);
				_log.Log(LOG_STATUS, ""(Floorplan) Plan '%s' floor area updated to '%s'."", planidx.c_str(), planarea.c_str());
			}
			else if (cparam == ""deletefloorplanplan"")
			{
				if (session.rights < 2)
				{
					session.reply_status = reply::forbidden;
					return; //Only admin user allowed
				}

				std::string idx = request::findValue(&req, ""idx"");
				if (idx.empty())
					return;
				root[""status""] = ""OK"";
				root[""title""] = ""DeleteFloorplanPlan"";
				m_sql.safe_query(
					""UPDATE DeviceToPlansMap SET XOffset=0,YOffset=0 WHERE (PlanID == '%q')"",
					idx.c_str()
				);
				_log.Log(LOG_STATUS, ""(Floorplan) Device coordinates reset for plan '%s'."", idx.c_str());
				m_sql.safe_query(
					""UPDATE Plans SET FloorplanID=0,Area='' WHERE (ID == '%q')"",
					idx.c_str()
				);
				_log.Log(LOG_STATUS, ""(Floorplan) Plan '%s' floorplan data reset."", idx.c_str());
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,80820818234852330464584551925820109532,,
"		void CWebServer::HandleRType(const std::string &rtype, WebEmSession & session, const request& req, Json::Value &root)
		{
			std::map < std::string, webserver_response_function >::iterator pf = m_webrtypes.find(rtype);
			if (pf != m_webrtypes.end())
			{
				pf->second(session, req, root);
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,257629978861377183942862833278154368469,,
"		bool CWebServer::IsIdxForUser(const WebEmSession *pSession, const int Idx)
		{
			if (pSession->rights == 2)
				return true;
			if (pSession->rights == 0)
				return false; //viewer
			int iUser = FindUser(pSession->username.c_str());
			if ((iUser < 0) || (iUser >= (int)m_users.size()))
				return false;

			if (m_users[iUser].TotSensors == 0)
				return true; // all sensors

			std::vector<std::vector<std::string> > result = m_sql.safe_query(""SELECT DeviceRowID FROM SharedDevices WHERE (SharedUserID == '%d') AND (DeviceRowID == '%d')"", m_users[iUser].ID, Idx);
			return (!result.empty());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,44397944324391302076880343812691700164,,
"		void CWebServer::Post_UploadCustomIcon(WebEmSession & session, const request& req, reply & rep)
		{
			Json::Value root;
			root[""title""] = ""UploadCustomIcon"";
			root[""status""] = ""ERROR"";
			root[""error""] = ""Invalid"";
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			std::string zipfile = request::findValue(&req, ""file"");
			if (zipfile != """")
			{
				std::string ErrorMessage;
				bool bOK = m_sql.InsertCustomIconFromZip(zipfile, ErrorMessage);
				if (bOK)
				{
					root[""status""] = ""OK"";
				}
				else
				{
					root[""status""] = ""ERROR"";
					root[""error""] = ErrorMessage;
				}
			}
			std::string jcallback = request::findValue(&req, ""jsoncallback"");
			if (jcallback.size() == 0) {
				reply::set_content(&rep, root.toStyledString());
				return;
			}
			reply::set_content(&rep, ""var data="" + root.toStyledString() + '\n' + jcallback + ""(data);"");
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,186499874778944387670712017573105637970,,
"		void CWebServer::RType_AddScene(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string name = request::findValue(&req, ""name"");
			if (name.empty())
			{
				root[""status""] = ""ERR"";
				root[""message""] = ""No Scene Name specified!"";
				return;
			}
			std::string stype = request::findValue(&req, ""scenetype"");
			if (stype.empty())
			{
				root[""status""] = ""ERR"";
				root[""message""] = ""No Scene Type specified!"";
				return;
			}
			if (m_sql.DoesSceneByNameExits(name) == true)
			{
				root[""status""] = ""ERR"";
				root[""message""] = ""A Scene with this Name already Exits!"";
				return;
			}
			root[""status""] = ""OK"";
			root[""title""] = ""AddScene"";
			m_sql.safe_query(
				""INSERT INTO Scenes (Name,SceneType) VALUES ('%q',%d)"",
				name.c_str(),
				atoi(stype.c_str())
			);
			if (m_sql.m_bEnableEventSystem)
			{
				m_mainworker.m_eventsystem.GetCurrentScenesGroups();
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,310134352129233419667774534968467695432,,
"		void CWebServer::RType_CustomLightIcons(WebEmSession & session, const request& req, Json::Value &root)
		{
			int ii = 0;

			std::vector<_tCustomIcon> temp_custom_light_icons = m_custom_light_icons;
			std::sort(temp_custom_light_icons.begin(), temp_custom_light_icons.end(), compareIconsByName);

			for (const auto & itt : temp_custom_light_icons)
			{
				root[""result""][ii][""idx""] = itt.idx;
				root[""result""][ii][""imageSrc""] = itt.RootFile;
				root[""result""][ii][""text""] = itt.Title;
				root[""result""][ii][""description""] = itt.Description;
				ii++;
			}
			root[""status""] = ""OK"";
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,288532350834900647257887687345469644936,,
"		void CWebServer::RType_DeleteDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""DeleteDevice"";
			m_sql.DeleteDevices(idx);
			m_mainworker.m_scheduler.ReloadSchedules();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,56731217291006082288703007915721614358,,
"		void CWebServer::RType_DeleteScene(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""DeleteScene"";
			m_sql.safe_query(""DELETE FROM Scenes WHERE (ID == '%q')"", idx.c_str());
			m_sql.safe_query(""DELETE FROM SceneDevices WHERE (SceneRowID == '%q')"", idx.c_str());
			m_sql.safe_query(""DELETE FROM SceneTimers WHERE (SceneRowID == '%q')"", idx.c_str());
			m_sql.safe_query(""DELETE FROM SceneLog WHERE (SceneRowID=='%q')"", idx.c_str());
			uint64_t ullidx = std::strtoull(idx.c_str(), nullptr, 10);
			m_mainworker.m_eventsystem.RemoveSingleState(ullidx, m_mainworker.m_eventsystem.REASON_SCENEGROUP);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,291998189062317506829454386224401074442,,
"		void CWebServer::RType_Devices(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string rfilter = request::findValue(&req, ""filter"");
			std::string order = request::findValue(&req, ""order"");
			std::string rused = request::findValue(&req, ""used"");
			std::string rid = request::findValue(&req, ""rid"");
			std::string planid = request::findValue(&req, ""plan"");
			std::string floorid = request::findValue(&req, ""floor"");
			std::string sDisplayHidden = request::findValue(&req, ""displayhidden"");
			std::string sFetchFavorites = request::findValue(&req, ""favorite"");
			std::string sDisplayDisabled = request::findValue(&req, ""displaydisabled"");
			bool bDisplayHidden = (sDisplayHidden == ""1"");
			bool bFetchFavorites = (sFetchFavorites == ""1"");

			int HideDisabledHardwareSensors = 0;
			m_sql.GetPreferencesVar(""HideDisabledHardwareSensors"", HideDisabledHardwareSensors);
			bool bDisabledDisabled = (HideDisabledHardwareSensors == 0);
			if (sDisplayDisabled == ""1"")
				bDisabledDisabled = true;

			std::string sLastUpdate = request::findValue(&req, ""lastupdate"");
			std::string hwidx = request::findValue(&req, ""hwidx""); // OTO

			time_t LastUpdate = 0;
			if (sLastUpdate != """")
			{
				std::stringstream sstr;
				sstr << sLastUpdate;
				sstr >> LastUpdate;
			}

			root[""status""] = ""OK"";
			root[""title""] = ""Devices"";
			root[""app_version""] = szAppVersion;
			GetJSonDevices(root, rused, rfilter, order, rid, planid, floorid, bDisplayHidden, bDisabledDisabled, bFetchFavorites, LastUpdate, session.username, hwidx);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,39236168244159562654657499435298020863,,
"		void CWebServer::RType_FloorPlans(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""Floorplans"";

			std::vector<std::vector<std::string> > result, result2, result3;

			result = m_sql.safe_query(""SELECT Key, nValue, sValue FROM Preferences WHERE Key LIKE 'Floorplan%%'"");
			if (result.empty())
				return;

			for (const auto & itt : result)
			{
				std::vector<std::string> sd = itt;
				std::string Key = sd[0];
				int nValue = atoi(sd[1].c_str());
				std::string sValue = sd[2];

				if (Key == ""FloorplanPopupDelay"")
				{
					root[""PopupDelay""] = nValue;
				}
				if (Key == ""FloorplanFullscreenMode"")
				{
					root[""FullscreenMode""] = nValue;
				}
				if (Key == ""FloorplanAnimateZoom"")
				{
					root[""AnimateZoom""] = nValue;
				}
				if (Key == ""FloorplanShowSensorValues"")
				{
					root[""ShowSensorValues""] = nValue;
				}
				if (Key == ""FloorplanShowSwitchValues"")
				{
					root[""ShowSwitchValues""] = nValue;
				}
				if (Key == ""FloorplanShowSceneNames"")
				{
					root[""ShowSceneNames""] = nValue;
				}
				if (Key == ""FloorplanRoomColour"")
				{
					root[""RoomColour""] = sValue;
				}
				if (Key == ""FloorplanActiveOpacity"")
				{
					root[""ActiveRoomOpacity""] = nValue;
				}
				if (Key == ""FloorplanInactiveOpacity"")
				{
					root[""InactiveRoomOpacity""] = nValue;
				}
			}

			result2 = m_sql.safe_query(""SELECT ID, Name, ScaleFactor, [Order] FROM Floorplans ORDER BY [Order]"");
			if (!result2.empty())
			{
				int ii = 0;
				for (const auto & itt : result2)
				{
					std::vector<std::string> sd = itt;

					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Name""] = sd[1];
					std::string ImageURL = ""images/floorplans/plan?idx="" + sd[0];
					root[""result""][ii][""Image""] = ImageURL;
					root[""result""][ii][""ScaleFactor""] = sd[2];
					root[""result""][ii][""Order""] = sd[3];

					unsigned int totPlans = 0;

					result3 = m_sql.safe_query(""SELECT COUNT(*) FROM Plans WHERE (FloorplanID=='%q')"", sd[0].c_str());
					if (!result3.empty())
					{
						totPlans = (unsigned int)atoi(result3[0][0].c_str());
					}
					root[""result""][ii][""Plans""] = totPlans;

					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,237104336567195019962848180350539800839,,
"		void CWebServer::RType_GetSharedUserDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""GetSharedUserDevices"";

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT DeviceRowID FROM SharedDevices WHERE (SharedUserID == '%q')"", idx.c_str());
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;
					root[""result""][ii][""DeviceRowIdx""] = sd[0];
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,277913983503501352768664607368111180813,,
"		void CWebServer::RType_GetTransfers(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetTransfers"";

			uint64_t idx = 0;
			if (request::findValue(&req, ""idx"") != """")
			{
				idx = std::strtoull(request::findValue(&req, ""idx"").c_str(), nullptr, 10);
			}

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT Type, SubType FROM DeviceStatus WHERE (ID==%"" PRIu64 "")"",
				idx);
			if (!result.empty())
			{
				int dType = atoi(result[0][0].c_str());
				if (
					(dType == pTypeTEMP) ||
					(dType == pTypeTEMP_HUM)
					)
				{
					result = m_sql.safe_query(
						""SELECT ID, Name FROM DeviceStatus WHERE (Type=='%q') AND (ID!=%"" PRIu64 "")"",
						result[0][0].c_str(), idx);
				}
				else
				{
					result = m_sql.safe_query(
						""SELECT ID, Name FROM DeviceStatus WHERE (Type=='%q') AND (SubType=='%q') AND (ID!=%"" PRIu64 "")"",
						result[0][0].c_str(), result[0][1].c_str(), idx);
				}

				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Name""] = sd[1];
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,82295156583338969388894608145094459541,,
"		void CWebServer::RType_HandleGraph(WebEmSession & session, const request& req, Json::Value &root)
		{
			uint64_t idx = 0;
			if (request::findValue(&req, ""idx"") != """")
			{
				idx = std::strtoull(request::findValue(&req, ""idx"").c_str(), nullptr, 10);
			}

			std::vector<std::vector<std::string> > result;
			char szTmp[300];

			std::string sensor = request::findValue(&req, ""sensor"");
			if (sensor == """")
				return;
			std::string srange = request::findValue(&req, ""range"");
			if (srange == """")
				return;

			time_t now = mytime(NULL);
			struct tm tm1;
			localtime_r(&now, &tm1);

			result = m_sql.safe_query(""SELECT Type, SubType, SwitchType, AddjValue, AddjMulti, AddjValue2, Options FROM DeviceStatus WHERE (ID == %"" PRIu64 "")"",
				idx);
			if (result.empty())
				return;

			unsigned char dType = atoi(result[0][0].c_str());
			unsigned char dSubType = atoi(result[0][1].c_str());
			_eMeterType metertype = (_eMeterType)atoi(result[0][2].c_str());
			if (
				(dType == pTypeP1Power) ||
				(dType == pTypeENERGY) ||
				(dType == pTypePOWER) ||
				(dType == pTypeCURRENTENERGY) ||
				((dType == pTypeGeneral) && (dSubType == sTypeKwh))
				)
			{
				metertype = MTYPE_ENERGY;
			}
			else if (dType == pTypeP1Gas)
				metertype = MTYPE_GAS;
			else if ((dType == pTypeRego6XXValue) && (dSubType == sTypeRego6XXCounter))
				metertype = MTYPE_COUNTER;

			bool bIsManagedCounter = (dType == pTypeGeneral) && (dSubType == sTypeManagedCounter);

			double AddjValue = atof(result[0][3].c_str());
			double AddjMulti = atof(result[0][4].c_str());
			double AddjValue2 = atof(result[0][5].c_str());
			std::string sOptions = result[0][6].c_str();
			std::map<std::string, std::string> options = m_sql.BuildDeviceOptions(sOptions);

			float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

			std::string dbasetable = """";
			if (srange == ""day"") {
				if (sensor == ""temp"")
					dbasetable = ""Temperature"";
				else if (sensor == ""rain"")
					dbasetable = ""Rain"";
				else if (sensor == ""Percentage"")
					dbasetable = ""Percentage"";
				else if (sensor == ""fan"")
					dbasetable = ""Fan"";
				else if (sensor == ""counter"")
				{
					if ((dType == pTypeP1Power) || (dType == pTypeCURRENT) || (dType == pTypeCURRENTENERGY))
					{
						dbasetable = ""MultiMeter"";
					}
					else
					{
						dbasetable = ""Meter"";
					}
				}
				else if ((sensor == ""wind"") || (sensor == ""winddir""))
					dbasetable = ""Wind"";
				else if (sensor == ""uv"")
					dbasetable = ""UV"";
				else
					return;
			}
			else
			{
				if (sensor == ""temp"")
					dbasetable = ""Temperature_Calendar"";
				else if (sensor == ""rain"")
					dbasetable = ""Rain_Calendar"";
				else if (sensor == ""Percentage"")
					dbasetable = ""Percentage_Calendar"";
				else if (sensor == ""fan"")
					dbasetable = ""Fan_Calendar"";
				else if (sensor == ""counter"")
				{
					if (
						(dType == pTypeP1Power) ||
						(dType == pTypeCURRENT) ||
						(dType == pTypeCURRENTENERGY) ||
						(dType == pTypeAirQuality) ||
						((dType == pTypeGeneral) && (dSubType == sTypeVisibility)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeDistance)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSolarRadiation)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSoilMoisture)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeLeafWetness)) ||
						((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorAD)) ||
						((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorVolt)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeCurrent)) ||
						((dType == pTypeGeneral) && (dSubType == sTypePressure)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSoundLevel)) ||
						(dType == pTypeLux) ||
						(dType == pTypeWEIGHT) ||
						(dType == pTypeUsage)
						)
						dbasetable = ""MultiMeter_Calendar"";
					else
						dbasetable = ""Meter_Calendar"";
				}
				else if ((sensor == ""wind"") || (sensor == ""winddir""))
					dbasetable = ""Wind_Calendar"";
				else if (sensor == ""uv"")
					dbasetable = ""UV_Calendar"";
				else
					return;
			}
			unsigned char tempsign = m_sql.m_tempsign[0];
			int iPrev;

			if (srange == ""day"")
			{
				if (sensor == ""temp"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Temperature, Chill, Humidity, Barometer, Date, SetPoint FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						int ii = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[4].substr(0, 16);
							if (
								(dType == pTypeRego6XXTemp) ||
								(dType == pTypeTEMP) ||
								(dType == pTypeTEMP_HUM) ||
								(dType == pTypeTEMP_HUM_BARO) ||
								(dType == pTypeTEMP_BARO) ||
								((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
								((dType == pTypeUV) && (dSubType == sTypeUV3)) ||
								(dType == pTypeThermostat1) ||
								(dType == pTypeRadiator1) ||
								((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp)) ||
								((dType == pTypeGeneral) && (dSubType == sTypeSystemTemp)) ||
								((dType == pTypeGeneral) && (dSubType == sTypeBaro)) ||
								((dType == pTypeThermostat) && (dSubType == sTypeThermSetpoint)) ||
								(dType == pTypeEvohomeZone) ||
								(dType == pTypeEvohomeWater)
								)
							{
								double tvalue = ConvertTemperature(atof(sd[0].c_str()), tempsign);
								root[""result""][ii][""te""] = tvalue;
							}
							if (
								((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
								((dType == pTypeWIND) && (dSubType == sTypeWINDNoTemp))
								)
							{
								double tvalue = ConvertTemperature(atof(sd[1].c_str()), tempsign);
								root[""result""][ii][""ch""] = tvalue;
							}
							if ((dType == pTypeHUM) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO))
							{
								root[""result""][ii][""hu""] = sd[2];
							}
							if (
								(dType == pTypeTEMP_HUM_BARO) ||
								(dType == pTypeTEMP_BARO) ||
								((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								)
							{
								if (dType == pTypeTEMP_HUM_BARO)
								{
									if (dSubType == sTypeTHBFloat)
									{
										sprintf(szTmp, ""%.1f"", atof(sd[3].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
									else
										root[""result""][ii][""ba""] = sd[3];
								}
								else if (dType == pTypeTEMP_BARO)
								{
									sprintf(szTmp, ""%.1f"", atof(sd[3].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
								else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								{
									sprintf(szTmp, ""%.1f"", atof(sd[3].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
							}
							if ((dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater))
							{
								double se = ConvertTemperature(atof(sd[5].c_str()), tempsign);
								root[""result""][ii][""se""] = se;
							}

							ii++;
						}
					}
				}
				else if (sensor == ""Percentage"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Percentage, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						int ii = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[1].substr(0, 16);
							root[""result""][ii][""v""] = sd[0];
							ii++;
						}
					}
				}
				else if (sensor == ""fan"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Speed, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						int ii = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[1].substr(0, 16);
							root[""result""][ii][""v""] = sd[0];
							ii++;
						}
					}
				}

				else if (sensor == ""counter"")
				{
					if (dType == pTypeP1Power)
					{
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value1, Value2, Value3, Value4, Value5, Value6, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							bool bHaveDeliverd = false;
							bool bHaveFirstValue = false;
							long long lastUsage1, lastUsage2, lastDeliv1, lastDeliv2;
							time_t lastTime = 0;

							long long firstUsage1, firstUsage2, firstDeliv1, firstDeliv2;

							int nMeterType = 0;
							m_sql.GetPreferencesVar(""SmartMeterType"", nMeterType);

							int lastDay = 0;

							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								if (nMeterType == 0)
								{
									long long actUsage1 = std::strtoll(sd[0].c_str(), nullptr, 10);
									long long actUsage2 = std::strtoll(sd[4].c_str(), nullptr, 10);
									long long actDeliv1 = std::strtoll(sd[1].c_str(), nullptr, 10);
									long long actDeliv2 = std::strtoll(sd[5].c_str(), nullptr, 10);
									actDeliv1 = (actDeliv1 < 10) ? 0 : actDeliv1;
									actDeliv2 = (actDeliv2 < 10) ? 0 : actDeliv2;

									std::string stime = sd[6];
									struct tm ntime;
									time_t atime;
									ParseSQLdatetime(atime, ntime, stime, -1);
									if (lastDay != ntime.tm_mday)
									{
										lastDay = ntime.tm_mday;
										firstUsage1 = actUsage1;
										firstUsage2 = actUsage2;
										firstDeliv1 = actDeliv1;
										firstDeliv2 = actDeliv2;
									}

									if (bHaveFirstValue)
									{
										long curUsage1 = (long)(actUsage1 - lastUsage1);
										long curUsage2 = (long)(actUsage2 - lastUsage2);
										long curDeliv1 = (long)(actDeliv1 - lastDeliv1);
										long curDeliv2 = (long)(actDeliv2 - lastDeliv2);

										if ((curUsage1 < 0) || (curUsage1 > 100000))
											curUsage1 = 0;
										if ((curUsage2 < 0) || (curUsage2 > 100000))
											curUsage2 = 0;
										if ((curDeliv1 < 0) || (curDeliv1 > 100000))
											curDeliv1 = 0;
										if ((curDeliv2 < 0) || (curDeliv2 > 100000))
											curDeliv2 = 0;

										float tdiff = static_cast<float>(difftime(atime, lastTime));
										if (tdiff == 0)
											tdiff = 1;
										float tlaps = 3600.0f / tdiff;
										curUsage1 *= int(tlaps);
										curUsage2 *= int(tlaps);
										curDeliv1 *= int(tlaps);
										curDeliv2 *= int(tlaps);

										root[""result""][ii][""d""] = sd[6].substr(0, 16);

										if ((curDeliv1 != 0) || (curDeliv2 != 0))
											bHaveDeliverd = true;

										sprintf(szTmp, ""%ld"", curUsage1);
										root[""result""][ii][""v""] = szTmp;
										sprintf(szTmp, ""%ld"", curUsage2);
										root[""result""][ii][""v2""] = szTmp;
										sprintf(szTmp, ""%ld"", curDeliv1);
										root[""result""][ii][""r1""] = szTmp;
										sprintf(szTmp, ""%ld"", curDeliv2);
										root[""result""][ii][""r2""] = szTmp;

										long pUsage1 = (long)(actUsage1 - firstUsage1);
										long pUsage2 = (long)(actUsage2 - firstUsage2);

										sprintf(szTmp, ""%ld"", pUsage1 + pUsage2);
										root[""result""][ii][""eu""] = szTmp;
										if (bHaveDeliverd)
										{
											long pDeliv1 = (long)(actDeliv1 - firstDeliv1);
											long pDeliv2 = (long)(actDeliv2 - firstDeliv2);
											sprintf(szTmp, ""%ld"", pDeliv1 + pDeliv2);
											root[""result""][ii][""eg""] = szTmp;
										}

										ii++;
									}
									else
									{
										bHaveFirstValue = true;
										if ((ntime.tm_hour != 0) && (ntime.tm_min != 0))
										{
											struct tm ltime;
											localtime_r(&atime, &tm1);
											getNoon(atime, ltime, ntime.tm_year + 1900, ntime.tm_mon + 1, ntime.tm_mday - 1); // We're only interested in finding the date
											int year = ltime.tm_year + 1900;
											int mon = ltime.tm_mon + 1;
											int day = ltime.tm_mday;
											sprintf(szTmp, ""%04d-%02d-%02d"", year, mon, day);
											std::vector<std::vector<std::string> > result2;
											result2 = m_sql.safe_query(
												""SELECT Counter1, Counter2, Counter3, Counter4 FROM Multimeter_Calendar WHERE (DeviceRowID==%"" PRIu64 "") AND (Date=='%q')"",
												idx, szTmp);
											if (!result2.empty())
											{
												std::vector<std::string> sd = result2[0];
												firstUsage1 = std::strtoll(sd[0].c_str(), nullptr, 10);
												firstDeliv1 = std::strtoll(sd[1].c_str(), nullptr, 10);
												firstUsage2 = std::strtoll(sd[2].c_str(), nullptr, 10);
												firstDeliv2 = std::strtoll(sd[3].c_str(), nullptr, 10);
												lastDay = ntime.tm_mday;
											}
										}

									}
									lastUsage1 = actUsage1;
									lastUsage2 = actUsage2;
									lastDeliv1 = actDeliv1;
									lastDeliv2 = actDeliv2;
									lastTime = atime;
								}
								else
								{
									root[""result""][ii][""d""] = sd[6].substr(0, 16);

									if (sd[3] != ""0"")
										bHaveDeliverd = true;
									root[""result""][ii][""v""] = sd[2];
									root[""result""][ii][""r1""] = sd[3];
									ii++;

								}
							}
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
					}
					else if (dType == pTypeAirQuality)
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								root[""result""][ii][""co2""] = sd[0];
								ii++;
							}
						}
					}
					else if ((dType == pTypeGeneral) && ((dSubType == sTypeSoilMoisture) || (dSubType == sTypeLeafWetness)))
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								root[""result""][ii][""v""] = sd[0];
								ii++;
							}
						}
					}
					else if (
						((dType == pTypeGeneral) && (dSubType == sTypeVisibility)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeDistance)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSolarRadiation)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeCurrent)) ||
						((dType == pTypeGeneral) && (dSubType == sTypePressure)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSoundLevel))
						)
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;
						float vdiv = 10.0f;
						if (
							((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
							((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
							)
						{
							vdiv = 1000.0f;
						}
						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								float fValue = float(atof(sd[0].c_str())) / vdiv;
								if (metertype == 1)
									fValue *= 0.6214f;
								if ((dType == pTypeGeneral) && (dSubType == sTypeVoltage))
									sprintf(szTmp, ""%.3f"", fValue);
								else if ((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
									sprintf(szTmp, ""%.3f"", fValue);
								else
									sprintf(szTmp, ""%.1f"", fValue);
								root[""result""][ii][""v""] = szTmp;
								ii++;
							}
						}
					}
					else if ((dType == pTypeRFXSensor) && ((dSubType == sTypeRFXSensorAD) || (dSubType == sTypeRFXSensorVolt)))
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								root[""result""][ii][""v""] = sd[0];
								ii++;
							}
						}
					}
					else if (dType == pTypeLux)
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								root[""result""][ii][""lux""] = sd[0];
								ii++;
							}
						}
					}
					else if (dType == pTypeWEIGHT)
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								sprintf(szTmp, ""%.1f"", m_sql.m_weightscale * atof(sd[0].c_str()) / 10.0f);
								root[""result""][ii][""v""] = szTmp;
								ii++;
							}
						}
					}
					else if (dType == pTypeUsage)
					{//day
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								root[""result""][ii][""u""] = atof(sd[0].c_str()) / 10.0f;
								ii++;
							}
						}
					}
					else if (dType == pTypeCURRENT)
					{
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						int displaytype = 0;
						int voltage = 230;
						m_sql.GetPreferencesVar(""CM113DisplayType"", displaytype);
						m_sql.GetPreferencesVar(""ElectricVoltage"", voltage);

						root[""displaytype""] = displaytype;

						result = m_sql.safe_query(""SELECT Value1, Value2, Value3, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							bool bHaveL1 = false;
							bool bHaveL2 = false;
							bool bHaveL3 = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[3].substr(0, 16);

								float fval1 = static_cast<float>(atof(sd[0].c_str()) / 10.0f);
								float fval2 = static_cast<float>(atof(sd[1].c_str()) / 10.0f);
								float fval3 = static_cast<float>(atof(sd[2].c_str()) / 10.0f);

								if (fval1 != 0)
									bHaveL1 = true;
								if (fval2 != 0)
									bHaveL2 = true;
								if (fval3 != 0)
									bHaveL3 = true;

								if (displaytype == 0)
								{
									sprintf(szTmp, ""%.1f"", fval1);
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval2);
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval3);
									root[""result""][ii][""v3""] = szTmp;
								}
								else
								{
									sprintf(szTmp, ""%d"", int(fval1*voltage));
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval2*voltage));
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval3*voltage));
									root[""result""][ii][""v3""] = szTmp;
								}
								ii++;
							}
							if (
								(!bHaveL1) &&
								(!bHaveL2) &&
								(!bHaveL3)
								) {
								root[""haveL1""] = true; //show at least something
							}
							else {
								if (bHaveL1)
									root[""haveL1""] = true;
								if (bHaveL2)
									root[""haveL2""] = true;
								if (bHaveL3)
									root[""haveL3""] = true;
							}
						}
					}
					else if (dType == pTypeCURRENTENERGY)
					{
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						int displaytype = 0;
						int voltage = 230;
						m_sql.GetPreferencesVar(""CM113DisplayType"", displaytype);
						m_sql.GetPreferencesVar(""ElectricVoltage"", voltage);

						root[""displaytype""] = displaytype;

						result = m_sql.safe_query(""SELECT Value1, Value2, Value3, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							int ii = 0;
							bool bHaveL1 = false;
							bool bHaveL2 = false;
							bool bHaveL3 = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[3].substr(0, 16);

								float fval1 = static_cast<float>(atof(sd[0].c_str()) / 10.0f);
								float fval2 = static_cast<float>(atof(sd[1].c_str()) / 10.0f);
								float fval3 = static_cast<float>(atof(sd[2].c_str()) / 10.0f);

								if (fval1 != 0)
									bHaveL1 = true;
								if (fval2 != 0)
									bHaveL2 = true;
								if (fval3 != 0)
									bHaveL3 = true;

								if (displaytype == 0)
								{
									sprintf(szTmp, ""%.1f"", fval1);
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval2);
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval3);
									root[""result""][ii][""v3""] = szTmp;
								}
								else
								{
									sprintf(szTmp, ""%d"", int(fval1*voltage));
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval2*voltage));
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval3*voltage));
									root[""result""][ii][""v3""] = szTmp;
								}
								ii++;
							}
							if (
								(!bHaveL1) &&
								(!bHaveL2) &&
								(!bHaveL3)
								) {
								root[""haveL1""] = true; //show at least something
							}
							else {
								if (bHaveL1)
									root[""haveL1""] = true;
								if (bHaveL2)
									root[""haveL2""] = true;
								if (bHaveL3)
									root[""haveL3""] = true;
							}
						}
					}
					else if ((dType == pTypeENERGY) || (dType == pTypePOWER) || (dType == pTypeYouLess) || ((dType == pTypeGeneral) && (dSubType == sTypeKwh)))
					{
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;
						root[""ValueQuantity""] = options[""ValueQuantity""];
						root[""ValueUnits""] = options[""ValueUnits""];

						bool bHaveUsage = true;
						result = m_sql.safe_query(""SELECT MIN([Usage]), MAX([Usage]) FROM %s WHERE (DeviceRowID==%"" PRIu64 "")"", dbasetable.c_str(), idx);
						if (!result.empty())
						{
							long long minValue = std::strtoll(result[0][0].c_str(), nullptr, 10);
							long long maxValue = std::strtoll(result[0][1].c_str(), nullptr, 10);
							if ((minValue == 0) && (maxValue == 0))
							{
								bHaveUsage = false;
							}
						}

						int ii = 0;
						result = m_sql.safe_query(""SELECT Value,[Usage], Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);

						int method = 0;
						std::string sMethod = request::findValue(&req, ""method"");
						if (sMethod.size() > 0)
							method = atoi(sMethod.c_str());
						if (bHaveUsage == false)
							method = 0;

						if ((dType == pTypeYouLess) && ((metertype == MTYPE_ENERGY) || (metertype == MTYPE_ENERGY_GENERATED)))
							method = 1;

						if (method != 0)
						{
							if ((dType == pTypeENERGY) || (dType == pTypePOWER))
								divider /= 100.0f;
						}
						root[""method""] = method;
						bool bHaveFirstValue = false;
						bool bHaveFirstRealValue = false;
						float FirstValue = 0;
						long long ulFirstRealValue = 0;
						long long ulFirstValue = 0;
						long long ulLastValue = 0;
						std::string LastDateTime = """";
						time_t lastTime = 0;

						if (!result.empty())
						{
							std::vector<std::vector<std::string> >::const_iterator itt;
							for (itt = result.begin(); itt!=result.end(); ++itt)
							{
								std::vector<std::string> sd = *itt;

								{
									std::string actDateTimeHour = sd[2].substr(0, 13);
									long long actValue = std::strtoll(sd[0].c_str(), nullptr, 10);

									if (actValue >= ulLastValue)
										ulLastValue = actValue;

									if (actDateTimeHour != LastDateTime || ((method == 1) && (itt + 1 == result.end())))
									{
										if (bHaveFirstValue)
										{
											root[""result""][ii][""d""] = LastDateTime + "":00"";

											long long ulTotalValue = ulLastValue - ulFirstValue;
											if (ulTotalValue == 0)
											{
												ulTotalValue = ulLastValue - ulFirstRealValue;
											}
											ulFirstRealValue = ulLastValue;
											float TotalValue = float(ulTotalValue);
											switch (metertype)
											{
											case MTYPE_ENERGY:
											case MTYPE_ENERGY_GENERATED:
												sprintf(szTmp, ""%.3f"", (TotalValue / divider)*1000.0f);	//from kWh -> Watt
												break;
											case MTYPE_GAS:
												sprintf(szTmp, ""%.3f"", TotalValue / divider);
												break;
											case MTYPE_WATER:
												sprintf(szTmp, ""%.3f"", TotalValue / divider);
												break;
											case MTYPE_COUNTER:
												sprintf(szTmp, ""%.1f"", TotalValue);
												break;
											default:
												strcpy(szTmp, ""0"");
												break;
											}
											root[""result""][ii][method == 1 ? ""eu"" : ""v""] = szTmp;
											ii++;
										}
										LastDateTime = actDateTimeHour;
										bHaveFirstValue = false;
									}
									if (!bHaveFirstValue)
									{
										ulFirstValue = ulLastValue;
										bHaveFirstValue = true;
									}
									if (!bHaveFirstRealValue)
									{
										bHaveFirstRealValue = true;
										ulFirstRealValue = ulLastValue;
									}
								}

								if (method == 1)
								{
									long long actValue = std::strtoll(sd[1].c_str(), nullptr, 10);

									root[""result""][ii][""d""] = sd[2].substr(0, 16);

									float TotalValue = float(actValue);
									if ((dType == pTypeGeneral) && (dSubType == sTypeKwh))
										TotalValue /= 10.0f;
									switch (metertype)
									{
									case MTYPE_ENERGY:
									case MTYPE_ENERGY_GENERATED:
										sprintf(szTmp, ""%.3f"", (TotalValue / divider)*1000.0f);	//from kWh -> Watt
										break;
									case MTYPE_GAS:
										sprintf(szTmp, ""%.2f"", TotalValue / divider);
										break;
									case MTYPE_WATER:
										sprintf(szTmp, ""%.3f"", TotalValue / divider);
										break;
									case MTYPE_COUNTER:
										sprintf(szTmp, ""%.1f"", TotalValue);
										break;
									default:
										strcpy(szTmp, ""0"");
										break;
									}
									root[""result""][ii][""v""] = szTmp;
									ii++;
								}
							}
						}
					}
					else
					{
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;
						root[""ValueQuantity""] = options[""ValueQuantity""];
						root[""ValueUnits""] = options[""ValueUnits""];

						int ii = 0;

						bool bHaveFirstValue = false;
						bool bHaveFirstRealValue = false;
						float FirstValue = 0;
						unsigned long long ulFirstRealValue = 0;
						unsigned long long ulFirstValue = 0;
						unsigned long long ulLastValue = 0;

						std::string LastDateTime = """";
						time_t lastTime = 0;

						if (bIsManagedCounter) {
							result = m_sql.safe_query(""SELECT Usage, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
							bHaveFirstValue = true;
							bHaveFirstRealValue = true;
						}
						else {
							result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
						}

						int method = 0;
						std::string sMethod = request::findValue(&req, ""method"");
						if (sMethod.size() > 0)
							method = atoi(sMethod.c_str());

						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								if (method == 0)
								{

									unsigned long long actValue = std::strtoull(sd[0].c_str(), nullptr, 10);

									std::string actDateTimeHour = sd[1].substr(0, 13);
									if (actDateTimeHour != LastDateTime)
									{
										if (bHaveFirstValue)
										{
											struct tm ntime;
											time_t atime;
											if (actDateTimeHour.size() == 10)
												actDateTimeHour += "" 00"";
											constructTime(atime, ntime,
												atoi(actDateTimeHour.substr(0, 4).c_str()),
												atoi(actDateTimeHour.substr(5, 2).c_str()),
												atoi(actDateTimeHour.substr(8, 2).c_str()),
												atoi(actDateTimeHour.substr(11, 2).c_str()) - 1,
												0, 0, -1);

											char szTime[50];
											sprintf(szTime, ""%04d-%02d-%02d %02d:00"", ntime.tm_year + 1900, ntime.tm_mon + 1, ntime.tm_mday, ntime.tm_hour);
											root[""result""][ii][""d""] = szTime;

											
											float TotalValue = (actValue >= ulFirstValue) ? float(actValue - ulFirstValue) : actValue;

											{
												switch (metertype)
												{
												case MTYPE_ENERGY:
												case MTYPE_ENERGY_GENERATED:
													sprintf(szTmp, ""%.3f"", (TotalValue / divider)*1000.0f);	//from kWh -> Watt
													break;
												case MTYPE_GAS:
													sprintf(szTmp, ""%.3f"", TotalValue / divider);
													break;
												case MTYPE_WATER:
													sprintf(szTmp, ""%.3f"", TotalValue / divider);
													break;
												case MTYPE_COUNTER:
													sprintf(szTmp, ""%.1f"", TotalValue);
													break;
												default:
													strcpy(szTmp, ""0"");
													break;
												}
												root[""result""][ii][""v""] = szTmp;
												ii++;
											}
										}
										if (!bIsManagedCounter) {
											ulFirstValue = actValue;
										}
										LastDateTime = actDateTimeHour;
									}

									if (!bHaveFirstValue)
									{
										ulFirstValue = actValue;
										bHaveFirstValue = true;
									}
									ulLastValue = actValue;
								}
								else
								{
									unsigned long long actValue = std::strtoull(sd[0].c_str(), nullptr, 10);

									std::string stime = sd[1];
									struct tm ntime;
									time_t atime;
									ParseSQLdatetime(atime, ntime, stime, -1);
									if (bHaveFirstRealValue)
									{
										long long curValue = actValue - ulLastValue;

										float tdiff = static_cast<float>(difftime(atime, lastTime));
										if (tdiff == 0)
											tdiff = 1;
										float tlaps = 3600.0f / tdiff;
										curValue *= int(tlaps);

										root[""result""][ii][""d""] = sd[1].substr(0, 16);

										float TotalValue = float(curValue);
										{
											switch (metertype)
											{
											case MTYPE_ENERGY:
											case MTYPE_ENERGY_GENERATED:
												sprintf(szTmp, ""%.3f"", (TotalValue / divider)*1000.0f);	//from kWh -> Watt
												break;
											case MTYPE_GAS:
												sprintf(szTmp, ""%.2f"", TotalValue / divider);
												break;
											case MTYPE_WATER:
												sprintf(szTmp, ""%.3f"", TotalValue / divider);
												break;
											case MTYPE_COUNTER:
												sprintf(szTmp, ""%.1f"", TotalValue);
												break;
											default:
												strcpy(szTmp, ""0"");
												break;
											}
											root[""result""][ii][""v""] = szTmp;
											ii++;
										}

									}
									else
										bHaveFirstRealValue = true;
									if (!bIsManagedCounter) {
										ulLastValue = actValue;
									}
									lastTime = atime;
								}
							}
						}
						if ((!bIsManagedCounter) && (bHaveFirstValue) && (method == 0))
						{
							root[""result""][ii][""d""] = LastDateTime + "":00"";

							unsigned long long ulTotalValue = ulLastValue - ulFirstValue;

							float TotalValue = float(ulTotalValue);

							{
								switch (metertype)
								{
								case MTYPE_ENERGY:
								case MTYPE_ENERGY_GENERATED:
									sprintf(szTmp, ""%.3f"", (TotalValue / divider)*1000.0f);	//from kWh -> Watt
									break;
								case MTYPE_GAS:
									sprintf(szTmp, ""%.3f"", TotalValue / divider);
									break;
								case MTYPE_WATER:
									sprintf(szTmp, ""%.3f"", TotalValue / divider);
									break;
								case MTYPE_COUNTER:
									sprintf(szTmp, ""%.1f"", TotalValue);
									break;
								default:
									strcpy(szTmp, ""0"");
									break;
								}
								root[""result""][ii][""v""] = szTmp;
								ii++;
							}
						}
					}
				}
				else if (sensor == ""uv"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Level, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						int ii = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[1].substr(0, 16);
							root[""result""][ii][""uvi""] = sd[0];
							ii++;
						}
					}
				}
				else if (sensor == ""rain"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					int LastHour = -1;
					float LastTotalPreviousHour = -1;

					float LastValue = -1;
					std::string LastDate = """";

					result = m_sql.safe_query(""SELECT Total, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						int ii = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;
							float ActTotal = static_cast<float>(atof(sd[0].c_str()));
							int Hour = atoi(sd[1].substr(11, 2).c_str());
							if (Hour != LastHour)
							{
								if (LastHour != -1)
								{
									int NextCalculatedHour = (LastHour + 1) % 24;
									if (Hour != NextCalculatedHour)
									{
										root[""result""][ii][""d""] = LastDate;
										double mmval = ActTotal - LastValue;
										mmval *= AddjMulti;
										sprintf(szTmp, ""%.1f"", mmval);
										root[""result""][ii][""mm""] = szTmp;
										ii++;
									}
									else
									{
										root[""result""][ii][""d""] = sd[1].substr(0, 16);
										double mmval = ActTotal - LastTotalPreviousHour;
										mmval *= AddjMulti;
										sprintf(szTmp, ""%.1f"", mmval);
										root[""result""][ii][""mm""] = szTmp;
										ii++;
									}
								}
								LastHour = Hour;
								LastTotalPreviousHour = ActTotal;
							}
							LastValue = ActTotal;
							LastDate = sd[1];
						}
					}
				}
				else if (sensor == ""wind"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Direction, Speed, Gust, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						int ii = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[3].substr(0, 16);
							root[""result""][ii][""di""] = sd[0];

							int intSpeed = atoi(sd[1].c_str());
							int intGust = atoi(sd[2].c_str());
							if (m_sql.m_windunit != WINDUNIT_Beaufort)
							{
								sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
								root[""result""][ii][""sp""] = szTmp;
								sprintf(szTmp, ""%.1f"", float(intGust) * m_sql.m_windscale);
								root[""result""][ii][""gu""] = szTmp;
							}
							else
							{
								float windspeedms = float(intSpeed)*0.1f;
								float windgustms = float(intGust)*0.1f;
								sprintf(szTmp, ""%d"", MStoBeaufort(windspeedms));
								root[""result""][ii][""sp""] = szTmp;
								sprintf(szTmp, ""%d"", MStoBeaufort(windgustms));
								root[""result""][ii][""gu""] = szTmp;
							}
							ii++;
						}
					}
				}
				else if (sensor == ""winddir"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Direction, Speed, Gust FROM %s WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date ASC"", dbasetable.c_str(), idx);
					if (!result.empty())
					{
						std::map<int, int> _directions;
						int wdirtabletemp[17][8];
						std::string szLegendLabels[7];
						int ii = 0;

						int totalvalues = 0;
						int idir;
						for (idir = 0; idir < 360 + 1; idir++)
							_directions[idir] = 0;
						for (ii = 0; ii < 17; ii++)
						{
							for (int jj = 0; jj < 8; jj++)
							{
								wdirtabletemp[ii][jj] = 0;
							}
						}

						if (m_sql.m_windunit == WINDUNIT_MS)
						{
							szLegendLabels[0] = ""&lt; 0.5 "" + m_sql.m_windsign;
							szLegendLabels[1] = ""0.5-2 "" + m_sql.m_windsign;
							szLegendLabels[2] = ""2-4 "" + m_sql.m_windsign;
							szLegendLabels[3] = ""4-6 "" + m_sql.m_windsign;
							szLegendLabels[4] = ""6-8 "" + m_sql.m_windsign;
							szLegendLabels[5] = ""8-10 "" + m_sql.m_windsign;
							szLegendLabels[6] = ""&gt; 10"" + m_sql.m_windsign;
						}
						else if (m_sql.m_windunit == WINDUNIT_KMH)
						{
							szLegendLabels[0] = ""&lt; 2 "" + m_sql.m_windsign;
							szLegendLabels[1] = ""2-4 "" + m_sql.m_windsign;
							szLegendLabels[2] = ""4-6 "" + m_sql.m_windsign;
							szLegendLabels[3] = ""6-10 "" + m_sql.m_windsign;
							szLegendLabels[4] = ""10-20 "" + m_sql.m_windsign;
							szLegendLabels[5] = ""20-36 "" + m_sql.m_windsign;
							szLegendLabels[6] = ""&gt; 36"" + m_sql.m_windsign;
						}
						else if (m_sql.m_windunit == WINDUNIT_MPH)
						{
							szLegendLabels[0] = ""&lt; 3 "" + m_sql.m_windsign;
							szLegendLabels[1] = ""3-7 "" + m_sql.m_windsign;
							szLegendLabels[2] = ""7-12 "" + m_sql.m_windsign;
							szLegendLabels[3] = ""12-18 "" + m_sql.m_windsign;
							szLegendLabels[4] = ""18-24 "" + m_sql.m_windsign;
							szLegendLabels[5] = ""24-46 "" + m_sql.m_windsign;
							szLegendLabels[6] = ""&gt; 46"" + m_sql.m_windsign;
						}
						else if (m_sql.m_windunit == WINDUNIT_Knots)
						{
							szLegendLabels[0] = ""&lt; 3 "" + m_sql.m_windsign;
							szLegendLabels[1] = ""3-7 "" + m_sql.m_windsign;
							szLegendLabels[2] = ""7-17 "" + m_sql.m_windsign;
							szLegendLabels[3] = ""17-27 "" + m_sql.m_windsign;
							szLegendLabels[4] = ""27-34 "" + m_sql.m_windsign;
							szLegendLabels[5] = ""34-41 "" + m_sql.m_windsign;
							szLegendLabels[6] = ""&gt; 41"" + m_sql.m_windsign;
						}
						else if (m_sql.m_windunit == WINDUNIT_Beaufort)
						{
							szLegendLabels[0] = ""&lt; 2 "" + m_sql.m_windsign;
							szLegendLabels[1] = ""2-4 "" + m_sql.m_windsign;
							szLegendLabels[2] = ""4-6 "" + m_sql.m_windsign;
							szLegendLabels[3] = ""6-8 "" + m_sql.m_windsign;
							szLegendLabels[4] = ""8-10 "" + m_sql.m_windsign;
							szLegendLabels[5] = ""10-12 "" + m_sql.m_windsign;
							szLegendLabels[6] = ""&gt; 12"" + m_sql.m_windsign;
						}
						else {
							szLegendLabels[0] = ""&lt; 0.5 "" + m_sql.m_windsign;
							szLegendLabels[1] = ""0.5-2 "" + m_sql.m_windsign;
							szLegendLabels[2] = ""2-4 "" + m_sql.m_windsign;
							szLegendLabels[3] = ""4-6 "" + m_sql.m_windsign;
							szLegendLabels[4] = ""6-8 "" + m_sql.m_windsign;
							szLegendLabels[5] = ""8-10 "" + m_sql.m_windsign;
							szLegendLabels[6] = ""&gt; 10"" + m_sql.m_windsign;
						}


						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;
							float fdirection = static_cast<float>(atof(sd[0].c_str()));
							if (fdirection >= 360)
								fdirection = 0;
							int direction = int(fdirection);
							float speedOrg = static_cast<float>(atof(sd[1].c_str()));
							float gustOrg = static_cast<float>(atof(sd[2].c_str()));
							if ((gustOrg == 0) && (speedOrg != 0))
								gustOrg = speedOrg;
							if (gustOrg == 0)
								continue; //no direction if wind is still
							float speed = speedOrg * m_sql.m_windscale;
							float gust = gustOrg * m_sql.m_windscale;
							int bucket = int(fdirection / 22.5f);

							int speedpos = 0;

							if (m_sql.m_windunit == WINDUNIT_MS)
							{
								if (gust < 0.5f) speedpos = 0;
								else if (gust < 2.0f) speedpos = 1;
								else if (gust < 4.0f) speedpos = 2;
								else if (gust < 6.0f) speedpos = 3;
								else if (gust < 8.0f) speedpos = 4;
								else if (gust < 10.0f) speedpos = 5;
								else speedpos = 6;
							}
							else if (m_sql.m_windunit == WINDUNIT_KMH)
							{
								if (gust < 2.0f) speedpos = 0;
								else if (gust < 4.0f) speedpos = 1;
								else if (gust < 6.0f) speedpos = 2;
								else if (gust < 10.0f) speedpos = 3;
								else if (gust < 20.0f) speedpos = 4;
								else if (gust < 36.0f) speedpos = 5;
								else speedpos = 6;
							}
							else if (m_sql.m_windunit == WINDUNIT_MPH)
							{
								if (gust < 3.0f) speedpos = 0;
								else if (gust < 7.0f) speedpos = 1;
								else if (gust < 12.0f) speedpos = 2;
								else if (gust < 18.0f) speedpos = 3;
								else if (gust < 24.0f) speedpos = 4;
								else if (gust < 46.0f) speedpos = 5;
								else speedpos = 6;
							}
							else if (m_sql.m_windunit == WINDUNIT_Knots)
							{
								if (gust < 3.0f) speedpos = 0;
								else if (gust < 7.0f) speedpos = 1;
								else if (gust < 17.0f) speedpos = 2;
								else if (gust < 27.0f) speedpos = 3;
								else if (gust < 34.0f) speedpos = 4;
								else if (gust < 41.0f) speedpos = 5;
								else speedpos = 6;
							}
							else if (m_sql.m_windunit == WINDUNIT_Beaufort)
							{
								float gustms = gustOrg * 0.1f;
								int iBeaufort = MStoBeaufort(gustms);
								if (iBeaufort < 2) speedpos = 0;
								else if (iBeaufort < 4) speedpos = 1;
								else if (iBeaufort < 6) speedpos = 2;
								else if (iBeaufort < 8) speedpos = 3;
								else if (iBeaufort < 10) speedpos = 4;
								else if (iBeaufort < 12) speedpos = 5;
								else speedpos = 6;
							}
							else
							{
								if (gust < 0.5f) speedpos = 0;
								else if (gust < 2.0f) speedpos = 1;
								else if (gust < 4.0f) speedpos = 2;
								else if (gust < 6.0f) speedpos = 3;
								else if (gust < 8.0f) speedpos = 4;
								else if (gust < 10.0f) speedpos = 5;
								else speedpos = 6;
							}
							wdirtabletemp[bucket][speedpos]++;
							_directions[direction]++;
							totalvalues++;
						}

						for (int jj = 0; jj < 7; jj++)
						{
							root[""result_speed""][jj][""label""] = szLegendLabels[jj];

							for (ii = 0; ii < 16; ii++)
							{
								float svalue = 0;
								if (totalvalues > 0)
								{
									svalue = (100.0f / totalvalues)*wdirtabletemp[ii][jj];
								}
								sprintf(szTmp, ""%.2f"", svalue);
								root[""result_speed""][jj][""sp""][ii] = szTmp;
							}
						}
						ii = 0;
						for (idir = 0; idir < 360 + 1; idir++)
						{
							if (_directions[idir] != 0)
							{
								root[""result""][ii][""dig""] = idir;
								float percentage = 0;
								if (totalvalues > 0)
								{
									percentage = (float(100.0 / float(totalvalues))*float(_directions[idir]));
								}
								sprintf(szTmp, ""%.2f"", percentage);
								root[""result""][ii][""div""] = szTmp;
								ii++;
							}
						}
					}
				}

			}//day
			else if (srange == ""week"")
			{
				if (sensor == ""rain"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					char szDateStart[40];
					char szDateEnd[40];
					sprintf(szDateEnd, ""%04d-%02d-%02d"", tm1.tm_year + 1900, tm1.tm_mon + 1, tm1.tm_mday);

					time_t weekbefore;
					struct tm tm2;
					getNoon(weekbefore, tm2, tm1.tm_year + 1900, tm1.tm_mon + 1, tm1.tm_mday - 7); // We only want the date
					sprintf(szDateStart, ""%04d-%02d-%02d"", tm2.tm_year + 1900, tm2.tm_mon + 1, tm2.tm_mday);

					result = m_sql.safe_query(""SELECT Total, Rate, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[2].substr(0, 16);
							double mmval = atof(sd[0].c_str());
							mmval *= AddjMulti;
							sprintf(szTmp, ""%.1f"", mmval);
							root[""result""][ii][""mm""] = szTmp;
							ii++;
						}
					}
					if (dSubType != sTypeRAINWU)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Total), MAX(Total), MAX(Rate) FROM Rain WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
					}
					else
					{
						result = m_sql.safe_query(
							""SELECT Total, Total, Rate FROM Rain WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q') ORDER BY ROWID DESC LIMIT 1"",
							idx, szDateEnd);
					}
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						float total_min = static_cast<float>(atof(sd[0].c_str()));
						float total_max = static_cast<float>(atof(sd[1].c_str()));
						int rate = atoi(sd[2].c_str());

						double total_real = 0;
						if (dSubType != sTypeRAINWU)
						{
							total_real = total_max - total_min;
						}
						else
						{
							total_real = total_max;
						}
						total_real *= AddjMulti;
						sprintf(szTmp, ""%.1f"", total_real);
						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""mm""] = szTmp;
						ii++;
					}
				}
				else if (sensor == ""counter"")
				{
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;
					root[""ValueQuantity""] = options[""ValueQuantity""];
					root[""ValueUnits""] = options[""ValueUnits""];

					char szDateStart[40];
					char szDateEnd[40];
					sprintf(szDateEnd, ""%04d-%02d-%02d"", tm1.tm_year + 1900, tm1.tm_mon + 1, tm1.tm_mday);

					time_t weekbefore;
					struct tm tm2;
					getNoon(weekbefore, tm2, tm1.tm_year + 1900, tm1.tm_mon + 1, tm1.tm_mday - 7); // We only want the date
					sprintf(szDateStart, ""%04d-%02d-%02d"", tm2.tm_year + 1900, tm2.tm_mon + 1, tm2.tm_mday);

					int ii = 0;
					if (dType == pTypeP1Power)
					{
						result = m_sql.safe_query(""SELECT Value1,Value2,Value5,Value6,Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							bool bHaveDeliverd = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;
								root[""result""][ii][""d""] = sd[4].substr(0, 16);
								std::string szValueUsage1 = sd[0];
								std::string szValueDeliv1 = sd[1];
								std::string szValueUsage2 = sd[2];
								std::string szValueDeliv2 = sd[3];

								float fUsage1 = (float)(atof(szValueUsage1.c_str()));
								float fUsage2 = (float)(atof(szValueUsage2.c_str()));
								float fDeliv1 = (float)(atof(szValueDeliv1.c_str()));
								float fDeliv2 = (float)(atof(szValueDeliv2.c_str()));

								fDeliv1 = (fDeliv1 < 10) ? 0 : fDeliv1;
								fDeliv2 = (fDeliv2 < 10) ? 0 : fDeliv2;

								if ((fDeliv1 != 0) || (fDeliv2 != 0))
									bHaveDeliverd = true;
								sprintf(szTmp, ""%.3f"", fUsage1 / divider);
								root[""result""][ii][""v""] = szTmp;
								sprintf(szTmp, ""%.3f"", fUsage2 / divider);
								root[""result""][ii][""v2""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv1 / divider);
								root[""result""][ii][""r1""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv2 / divider);
								root[""result""][ii][""r2""] = szTmp;
								ii++;
							}
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
					}
					else
					{
						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								std::string szValue = sd[0];
								switch (metertype)
								{
								case MTYPE_ENERGY:
								case MTYPE_ENERGY_GENERATED:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									szValue = szTmp;
									break;
								case MTYPE_GAS:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									szValue = szTmp;
									break;
								case MTYPE_WATER:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									szValue = szTmp;
									break;
								case MTYPE_COUNTER:
									break;
								default:
									szValue = ""0"";
									break;
								}
								root[""result""][ii][""v""] = szValue;
								ii++;
							}
						}
					}
					if (dType == pTypeP1Power)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value1), MAX(Value1), MIN(Value2), MAX(Value2),MIN(Value5), MAX(Value5), MIN(Value6), MAX(Value6) FROM MultiMeter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];

							unsigned long long total_min_usage_1 = std::strtoull(sd[0].c_str(), nullptr, 10);
							unsigned long long total_max_usage_1 = std::strtoull(sd[1].c_str(), nullptr, 10);
							unsigned long long total_min_usage_2 = std::strtoull(sd[4].c_str(), nullptr, 10);
							unsigned long long total_max_usage_2 = std::strtoull(sd[5].c_str(), nullptr, 10);
							unsigned long long total_real_usage_1, total_real_usage_2;
							unsigned long long total_min_deliv_1 = std::strtoull(sd[2].c_str(), nullptr, 10);
							unsigned long long total_max_deliv_1 = std::strtoull(sd[3].c_str(), nullptr, 10);
							unsigned long long total_min_deliv_2 = std::strtoull(sd[6].c_str(), nullptr, 10);
							unsigned long long total_max_deliv_2 = std::strtoull(sd[7].c_str(), nullptr, 10);
							unsigned long long total_real_deliv_1, total_real_deliv_2;

							bool bHaveDeliverd = false;

							total_real_usage_1 = total_max_usage_1 - total_min_usage_1;
							total_real_usage_2 = total_max_usage_2 - total_min_usage_2;

							total_real_deliv_1 = total_max_deliv_1 - total_min_deliv_1;
							total_real_deliv_2 = total_max_deliv_2 - total_min_deliv_2;
							if ((total_real_deliv_1 != 0) || (total_real_deliv_2 != 0))
								bHaveDeliverd = true;

							root[""result""][ii][""d""] = szDateEnd;

							sprintf(szTmp, ""%llu"", total_real_usage_1);
							std::string szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""v""] = szTmp;
							sprintf(szTmp, ""%llu"", total_real_usage_2);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""v2""] = szTmp;

							sprintf(szTmp, ""%llu"", total_real_deliv_1);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""r1""] = szTmp;
							sprintf(szTmp, ""%llu"", total_real_deliv_2);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""r2""] = szTmp;

							ii++;
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
					}
					else if (!bIsManagedCounter)
					{
						result = m_sql.safe_query(""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];

							unsigned long long total_min = std::strtoull(sd[0].c_str(), nullptr, 10);
							unsigned long long total_max = std::strtoull(sd[1].c_str(), nullptr, 10);
							unsigned long long total_real;

							total_real = total_max - total_min;
							sprintf(szTmp, ""%llu"", total_real);
							std::string szValue = szTmp;
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								szValue = szTmp;
								break;
							case MTYPE_GAS:
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								szValue = szTmp;
								break;
							case MTYPE_WATER:
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								szValue = szTmp;
								break;
							case MTYPE_COUNTER:
								break;
							default:
								szValue = ""0"";
								break;
							}

							root[""result""][ii][""d""] = szDateEnd;
							root[""result""][ii][""v""] = szValue;
							ii++;
						}
					}
				}
			}//week
			else if ((srange == ""month"") || (srange == ""year""))
			{
				char szDateStart[40];
				char szDateEnd[40];
				char szDateStartPrev[40];
				char szDateEndPrev[40];

				std::string sactmonth = request::findValue(&req, ""actmonth"");
				std::string sactyear = request::findValue(&req, ""actyear"");

				int actMonth = atoi(sactmonth.c_str());
				int actYear = atoi(sactyear.c_str());

				if ((sactmonth != """") && (sactyear != """"))
				{
					sprintf(szDateStart, ""%04d-%02d-%02d"", actYear, actMonth, 1);
					sprintf(szDateStartPrev, ""%04d-%02d-%02d"", actYear - 1, actMonth, 1);
					actMonth++;
					if (actMonth == 13)
					{
						actMonth = 1;
						actYear++;
					}
					sprintf(szDateEnd, ""%04d-%02d-%02d"", actYear, actMonth, 1);
					sprintf(szDateEndPrev, ""%04d-%02d-%02d"", actYear - 1, actMonth, 1);
				}
				else if (sactyear != """")
				{
					sprintf(szDateStart, ""%04d-%02d-%02d"", actYear, 1, 1);
					sprintf(szDateStartPrev, ""%04d-%02d-%02d"", actYear - 1, 1, 1);
					actYear++;
					sprintf(szDateEnd, ""%04d-%02d-%02d"", actYear, 1, 1);
					sprintf(szDateEndPrev, ""%04d-%02d-%02d"", actYear - 1, 1, 1);
				}
				else
				{
					sprintf(szDateEnd, ""%04d-%02d-%02d"", tm1.tm_year + 1900, tm1.tm_mon + 1, tm1.tm_mday);
					sprintf(szDateEndPrev, ""%04d-%02d-%02d"", tm1.tm_year + 1900 - 1, tm1.tm_mon + 1, tm1.tm_mday);

					struct tm tm2;
					if (srange == ""month"")
					{
						time_t monthbefore;
						getNoon(monthbefore, tm2, tm1.tm_year + 1900, tm1.tm_mon, tm1.tm_mday);
					}
					else
					{
						time_t yearbefore;
						getNoon(yearbefore, tm2, tm1.tm_year + 1900 - 1, tm1.tm_mon + 1, tm1.tm_mday);
					}

					sprintf(szDateStart, ""%04d-%02d-%02d"", tm2.tm_year + 1900, tm2.tm_mon + 1, tm2.tm_mday);
					sprintf(szDateStartPrev, ""%04d-%02d-%02d"", tm2.tm_year + 1900 - 1, tm2.tm_mon + 1, tm2.tm_mday);
				}

				if (sensor == ""temp"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(
						""SELECT Temp_Min, Temp_Max, Chill_Min, Chill_Max,""
						"" Humidity, Barometer, Temp_Avg, Date, SetPoint_Min,""
						"" SetPoint_Max, SetPoint_Avg ""
						""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
						"" AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStart, szDateEnd);
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[7].substr(0, 16);

							if (
								(dType == pTypeRego6XXTemp) || (dType == pTypeTEMP) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO) || (dType == pTypeTEMP_BARO) || (dType == pTypeWIND) || (dType == pTypeThermostat1) || (dType == pTypeRadiator1) ||
								((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp)) ||
								((dType == pTypeUV) && (dSubType == sTypeUV3)) ||
								((dType == pTypeGeneral) && (dSubType == sTypeSystemTemp)) ||
								((dType == pTypeThermostat) && (dSubType == sTypeThermSetpoint)) ||
								(dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater) ||
								((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								)
							{
								bool bOK = true;
								if (dType == pTypeWIND)
								{
									bOK = ((dSubType != sTypeWINDNoTemp) && (dSubType != sTypeWINDNoTempNoChill));
								}
								if (bOK)
								{
									double te = ConvertTemperature(atof(sd[1].c_str()), tempsign);
									double tm = ConvertTemperature(atof(sd[0].c_str()), tempsign);
									double ta = ConvertTemperature(atof(sd[6].c_str()), tempsign);
									root[""result""][ii][""te""] = te;
									root[""result""][ii][""tm""] = tm;
									root[""result""][ii][""ta""] = ta;
								}
							}
							if (
								((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
								((dType == pTypeWIND) && (dSubType == sTypeWINDNoTemp))
								)
							{
								double ch = ConvertTemperature(atof(sd[3].c_str()), tempsign);
								double cm = ConvertTemperature(atof(sd[2].c_str()), tempsign);
								root[""result""][ii][""ch""] = ch;
								root[""result""][ii][""cm""] = cm;
							}
							if ((dType == pTypeHUM) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO))
							{
								root[""result""][ii][""hu""] = sd[4];
							}
							if (
								(dType == pTypeTEMP_HUM_BARO) ||
								(dType == pTypeTEMP_BARO) ||
								((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								)
							{
								if (dType == pTypeTEMP_HUM_BARO)
								{
									if (dSubType == sTypeTHBFloat)
									{
										sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
									else
										root[""result""][ii][""ba""] = sd[5];
								}
								else if (dType == pTypeTEMP_BARO)
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
								else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
							}
							if ((dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater))
							{
								double sm = ConvertTemperature(atof(sd[8].c_str()), tempsign);
								double sx = ConvertTemperature(atof(sd[9].c_str()), tempsign);
								double se = ConvertTemperature(atof(sd[10].c_str()), tempsign);
								root[""result""][ii][""sm""] = sm;
								root[""result""][ii][""se""] = se;
								root[""result""][ii][""sx""] = sx;
							}
							ii++;
						}
					}
					result = m_sql.safe_query(
						""SELECT MIN(Temperature), MAX(Temperature),""
						"" MIN(Chill), MAX(Chill), AVG(Humidity),""
						"" AVG(Barometer), AVG(Temperature), MIN(SetPoint),""
						"" MAX(SetPoint), AVG(SetPoint) ""
						""FROM Temperature WHERE (DeviceRowID==%"" PRIu64 """"
						"" AND Date>='%q')"",
						idx, szDateEnd);
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						root[""result""][ii][""d""] = szDateEnd;
						if (
							((dType == pTypeRego6XXTemp) || (dType == pTypeTEMP) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO) || (dType == pTypeTEMP_BARO) || (dType == pTypeWIND) || (dType == pTypeThermostat1) || (dType == pTypeRadiator1)) ||
							((dType == pTypeUV) && (dSubType == sTypeUV3)) ||
							((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
							(dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater)
							)
						{
							double te = ConvertTemperature(atof(sd[1].c_str()), tempsign);
							double tm = ConvertTemperature(atof(sd[0].c_str()), tempsign);
							double ta = ConvertTemperature(atof(sd[6].c_str()), tempsign);

							root[""result""][ii][""te""] = te;
							root[""result""][ii][""tm""] = tm;
							root[""result""][ii][""ta""] = ta;
						}
						if (
							((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
							((dType == pTypeWIND) && (dSubType == sTypeWINDNoTemp))
							)
						{
							double ch = ConvertTemperature(atof(sd[3].c_str()), tempsign);
							double cm = ConvertTemperature(atof(sd[2].c_str()), tempsign);
							root[""result""][ii][""ch""] = ch;
							root[""result""][ii][""cm""] = cm;
						}
						if ((dType == pTypeHUM) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO))
						{
							root[""result""][ii][""hu""] = sd[4];
						}
						if (
							(dType == pTypeTEMP_HUM_BARO) ||
							(dType == pTypeTEMP_BARO) ||
							((dType == pTypeGeneral) && (dSubType == sTypeBaro))
							)
						{
							if (dType == pTypeTEMP_HUM_BARO)
							{
								if (dSubType == sTypeTHBFloat)
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
								else
									root[""result""][ii][""ba""] = sd[5];
							}
							else if (dType == pTypeTEMP_BARO)
							{
								sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
								root[""result""][ii][""ba""] = szTmp;
							}
							else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
							{
								sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
								root[""result""][ii][""ba""] = szTmp;
							}
						}
						if ((dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater))
						{
							double sx = ConvertTemperature(atof(sd[8].c_str()), tempsign);
							double sm = ConvertTemperature(atof(sd[7].c_str()), tempsign);
							double se = ConvertTemperature(atof(sd[9].c_str()), tempsign);
							root[""result""][ii][""se""] = se;
							root[""result""][ii][""sm""] = sm;
							root[""result""][ii][""sx""] = sx;
						}
						ii++;
					}
					result = m_sql.safe_query(
						""SELECT Temp_Min, Temp_Max, Chill_Min, Chill_Max,""
						"" Humidity, Barometer, Temp_Avg, Date, SetPoint_Min,""
						"" SetPoint_Max, SetPoint_Avg ""
						""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
						"" AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
					if (!result.empty())
					{
						iPrev = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""resultprev""][iPrev][""d""] = sd[7].substr(0, 16);

							if (
								(dType == pTypeRego6XXTemp) || (dType == pTypeTEMP) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO) || (dType == pTypeTEMP_BARO) || (dType == pTypeWIND) || (dType == pTypeThermostat1) || (dType == pTypeRadiator1) ||
								((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp)) ||
								((dType == pTypeUV) && (dSubType == sTypeUV3)) ||
								((dType == pTypeGeneral) && (dSubType == sTypeSystemTemp)) ||
								((dType == pTypeThermostat) && (dSubType == sTypeThermSetpoint)) ||
								(dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater)
								)
							{
								bool bOK = true;
								if (dType == pTypeWIND)
								{
									bOK = ((dSubType == sTypeWIND4) || (dSubType == sTypeWINDNoTemp));
								}
								if (bOK)
								{
									double te = ConvertTemperature(atof(sd[1].c_str()), tempsign);
									double tm = ConvertTemperature(atof(sd[0].c_str()), tempsign);
									double ta = ConvertTemperature(atof(sd[6].c_str()), tempsign);
									root[""resultprev""][iPrev][""te""] = te;
									root[""resultprev""][iPrev][""tm""] = tm;
									root[""resultprev""][iPrev][""ta""] = ta;
								}
							}
							if (
								((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
								((dType == pTypeWIND) && (dSubType == sTypeWINDNoTemp))
								)
							{
								double ch = ConvertTemperature(atof(sd[3].c_str()), tempsign);
								double cm = ConvertTemperature(atof(sd[2].c_str()), tempsign);
								root[""resultprev""][iPrev][""ch""] = ch;
								root[""resultprev""][iPrev][""cm""] = cm;
							}
							if ((dType == pTypeHUM) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO))
							{
								root[""resultprev""][iPrev][""hu""] = sd[4];
							}
							if (
								(dType == pTypeTEMP_HUM_BARO) ||
								(dType == pTypeTEMP_BARO) ||
								((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								)
							{
								if (dType == pTypeTEMP_HUM_BARO)
								{
									if (dSubType == sTypeTHBFloat)
									{
										sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
										root[""resultprev""][iPrev][""ba""] = szTmp;
									}
									else
										root[""resultprev""][iPrev][""ba""] = sd[5];
								}
								else if (dType == pTypeTEMP_BARO)
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""resultprev""][iPrev][""ba""] = szTmp;
								}
								else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""resultprev""][iPrev][""ba""] = szTmp;
								}
							}
							if ((dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater))
							{
								double sx = ConvertTemperature(atof(sd[8].c_str()), tempsign);
								double sm = ConvertTemperature(atof(sd[7].c_str()), tempsign);
								double se = ConvertTemperature(atof(sd[9].c_str()), tempsign);
								root[""resultprev""][iPrev][""se""] = se;
								root[""resultprev""][iPrev][""sm""] = sm;
								root[""resultprev""][iPrev][""sx""] = sx;
							}
							iPrev++;
						}
					}
				}
				else if (sensor == ""Percentage"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Percentage_Min, Percentage_Max, Percentage_Avg, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[3].substr(0, 16);
							root[""result""][ii][""v_min""] = sd[0];
							root[""result""][ii][""v_max""] = sd[1];
							root[""result""][ii][""v_avg""] = sd[2];
							ii++;
						}
					}
					result = m_sql.safe_query(
						""SELECT MIN(Percentage), MAX(Percentage), AVG(Percentage) FROM Percentage WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q')"",
						idx, szDateEnd);
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];
						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""v_min""] = sd[0];
						root[""result""][ii][""v_max""] = sd[1];
						root[""result""][ii][""v_avg""] = sd[2];
						ii++;
					}

				}
				else if (sensor == ""fan"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Speed_Min, Speed_Max, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[2].substr(0, 16);
							root[""result""][ii][""v_max""] = sd[1];
							root[""result""][ii][""v_min""] = sd[0];
							ii++;
						}
					}
					result = m_sql.safe_query(""SELECT MIN(Speed), MAX(Speed) FROM Fan WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q')"",
						idx, szDateEnd);
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];
						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""v_max""] = sd[1];
						root[""result""][ii][""v_min""] = sd[0];
						ii++;
					}

				}
				else if (sensor == ""uv"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Level, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[1].substr(0, 16);
							root[""result""][ii][""uvi""] = sd[0];
							ii++;
						}
					}
					result = m_sql.safe_query(
						""SELECT MAX(Level) FROM UV WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q')"",
						idx, szDateEnd);
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""uvi""] = sd[0];
						ii++;
					}
					result = m_sql.safe_query(""SELECT Level, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
					if (!result.empty())
					{
						iPrev = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""resultprev""][iPrev][""d""] = sd[1].substr(0, 16);
							root[""resultprev""][iPrev][""uvi""] = sd[0];
							iPrev++;
						}
					}
				}
				else if (sensor == ""rain"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(""SELECT Total, Rate, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[2].substr(0, 16);
							double mmval = atof(sd[0].c_str());
							mmval *= AddjMulti;
							sprintf(szTmp, ""%.1f"", mmval);
							root[""result""][ii][""mm""] = szTmp;
							ii++;
						}
					}
					if (dSubType != sTypeRAINWU)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Total), MAX(Total), MAX(Rate) FROM Rain WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
					}
					else
					{
						result = m_sql.safe_query(
							""SELECT Total, Total, Rate FROM Rain WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q') ORDER BY ROWID DESC LIMIT 1"",
							idx, szDateEnd);
					}
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						float total_min = static_cast<float>(atof(sd[0].c_str()));
						float total_max = static_cast<float>(atof(sd[1].c_str()));
						int rate = atoi(sd[2].c_str());

						double total_real = 0;
						if (dSubType != sTypeRAINWU)
						{
							total_real = total_max - total_min;
						}
						else
						{
							total_real = total_max;
						}
						total_real *= AddjMulti;
						sprintf(szTmp, ""%.1f"", total_real);
						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""mm""] = szTmp;
						ii++;
					}
					result = m_sql.safe_query(
						""SELECT Total, Rate, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
					if (!result.empty())
					{
						iPrev = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""resultprev""][iPrev][""d""] = sd[2].substr(0, 16);
							double mmval = atof(sd[0].c_str());
							mmval *= AddjMulti;
							sprintf(szTmp, ""%.1f"", mmval);
							root[""resultprev""][iPrev][""mm""] = szTmp;
							iPrev++;
						}
					}
				}
				else if (sensor == ""counter"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;
					root[""ValueQuantity""] = options[""ValueQuantity""];
					root[""ValueUnits""] = options[""ValueUnits""];

					int nValue = 0;
					std::string sValue = """";

					result = m_sql.safe_query(""SELECT nValue, sValue FROM DeviceStatus WHERE (ID==%"" PRIu64 "")"",
						idx);
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];
						nValue = atoi(sd[0].c_str());
						sValue = sd[1];
					}

					int ii = 0;
					iPrev = 0;
					if (dType == pTypeP1Power)
					{
						result = m_sql.safe_query(
							""SELECT Value1,Value2,Value5,Value6, Date,""
							"" Counter1, Counter2, Counter3, Counter4 ""
							""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
							"" AND Date<='%q') ORDER BY Date ASC"",
							dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							bool bHaveDeliverd = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[4].substr(0, 16);

								double counter_1 = atof(sd[5].c_str());
								double counter_2 = atof(sd[6].c_str());
								double counter_3 = atof(sd[7].c_str());
								double counter_4 = atof(sd[8].c_str());

								std::string szUsage1 = sd[0];
								std::string szDeliv1 = sd[1];
								std::string szUsage2 = sd[2];
								std::string szDeliv2 = sd[3];

								float fUsage_1 = static_cast<float>(atof(szUsage1.c_str()));
								float fUsage_2 = static_cast<float>(atof(szUsage2.c_str()));
								float fDeliv_1 = static_cast<float>(atof(szDeliv1.c_str()));
								float fDeliv_2 = static_cast<float>(atof(szDeliv2.c_str()));

								fDeliv_1 = (fDeliv_1 < 10) ? 0 : fDeliv_1;
								fDeliv_2 = (fDeliv_2 < 10) ? 0 : fDeliv_2;

								if ((fDeliv_1 != 0) || (fDeliv_2 != 0))
									bHaveDeliverd = true;
								sprintf(szTmp, ""%.3f"", fUsage_1 / divider);
								root[""result""][ii][""v""] = szTmp;
								sprintf(szTmp, ""%.3f"", fUsage_2 / divider);
								root[""result""][ii][""v2""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv_1 / divider);
								root[""result""][ii][""r1""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv_2 / divider);
								root[""result""][ii][""r2""] = szTmp;

								if (counter_1 != 0)
								{
									sprintf(szTmp, ""%.3f"", (counter_1 - fUsage_1) / divider);
								}
								else
								{
									strcpy(szTmp, ""0"");
								}
								root[""result""][ii][""c1""] = szTmp;

								if (counter_2 != 0)
								{
									sprintf(szTmp, ""%.3f"", (counter_2 - fDeliv_1) / divider);
								}
								else
								{
									strcpy(szTmp, ""0"");
								}
								root[""result""][ii][""c2""] = szTmp;

								if (counter_3 != 0)
								{
									sprintf(szTmp, ""%.3f"", (counter_3 - fUsage_2) / divider);
								}
								else
								{
									strcpy(szTmp, ""0"");
								}
								root[""result""][ii][""c3""] = szTmp;

								if (counter_4 != 0)
								{
									sprintf(szTmp, ""%.3f"", (counter_4 - fDeliv_2) / divider);
								}
								else
								{
									strcpy(szTmp, ""0"");
								}
								root[""result""][ii][""c4""] = szTmp;

								ii++;
							}
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
						result = m_sql.safe_query(
							""SELECT Value1,Value2,Value5,Value6, Date ""
							""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"",
							dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
						if (!result.empty())
						{
							bool bHaveDeliverd = false;
							iPrev = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""resultprev""][iPrev][""d""] = sd[4].substr(0, 16);

								std::string szUsage1 = sd[0];
								std::string szDeliv1 = sd[1];
								std::string szUsage2 = sd[2];
								std::string szDeliv2 = sd[3];

								float fUsage_1 = static_cast<float>(atof(szUsage1.c_str()));
								float fUsage_2 = static_cast<float>(atof(szUsage2.c_str()));
								float fDeliv_1 = static_cast<float>(atof(szDeliv1.c_str()));
								float fDeliv_2 = static_cast<float>(atof(szDeliv2.c_str()));

								if ((fDeliv_1 != 0) || (fDeliv_2 != 0))
									bHaveDeliverd = true;
								sprintf(szTmp, ""%.3f"", fUsage_1 / divider);
								root[""resultprev""][iPrev][""v""] = szTmp;
								sprintf(szTmp, ""%.3f"", fUsage_2 / divider);
								root[""resultprev""][iPrev][""v2""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv_1 / divider);
								root[""resultprev""][iPrev][""r1""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv_2 / divider);
								root[""resultprev""][iPrev][""r2""] = szTmp;
								iPrev++;
							}
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
					}
					else if (dType == pTypeAirQuality)
					{//month/year
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value1,Value2,Value3,Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[3].substr(0, 16);
								root[""result""][ii][""co2_min""] = sd[0];
								root[""result""][ii][""co2_max""] = sd[1];
								root[""result""][ii][""co2_avg""] = sd[2];
								ii++;
							}
						}
						result = m_sql.safe_query(""SELECT Value2,Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
						if (!result.empty())
						{
							iPrev = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""resultprev""][iPrev][""d""] = sd[1].substr(0, 16);
								root[""resultprev""][iPrev][""co2_max""] = sd[0];
								iPrev++;
							}
						}
					}
					else if (
						((dType == pTypeGeneral) && ((dSubType == sTypeSoilMoisture) || (dSubType == sTypeLeafWetness))) ||
						((dType == pTypeRFXSensor) && ((dSubType == sTypeRFXSensorAD) || (dSubType == sTypeRFXSensorVolt)))
						)
					{//month/year
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value1,Value2, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[2].substr(0, 16);
								root[""result""][ii][""v_min""] = sd[0];
								root[""result""][ii][""v_max""] = sd[1];
								ii++;
							}
						}
					}
					else if (
						((dType == pTypeGeneral) && (dSubType == sTypeVisibility)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeDistance)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSolarRadiation)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeCurrent)) ||
						((dType == pTypeGeneral) && (dSubType == sTypePressure)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSoundLevel))
						)
					{//month/year
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						float vdiv = 10.0f;
						if (
							((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
							((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
							)
						{
							vdiv = 1000.0f;
						}

						result = m_sql.safe_query(""SELECT Value1,Value2,Value3,Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								float fValue1 = float(atof(sd[0].c_str())) / vdiv;
								float fValue2 = float(atof(sd[1].c_str())) / vdiv;
								float fValue3 = float(atof(sd[2].c_str())) / vdiv;
								root[""result""][ii][""d""] = sd[3].substr(0, 16);

								if (metertype == 1)
								{
									fValue1 *= 0.6214f;
									fValue2 *= 0.6214f;
								}
								if (
									((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
									((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
									)
								{
									sprintf(szTmp, ""%.3f"", fValue1);
									root[""result""][ii][""v_min""] = szTmp;
									sprintf(szTmp, ""%.3f"", fValue2);
									root[""result""][ii][""v_max""] = szTmp;
									if (fValue3 != 0)
									{
										sprintf(szTmp, ""%.3f"", fValue3);
										root[""result""][ii][""v_avg""] = szTmp;
									}
								}
								else
								{
									sprintf(szTmp, ""%.1f"", fValue1);
									root[""result""][ii][""v_min""] = szTmp;
									sprintf(szTmp, ""%.1f"", fValue2);
									root[""result""][ii][""v_max""] = szTmp;
									if (fValue3 != 0)
									{
										sprintf(szTmp, ""%.1f"", fValue3);
										root[""result""][ii][""v_avg""] = szTmp;
									}
								}
								ii++;
							}
						}
					}
					else if (dType == pTypeLux)
					{//month/year
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(""SELECT Value1,Value2,Value3, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[3].substr(0, 16);
								root[""result""][ii][""lux_min""] = sd[0];
								root[""result""][ii][""lux_max""] = sd[1];
								root[""result""][ii][""lux_avg""] = sd[2];
								ii++;
							}
						}
					}
					else if (dType == pTypeWEIGHT)
					{//month/year
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(
							""SELECT Value1,Value2, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[2].substr(0, 16);
								sprintf(szTmp, ""%.1f"", m_sql.m_weightscale * atof(sd[0].c_str()) / 10.0f);
								root[""result""][ii][""v_min""] = szTmp;
								sprintf(szTmp, ""%.1f"", m_sql.m_weightscale * atof(sd[1].c_str()) / 10.0f);
								root[""result""][ii][""v_max""] = szTmp;
								ii++;
							}
						}
					}
					else if (dType == pTypeUsage)
					{//month/year
						root[""status""] = ""OK"";
						root[""title""] = ""Graph "" + sensor + "" "" + srange;

						result = m_sql.safe_query(
							""SELECT Value1,Value2, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[2].substr(0, 16);
								root[""result""][ii][""u_min""] = atof(sd[0].c_str()) / 10.0f;
								root[""result""][ii][""u_max""] = atof(sd[1].c_str()) / 10.0f;
								ii++;
							}
						}
					}
					else if (dType == pTypeCURRENT)
					{
						result = m_sql.safe_query(""SELECT Value1,Value2,Value3,Value4,Value5,Value6, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							int displaytype = 0;
							int voltage = 230;
							m_sql.GetPreferencesVar(""CM113DisplayType"", displaytype);
							m_sql.GetPreferencesVar(""ElectricVoltage"", voltage);

							root[""displaytype""] = displaytype;

							bool bHaveL1 = false;
							bool bHaveL2 = false;
							bool bHaveL3 = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[6].substr(0, 16);

								float fval1 = static_cast<float>(atof(sd[0].c_str()) / 10.0f);
								float fval2 = static_cast<float>(atof(sd[1].c_str()) / 10.0f);
								float fval3 = static_cast<float>(atof(sd[2].c_str()) / 10.0f);
								float fval4 = static_cast<float>(atof(sd[3].c_str()) / 10.0f);
								float fval5 = static_cast<float>(atof(sd[4].c_str()) / 10.0f);
								float fval6 = static_cast<float>(atof(sd[5].c_str()) / 10.0f);

								if ((fval1 != 0) || (fval2 != 0))
									bHaveL1 = true;
								if ((fval3 != 0) || (fval4 != 0))
									bHaveL2 = true;
								if ((fval5 != 0) || (fval6 != 0))
									bHaveL3 = true;

								if (displaytype == 0)
								{
									sprintf(szTmp, ""%.1f"", fval1);
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval2);
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval3);
									root[""result""][ii][""v3""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval4);
									root[""result""][ii][""v4""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval5);
									root[""result""][ii][""v5""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval6);
									root[""result""][ii][""v6""] = szTmp;
								}
								else
								{
									sprintf(szTmp, ""%d"", int(fval1*voltage));
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval2*voltage));
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval3*voltage));
									root[""result""][ii][""v3""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval4*voltage));
									root[""result""][ii][""v4""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval5*voltage));
									root[""result""][ii][""v5""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval6*voltage));
									root[""result""][ii][""v6""] = szTmp;
								}

								ii++;
							}
							if (
								(!bHaveL1) &&
								(!bHaveL2) &&
								(!bHaveL3)
								) {
								root[""haveL1""] = true; //show at least something
							}
							else {
								if (bHaveL1)
									root[""haveL1""] = true;
								if (bHaveL2)
									root[""haveL2""] = true;
								if (bHaveL3)
									root[""haveL3""] = true;
							}
						}
					}
					else if (dType == pTypeCURRENTENERGY)
					{
						result = m_sql.safe_query(""SELECT Value1,Value2,Value3,Value4,Value5,Value6, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							int displaytype = 0;
							int voltage = 230;
							m_sql.GetPreferencesVar(""CM113DisplayType"", displaytype);
							m_sql.GetPreferencesVar(""ElectricVoltage"", voltage);

							root[""displaytype""] = displaytype;

							bool bHaveL1 = false;
							bool bHaveL2 = false;
							bool bHaveL3 = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[6].substr(0, 16);

								float fval1 = static_cast<float>(atof(sd[0].c_str()) / 10.0f);
								float fval2 = static_cast<float>(atof(sd[1].c_str()) / 10.0f);
								float fval3 = static_cast<float>(atof(sd[2].c_str()) / 10.0f);
								float fval4 = static_cast<float>(atof(sd[3].c_str()) / 10.0f);
								float fval5 = static_cast<float>(atof(sd[4].c_str()) / 10.0f);
								float fval6 = static_cast<float>(atof(sd[5].c_str()) / 10.0f);

								if ((fval1 != 0) || (fval2 != 0))
									bHaveL1 = true;
								if ((fval3 != 0) || (fval4 != 0))
									bHaveL2 = true;
								if ((fval5 != 0) || (fval6 != 0))
									bHaveL3 = true;

								if (displaytype == 0)
								{
									sprintf(szTmp, ""%.1f"", fval1);
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval2);
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval3);
									root[""result""][ii][""v3""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval4);
									root[""result""][ii][""v4""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval5);
									root[""result""][ii][""v5""] = szTmp;
									sprintf(szTmp, ""%.1f"", fval6);
									root[""result""][ii][""v6""] = szTmp;
								}
								else
								{
									sprintf(szTmp, ""%d"", int(fval1*voltage));
									root[""result""][ii][""v1""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval2*voltage));
									root[""result""][ii][""v2""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval3*voltage));
									root[""result""][ii][""v3""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval4*voltage));
									root[""result""][ii][""v4""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval5*voltage));
									root[""result""][ii][""v5""] = szTmp;
									sprintf(szTmp, ""%d"", int(fval6*voltage));
									root[""result""][ii][""v6""] = szTmp;
								}

								ii++;
							}
							if (
								(!bHaveL1) &&
								(!bHaveL2) &&
								(!bHaveL3)
								) {
								root[""haveL1""] = true; //show at least something
							}
							else {
								if (bHaveL1)
									root[""haveL1""] = true;
								if (bHaveL2)
									root[""haveL2""] = true;
								if (bHaveL3)
									root[""haveL3""] = true;
							}
						}
					}
					else
					{
						if (dType == pTypeP1Gas)
						{
							sprintf(szTmp, ""%.3f"", atof(sValue.c_str()) / 1000.0);
							root[""counter""] = szTmp;
						}
						else if (dType == pTypeENERGY)
						{
							size_t spos = sValue.find("";"");
							if (spos != std::string::npos)
							{
								float fvalue = static_cast<float>(atof(sValue.substr(spos + 1).c_str()));
								sprintf(szTmp, ""%.3f"", fvalue / (divider / 100.0f));
								root[""counter""] = szTmp;
							}
						}
						else if ((dType == pTypeGeneral) && (dSubType == sTypeKwh))
						{
							size_t spos = sValue.find("";"");
							if (spos != std::string::npos)
							{
								float fvalue = static_cast<float>(atof(sValue.substr(spos + 1).c_str()));
								sprintf(szTmp, ""%.3f"", fvalue / divider);
								root[""counter""] = szTmp;
							}
						}
						else if (dType == pTypeRFXMeter)
						{
							float fvalue = static_cast<float>(atof(sValue.c_str()));
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
								sprintf(szTmp, ""%.3f"", AddjValue + (fvalue / divider));
								break;
							case MTYPE_GAS:
								sprintf(szTmp, ""%.2f"", AddjValue + (fvalue / divider));
								break;
							case MTYPE_WATER:
								sprintf(szTmp, ""%.3f"", AddjValue + (fvalue / divider));
								break;
							default:
								strcpy(szTmp, """");
								break;
							}
							root[""counter""] = szTmp;
						}
						else if (dType == pTypeYouLess)
						{
							std::vector<std::string> results;
							StringSplit(sValue, "";"", results);
							if (results.size() == 2)
							{
								float fvalue = static_cast<float>(atof(results[0].c_str()));
								switch (metertype)
								{
								case MTYPE_ENERGY:
								case MTYPE_ENERGY_GENERATED:
									sprintf(szTmp, ""%.3f"", fvalue / divider);
									break;
								case MTYPE_GAS:
									sprintf(szTmp, ""%.2f"", fvalue / divider);
									break;
								case MTYPE_WATER:
									sprintf(szTmp, ""%.3f"", fvalue / divider);
									break;
								default:
									strcpy(szTmp, """");
									break;
								}
								root[""counter""] = szTmp;
							}
						}
						else if (!bIsManagedCounter)
						{
							sprintf(szTmp, ""%d"", atoi(sValue.c_str()));
							root[""counter""] = szTmp;
						}
						else
						{
							root[""counter""] = ""0"";
						}
						result = m_sql.safe_query(""SELECT Value, Date, Counter FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart, szDateEnd);
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[1].substr(0, 16);

								std::string szValue = sd[0];

								double fcounter = atof(sd[2].c_str());

								switch (metertype)
								{
								case MTYPE_ENERGY:
								case MTYPE_ENERGY_GENERATED:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									root[""result""][ii][""v""] = szTmp;
									if (fcounter != 0)
										sprintf(szTmp, ""%.3f"", AddjValue + ((fcounter - atof(szValue.c_str())) / divider));
									else
										strcpy(szTmp, ""0"");
									root[""result""][ii][""c""] = szTmp;
									break;
								case MTYPE_GAS:
									sprintf(szTmp, ""%.2f"", atof(szValue.c_str()) / divider);
									root[""result""][ii][""v""] = szTmp;
									if (fcounter != 0)
										sprintf(szTmp, ""%.2f"", AddjValue + ((fcounter - atof(szValue.c_str())) / divider));
									else
										strcpy(szTmp, ""0"");
									root[""result""][ii][""c""] = szTmp;
									break;
								case MTYPE_WATER:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									root[""result""][ii][""v""] = szTmp;
									if (fcounter != 0)
										sprintf(szTmp, ""%.3f"", AddjValue + ((fcounter - atof(szValue.c_str())) / divider));
									else
										strcpy(szTmp, ""0"");
									root[""result""][ii][""c""] = szTmp;
									break;
								case MTYPE_COUNTER:
									sprintf(szTmp, ""%.0f"", atof(szValue.c_str()));
									root[""result""][ii][""v""] = szTmp;
									if (fcounter != 0)
										sprintf(szTmp, ""%.0f"", AddjValue + ((fcounter - atof(szValue.c_str()))));
									else
										strcpy(szTmp, ""0"");
									root[""result""][ii][""c""] = szTmp;
									break;
								}
								ii++;
							}
						}
						result = m_sql.safe_query(""SELECT Value, Date, Counter FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
						if (!result.empty())
						{
							iPrev = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""resultprev""][iPrev][""d""] = sd[1].substr(0, 16);

								std::string szValue = sd[0];
								switch (metertype)
								{
								case MTYPE_ENERGY:
								case MTYPE_ENERGY_GENERATED:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									root[""resultprev""][iPrev][""v""] = szTmp;
									break;
								case MTYPE_GAS:
									sprintf(szTmp, ""%.2f"", atof(szValue.c_str()) / divider);
									root[""resultprev""][iPrev][""v""] = szTmp;
									break;
								case MTYPE_WATER:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									root[""resultprev""][iPrev][""v""] = szTmp;
									break;
								case MTYPE_COUNTER:
									sprintf(szTmp, ""%.0f"", atof(szValue.c_str()));
									root[""resultprev""][iPrev][""v""] = szTmp;
									break;
								}
								iPrev++;
							}
						}
					}

					if ((sactmonth != """") || (sactyear != """"))
					{
						struct tm loctime;
						time_t now = mytime(NULL);
						localtime_r(&now, &loctime);
						if ((sactmonth != """") && (sactyear != """"))
						{
							bool bIsThisMonth = (atoi(sactyear.c_str()) == loctime.tm_year + 1900) && (atoi(sactmonth.c_str()) == loctime.tm_mon + 1);
							if (bIsThisMonth)
							{
								sprintf(szDateEnd, ""%04d-%02d-%02d"", loctime.tm_year + 1900, loctime.tm_mon + 1, loctime.tm_mday);
							}
						}
						else if (sactyear != """")
						{
							bool bIsThisYear = (atoi(sactyear.c_str()) == loctime.tm_year + 1900);
							if (bIsThisYear)
							{
								sprintf(szDateEnd, ""%04d-%02d-%02d"", loctime.tm_year + 1900, loctime.tm_mon + 1, loctime.tm_mday);
							}

						}
					}

					if (dType == pTypeP1Power)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value1), MAX(Value1), MIN(Value2),""
							"" MAX(Value2), MIN(Value5), MAX(Value5),""
							"" MIN(Value6), MAX(Value6) ""
							""FROM MultiMeter WHERE (DeviceRowID=%"" PRIu64 """"
							"" AND Date>='%q')"",
							idx, szDateEnd);
						bool bHaveDeliverd = false;
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];
							unsigned long long total_min_usage_1 = std::strtoull(sd[0].c_str(), nullptr, 10);
							unsigned long long total_max_usage_1 = std::strtoull(sd[1].c_str(), nullptr, 10);
							unsigned long long total_min_usage_2 = std::strtoull(sd[4].c_str(), nullptr, 10);
							unsigned long long total_max_usage_2 = std::strtoull(sd[5].c_str(), nullptr, 10);
							unsigned long long total_real_usage_1, total_real_usage_2;
							unsigned long long total_min_deliv_1 = std::strtoull(sd[2].c_str(), nullptr, 10);
							unsigned long long total_max_deliv_1 = std::strtoull(sd[3].c_str(), nullptr, 10);
							unsigned long long total_min_deliv_2 = std::strtoull(sd[6].c_str(), nullptr, 10);
							unsigned long long total_max_deliv_2 = std::strtoull(sd[7].c_str(), nullptr, 10);
							unsigned long long total_real_deliv_1, total_real_deliv_2;

							total_real_usage_1 = total_max_usage_1 - total_min_usage_1;
							total_real_usage_2 = total_max_usage_2 - total_min_usage_2;

							total_real_deliv_1 = total_max_deliv_1 - total_min_deliv_1;
							total_real_deliv_2 = total_max_deliv_2 - total_min_deliv_2;

							if ((total_real_deliv_1 != 0) || (total_real_deliv_2 != 0))
								bHaveDeliverd = true;

							root[""result""][ii][""d""] = szDateEnd;

							std::string szValue;

							sprintf(szTmp, ""%llu"", total_real_usage_1);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""v""] = szTmp;
							sprintf(szTmp, ""%llu"", total_real_usage_2);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""v2""] = szTmp;

							sprintf(szTmp, ""%llu"", total_real_deliv_1);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""r1""] = szTmp;
							sprintf(szTmp, ""%llu"", total_real_deliv_2);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""r2""] = szTmp;

							ii++;
						}
						if (bHaveDeliverd)
						{
							root[""delivered""] = true;
						}
					}
					else if (dType == pTypeAirQuality)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value), AVG(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							root[""result""][ii][""d""] = szDateEnd;
							root[""result""][ii][""co2_min""] = result[0][0];
							root[""result""][ii][""co2_max""] = result[0][1];
							root[""result""][ii][""co2_avg""] = result[0][2];
							ii++;
						}
					}
					else if (
						((dType == pTypeGeneral) && ((dSubType == sTypeSoilMoisture) || (dSubType == sTypeLeafWetness))) ||
						((dType == pTypeRFXSensor) && ((dSubType == sTypeRFXSensorAD) || (dSubType == sTypeRFXSensorVolt)))
						)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							root[""result""][ii][""d""] = szDateEnd;
							root[""result""][ii][""v_min""] = result[0][0];
							root[""result""][ii][""v_max""] = result[0][1];
							ii++;
						}
					}
					else if (
						((dType == pTypeGeneral) && (dSubType == sTypeVisibility)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeDistance)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSolarRadiation)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeCurrent)) ||
						((dType == pTypeGeneral) && (dSubType == sTypePressure)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeSoundLevel))
						)
					{
						float vdiv = 10.0f;
						if (
							((dType == pTypeGeneral) && (dSubType == sTypeVoltage)) ||
							((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
							)
						{
							vdiv = 1000.0f;
						}

						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							root[""result""][ii][""d""] = szDateEnd;
							float fValue1 = float(atof(result[0][0].c_str())) / vdiv;
							float fValue2 = float(atof(result[0][1].c_str())) / vdiv;
							if (metertype == 1)
							{
								fValue1 *= 0.6214f;
								fValue2 *= 0.6214f;
							}

							if ((dType == pTypeGeneral) && (dSubType == sTypeVoltage))
								sprintf(szTmp, ""%.3f"", fValue1);
							else if ((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
								sprintf(szTmp, ""%.3f"", fValue1);
							else
								sprintf(szTmp, ""%.1f"", fValue1);
							root[""result""][ii][""v_min""] = szTmp;
							if ((dType == pTypeGeneral) && (dSubType == sTypeVoltage))
								sprintf(szTmp, ""%.3f"", fValue2);
							else if ((dType == pTypeGeneral) && (dSubType == sTypeCurrent))
								sprintf(szTmp, ""%.3f"", fValue2);
							else
								sprintf(szTmp, ""%.1f"", fValue2);
							root[""result""][ii][""v_max""] = szTmp;
							ii++;
						}
					}
					else if (dType == pTypeLux)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value), AVG(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							root[""result""][ii][""d""] = szDateEnd;
							root[""result""][ii][""lux_min""] = result[0][0];
							root[""result""][ii][""lux_max""] = result[0][1];
							root[""result""][ii][""lux_avg""] = result[0][2];
							ii++;
						}
					}
					else if (dType == pTypeWEIGHT)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							root[""result""][ii][""d""] = szDateEnd;
							sprintf(szTmp, ""%.1f"", m_sql.m_weightscale* atof(result[0][0].c_str()) / 10.0f);
							root[""result""][ii][""v_min""] = szTmp;
							sprintf(szTmp, ""%.1f"", m_sql.m_weightscale * atof(result[0][1].c_str()) / 10.0f);
							root[""result""][ii][""v_max""] = szTmp;
							ii++;
						}
					}
					else if (dType == pTypeUsage)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID=%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							root[""result""][ii][""d""] = szDateEnd;
							root[""result""][ii][""u_min""] = atof(result[0][0].c_str()) / 10.0f;
							root[""result""][ii][""u_max""] = atof(result[0][1].c_str()) / 10.0f;
							ii++;
						}
					}
					else if (!bIsManagedCounter)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd);
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];
							unsigned long long total_min = std::strtoull(sd[0].c_str(), nullptr, 10);
							unsigned long long total_max = std::strtoull(sd[1].c_str(), nullptr, 10);
							unsigned long long total_real;

							total_real = total_max - total_min;
							sprintf(szTmp, ""%llu"", total_real);

							root[""result""][ii][""d""] = szDateEnd;

							std::string szValue = szTmp;
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
							{
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								root[""result""][ii][""v""] = szTmp;

								std::vector<std::string> mresults;
								StringSplit(sValue, "";"", mresults);
								if (mresults.size() == 2)
								{
									sValue = mresults[1];
								}
								if (dType == pTypeENERGY)
									sprintf(szTmp, ""%.3f"", AddjValue + (((atof(sValue.c_str())*100.0f) - atof(szValue.c_str())) / divider));
								else
									sprintf(szTmp, ""%.3f"", AddjValue + ((atof(sValue.c_str()) - atof(szValue.c_str())) / divider));
								root[""result""][ii][""c""] = szTmp;
							}
							break;
							case MTYPE_GAS:
								sprintf(szTmp, ""%.2f"", atof(szValue.c_str()) / divider);
								root[""result""][ii][""v""] = szTmp;
								sprintf(szTmp, ""%.2f"", AddjValue + ((atof(sValue.c_str()) - atof(szValue.c_str())) / divider));
								root[""result""][ii][""c""] = szTmp;
								break;
							case MTYPE_WATER:
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								root[""result""][ii][""v""] = szTmp;
								sprintf(szTmp, ""%.3f"", AddjValue + ((atof(sValue.c_str()) - atof(szValue.c_str())) / divider));
								root[""result""][ii][""c""] = szTmp;
								break;
							case MTYPE_COUNTER:
								sprintf(szTmp, ""%.0f"", atof(szValue.c_str()));
								root[""result""][ii][""v""] = szTmp;
								sprintf(szTmp, ""%.0f"", AddjValue + ((atof(sValue.c_str()) - atof(szValue.c_str()))));
								root[""result""][ii][""c""] = szTmp;
								break;
							}
							ii++;
						}
					}
				}
				else if (sensor == ""wind"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					int ii = 0;

					result = m_sql.safe_query(
						""SELECT Direction, Speed_Min, Speed_Max, Gust_Min,""
						"" Gust_Max, Date ""
						""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
						"" AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStart, szDateEnd);
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[5].substr(0, 16);
							root[""result""][ii][""di""] = sd[0];

							int intSpeed = atoi(sd[2].c_str());
							int intGust = atoi(sd[4].c_str());
							if (m_sql.m_windunit != WINDUNIT_Beaufort)
							{
								sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
								root[""result""][ii][""sp""] = szTmp;
								sprintf(szTmp, ""%.1f"", float(intGust) * m_sql.m_windscale);
								root[""result""][ii][""gu""] = szTmp;
							}
							else
							{
								float windspeedms = float(intSpeed)*0.1f;
								float windgustms = float(intGust)*0.1f;
								sprintf(szTmp, ""%d"", MStoBeaufort(windspeedms));
								root[""result""][ii][""sp""] = szTmp;
								sprintf(szTmp, ""%d"", MStoBeaufort(windgustms));
								root[""result""][ii][""gu""] = szTmp;
							}
							ii++;
						}
					}
					result = m_sql.safe_query(
						""SELECT AVG(Direction), MIN(Speed), MAX(Speed),""
						"" MIN(Gust), MAX(Gust) ""
						""FROM Wind WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q') ORDER BY Date ASC"",
						idx, szDateEnd);
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""di""] = sd[0];

						int intSpeed = atoi(sd[2].c_str());
						int intGust = atoi(sd[4].c_str());
						if (m_sql.m_windunit != WINDUNIT_Beaufort)
						{
							sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
							root[""result""][ii][""sp""] = szTmp;
							sprintf(szTmp, ""%.1f"", float(intGust) * m_sql.m_windscale);
							root[""result""][ii][""gu""] = szTmp;
						}
						else
						{
							float windspeedms = float(intSpeed)*0.1f;
							float windgustms = float(intGust)*0.1f;
							sprintf(szTmp, ""%d"", MStoBeaufort(windspeedms));
							root[""result""][ii][""sp""] = szTmp;
							sprintf(szTmp, ""%d"", MStoBeaufort(windgustms));
							root[""result""][ii][""gu""] = szTmp;
						}
						ii++;
					}
					result = m_sql.safe_query(
						""SELECT Direction, Speed_Min, Speed_Max, Gust_Min,""
						"" Gust_Max, Date ""
						""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
						"" AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStartPrev, szDateEndPrev);
					if (!result.empty())
					{
						iPrev = 0;
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""resultprev""][iPrev][""d""] = sd[5].substr(0, 16);
							root[""resultprev""][iPrev][""di""] = sd[0];

							int intSpeed = atoi(sd[2].c_str());
							int intGust = atoi(sd[4].c_str());
							if (m_sql.m_windunit != WINDUNIT_Beaufort)
							{
								sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
								root[""resultprev""][iPrev][""sp""] = szTmp;
								sprintf(szTmp, ""%.1f"", float(intGust) * m_sql.m_windscale);
								root[""resultprev""][iPrev][""gu""] = szTmp;
							}
							else
							{
								float windspeedms = float(intSpeed)*0.1f;
								float windgustms = float(intGust)*0.1f;
								sprintf(szTmp, ""%d"", MStoBeaufort(windspeedms));
								root[""resultprev""][iPrev][""sp""] = szTmp;
								sprintf(szTmp, ""%d"", MStoBeaufort(windgustms));
								root[""resultprev""][iPrev][""gu""] = szTmp;
							}
							iPrev++;
						}
					}
				}
			}//month or year
			else if ((srange.substr(0, 1) == ""2"") && (srange.substr(10, 1) == ""T"") && (srange.substr(11, 1) == ""2"")) // custom range 2013-01-01T2013-12-31
			{
				std::string szDateStart = srange.substr(0, 10);
				std::string szDateEnd = srange.substr(11, 10);
				std::string sgraphtype = request::findValue(&req, ""graphtype"");
				std::string sgraphTemp = request::findValue(&req, ""graphTemp"");
				std::string sgraphChill = request::findValue(&req, ""graphChill"");
				std::string sgraphHum = request::findValue(&req, ""graphHum"");
				std::string sgraphBaro = request::findValue(&req, ""graphBaro"");
				std::string sgraphDew = request::findValue(&req, ""graphDew"");
				std::string sgraphSet = request::findValue(&req, ""graphSet"");

				if (sensor == ""temp"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					bool sendTemp = false;
					bool sendChill = false;
					bool sendHum = false;
					bool sendBaro = false;
					bool sendDew = false;
					bool sendSet = false;

					if ((sgraphTemp == ""true"") &&
						((dType == pTypeRego6XXTemp) || (dType == pTypeTEMP) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO) || (dType == pTypeTEMP_BARO) || (dType == pTypeWIND) || (dType == pTypeThermostat1) || (dType == pTypeRadiator1) ||
						((dType == pTypeUV) && (dSubType == sTypeUV3)) ||
							((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
							((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp)) ||
							((dType == pTypeThermostat) && (dSubType == sTypeThermSetpoint)) ||
							(dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater)
							)
						)
					{
						sendTemp = true;
					}
					if ((sgraphSet == ""true"") &&
						((dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater))) //FIXME cheat for water setpoint is just on or off
					{
						sendSet = true;
					}
					if ((sgraphChill == ""true"") &&
						(((dType == pTypeWIND) && (dSubType == sTypeWIND4)) ||
						((dType == pTypeWIND) && (dSubType == sTypeWINDNoTemp)))
						)
					{
						sendChill = true;
					}
					if ((sgraphHum == ""true"") &&
						((dType == pTypeHUM) || (dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO))
						)
					{
						sendHum = true;
					}
					if ((sgraphBaro == ""true"") && (
						(dType == pTypeTEMP_HUM_BARO) ||
						(dType == pTypeTEMP_BARO) ||
						((dType == pTypeGeneral) && (dSubType == sTypeBaro))
						))
					{
						sendBaro = true;
					}
					if ((sgraphDew == ""true"") && ((dType == pTypeTEMP_HUM) || (dType == pTypeTEMP_HUM_BARO)))
					{
						sendDew = true;
					}

					if (sgraphtype == ""1"")
					{
						result = m_sql.safe_query(
							""SELECT Temperature, Chill, Humidity, Barometer,""
							"" Date, DewPoint, SetPoint ""
							""FROM Temperature WHERE (DeviceRowID==%"" PRIu64 """"
							"" AND Date>='%q' AND Date<='%q 23:59:59') ORDER BY Date ASC"",
							idx, szDateStart.c_str(), szDateEnd.c_str());
						int ii = 0;
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[4];//.substr(0,16);
								if (sendTemp)
								{
									double te = ConvertTemperature(atof(sd[0].c_str()), tempsign);
									double tm = ConvertTemperature(atof(sd[0].c_str()), tempsign);
									root[""result""][ii][""te""] = te;
									root[""result""][ii][""tm""] = tm;
								}
								if (sendChill)
								{
									double ch = ConvertTemperature(atof(sd[1].c_str()), tempsign);
									double cm = ConvertTemperature(atof(sd[1].c_str()), tempsign);
									root[""result""][ii][""ch""] = ch;
									root[""result""][ii][""cm""] = cm;
								}
								if (sendHum)
								{
									root[""result""][ii][""hu""] = sd[2];
								}
								if (sendBaro)
								{
									if (dType == pTypeTEMP_HUM_BARO)
									{
										if (dSubType == sTypeTHBFloat)
										{
											sprintf(szTmp, ""%.1f"", atof(sd[3].c_str()) / 10.0f);
											root[""result""][ii][""ba""] = szTmp;
										}
										else
											root[""result""][ii][""ba""] = sd[3];
									}
									else if (dType == pTypeTEMP_BARO)
									{
										sprintf(szTmp, ""%.1f"", atof(sd[3].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
									else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
									{
										sprintf(szTmp, ""%.1f"", atof(sd[3].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
								}
								if (sendDew)
								{
									double dp = ConvertTemperature(atof(sd[5].c_str()), tempsign);
									root[""result""][ii][""dp""] = dp;
								}
								if (sendSet)
								{
									double se = ConvertTemperature(atof(sd[6].c_str()), tempsign);
									root[""result""][ii][""se""] = se;
								}
								ii++;
							}
						}
					}
					else
					{
						result = m_sql.safe_query(
							""SELECT Temp_Min, Temp_Max, Chill_Min, Chill_Max,""
							"" Humidity, Barometer, Date, DewPoint, Temp_Avg,""
							"" SetPoint_Min, SetPoint_Max, SetPoint_Avg ""
							""FROM Temperature_Calendar ""
							""WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
							"" AND Date<='%q') ORDER BY Date ASC"",
							idx, szDateStart.c_str(), szDateEnd.c_str());
						int ii = 0;
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[6].substr(0, 16);
								if (sendTemp)
								{
									double te = ConvertTemperature(atof(sd[1].c_str()), tempsign);
									double tm = ConvertTemperature(atof(sd[0].c_str()), tempsign);
									double ta = ConvertTemperature(atof(sd[8].c_str()), tempsign);

									root[""result""][ii][""te""] = te;
									root[""result""][ii][""tm""] = tm;
									root[""result""][ii][""ta""] = ta;
								}
								if (sendChill)
								{
									double ch = ConvertTemperature(atof(sd[3].c_str()), tempsign);
									double cm = ConvertTemperature(atof(sd[2].c_str()), tempsign);

									root[""result""][ii][""ch""] = ch;
									root[""result""][ii][""cm""] = cm;
								}
								if (sendHum)
								{
									root[""result""][ii][""hu""] = sd[4];
								}
								if (sendBaro)
								{
									if (dType == pTypeTEMP_HUM_BARO)
									{
										if (dSubType == sTypeTHBFloat)
										{
											sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
											root[""result""][ii][""ba""] = szTmp;
										}
										else
											root[""result""][ii][""ba""] = sd[5];
									}
									else if (dType == pTypeTEMP_BARO)
									{
										sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
									else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
									{
										sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
								}
								if (sendDew)
								{
									double dp = ConvertTemperature(atof(sd[7].c_str()), tempsign);
									root[""result""][ii][""dp""] = dp;
								}
								if (sendSet)
								{
									double sm = ConvertTemperature(atof(sd[9].c_str()), tempsign);
									double sx = ConvertTemperature(atof(sd[10].c_str()), tempsign);
									double se = ConvertTemperature(atof(sd[11].c_str()), tempsign);
									root[""result""][ii][""sm""] = sm;
									root[""result""][ii][""se""] = se;
									root[""result""][ii][""sx""] = sx;
									char szTmp[1024];
									sprintf(szTmp, ""%.1f %.1f %.1f"", sm, se, sx);
									_log.Log(LOG_STATUS, ""%s"", szTmp);

								}
								ii++;
							}
						}

						result = m_sql.safe_query(
							""SELECT MIN(Temperature), MAX(Temperature),""
							"" MIN(Chill), MAX(Chill), AVG(Humidity),""
							"" AVG(Barometer), MIN(DewPoint), AVG(Temperature),""
							"" MIN(SetPoint), MAX(SetPoint), AVG(SetPoint) ""
							""FROM Temperature WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd.c_str());
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];

							root[""result""][ii][""d""] = szDateEnd;
							if (sendTemp)
							{
								double te = ConvertTemperature(atof(sd[1].c_str()), tempsign);
								double tm = ConvertTemperature(atof(sd[0].c_str()), tempsign);
								double ta = ConvertTemperature(atof(sd[7].c_str()), tempsign);

								root[""result""][ii][""te""] = te;
								root[""result""][ii][""tm""] = tm;
								root[""result""][ii][""ta""] = ta;
							}
							if (sendChill)
							{
								double ch = ConvertTemperature(atof(sd[3].c_str()), tempsign);
								double cm = ConvertTemperature(atof(sd[2].c_str()), tempsign);
								root[""result""][ii][""ch""] = ch;
								root[""result""][ii][""cm""] = cm;
							}
							if (sendHum)
							{
								root[""result""][ii][""hu""] = sd[4];
							}
							if (sendBaro)
							{
								if (dType == pTypeTEMP_HUM_BARO)
								{
									if (dSubType == sTypeTHBFloat)
									{
										sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
										root[""result""][ii][""ba""] = szTmp;
									}
									else
										root[""result""][ii][""ba""] = sd[5];
								}
								else if (dType == pTypeTEMP_BARO)
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
								else if ((dType == pTypeGeneral) && (dSubType == sTypeBaro))
								{
									sprintf(szTmp, ""%.1f"", atof(sd[5].c_str()) / 10.0f);
									root[""result""][ii][""ba""] = szTmp;
								}
							}
							if (sendDew)
							{
								double dp = ConvertTemperature(atof(sd[6].c_str()), tempsign);
								root[""result""][ii][""dp""] = dp;
							}
							if (sendSet)
							{
								double sm = ConvertTemperature(atof(sd[8].c_str()), tempsign);
								double sx = ConvertTemperature(atof(sd[9].c_str()), tempsign);
								double se = ConvertTemperature(atof(sd[10].c_str()), tempsign);

								root[""result""][ii][""sm""] = sm;
								root[""result""][ii][""se""] = se;
								root[""result""][ii][""sx""] = sx;
							}
							ii++;
						}
					}
				}
				else if (sensor == ""uv"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(
						""SELECT Level, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 """"
						"" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStart.c_str(), szDateEnd.c_str());
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[1].substr(0, 16);
							root[""result""][ii][""uvi""] = sd[0];
							ii++;
						}
					}
					result = m_sql.safe_query(
						""SELECT MAX(Level) FROM UV WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
						idx, szDateEnd.c_str());
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""uvi""] = sd[0];
						ii++;
					}
				}
				else if (sensor == ""rain"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					result = m_sql.safe_query(
						""SELECT Total, Rate, Date FROM %s ""
						""WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStart.c_str(), szDateEnd.c_str());
					int ii = 0;
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[2].substr(0, 16);
							root[""result""][ii][""mm""] = sd[0];
							ii++;
						}
					}
					if (dSubType != sTypeRAINWU)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Total), MAX(Total), MAX(Rate) FROM Rain WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd.c_str());
					}
					else
					{
						result = m_sql.safe_query(
							""SELECT Total, Total, Rate FROM Rain WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q') ORDER BY ROWID DESC LIMIT 1"",
							idx, szDateEnd.c_str());
					}
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						float total_min = static_cast<float>(atof(sd[0].c_str()));
						float total_max = static_cast<float>(atof(sd[1].c_str()));
						int rate = atoi(sd[2].c_str());

						float total_real = 0;
						if (dSubType != sTypeRAINWU)
						{
							total_real = total_max - total_min;
						}
						else
						{
							total_real = total_max;
						}
						sprintf(szTmp, ""%.1f"", total_real);
						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""mm""] = szTmp;
						ii++;
					}
				}
				else if (sensor == ""counter"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;
					root[""ValueQuantity""] = options[""ValueQuantity""];
					root[""ValueUnits""] = options[""ValueUnits""];

					int ii = 0;
					if (dType == pTypeP1Power)
					{
						result = m_sql.safe_query(
							""SELECT Value1,Value2,Value5,Value6, Date ""
							""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
							"" AND Date<='%q') ORDER BY Date ASC"",
							dbasetable.c_str(), idx, szDateStart.c_str(), szDateEnd.c_str());
						if (!result.empty())
						{
							bool bHaveDeliverd = false;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								root[""result""][ii][""d""] = sd[4].substr(0, 16);

								std::string szUsage1 = sd[0];
								std::string szDeliv1 = sd[1];
								std::string szUsage2 = sd[2];
								std::string szDeliv2 = sd[3];

								float fUsage = (float)(atof(szUsage1.c_str()) + atof(szUsage2.c_str()));
								float fDeliv = (float)(atof(szDeliv1.c_str()) + atof(szDeliv2.c_str()));

								if (fDeliv != 0)
									bHaveDeliverd = true;
								sprintf(szTmp, ""%.3f"", fUsage / divider);
								root[""result""][ii][""v""] = szTmp;
								sprintf(szTmp, ""%.3f"", fDeliv / divider);
								root[""result""][ii][""v2""] = szTmp;
								ii++;
							}
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
					}
					else
					{
						result = m_sql.safe_query(""SELECT Value, Date FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q' AND Date<='%q') ORDER BY Date ASC"", dbasetable.c_str(), idx, szDateStart.c_str(), szDateEnd.c_str());
						if (!result.empty())
						{
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								std::string szValue = sd[0];
								switch (metertype)
								{
								case MTYPE_ENERGY:
								case MTYPE_ENERGY_GENERATED:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									szValue = szTmp;
									break;
								case MTYPE_GAS:
									sprintf(szTmp, ""%.2f"", atof(szValue.c_str()) / divider);
									szValue = szTmp;
									break;
								case MTYPE_WATER:
									sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
									szValue = szTmp;
									break;
								}
								root[""result""][ii][""d""] = sd[1].substr(0, 16);
								root[""result""][ii][""v""] = szValue;
								ii++;
							}
						}
					}
					if (dType == pTypeP1Power)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value1), MAX(Value1), MIN(Value2),""
							"" MAX(Value2),MIN(Value5), MAX(Value5),""
							"" MIN(Value6), MAX(Value6) ""
							""FROM MultiMeter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd.c_str());
						bool bHaveDeliverd = false;
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];

							unsigned long long total_min_usage_1 = std::strtoull(sd[0].c_str(), nullptr, 10);
							unsigned long long total_max_usage_1 = std::strtoull(sd[1].c_str(), nullptr, 10);
							unsigned long long total_min_usage_2 = std::strtoull(sd[4].c_str(), nullptr, 10);
							unsigned long long total_max_usage_2 = std::strtoull(sd[5].c_str(), nullptr, 10);
							unsigned long long total_real_usage;

							unsigned long long total_min_deliv_1 = std::strtoull(sd[2].c_str(), nullptr, 10);
							unsigned long long total_max_deliv_1 = std::strtoull(sd[3].c_str(), nullptr, 10);
							unsigned long long total_min_deliv_2 = std::strtoull(sd[6].c_str(), nullptr, 10);
							unsigned long long total_max_deliv_2 = std::strtoull(sd[7].c_str(), nullptr, 10);
							unsigned long long total_real_deliv;

							total_real_usage = (total_max_usage_1 + total_max_usage_2) - (total_min_usage_1 + total_min_usage_2);
							total_real_deliv = (total_max_deliv_1 + total_max_deliv_2) - (total_min_deliv_1 + total_min_deliv_2);

							if (total_real_deliv != 0)
								bHaveDeliverd = true;

							root[""result""][ii][""d""] = szDateEnd;

							sprintf(szTmp, ""%llu"", total_real_usage);
							std::string szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""v""] = szTmp;
							sprintf(szTmp, ""%llu"", total_real_deliv);
							szValue = szTmp;
							sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
							root[""result""][ii][""v2""] = szTmp;
							ii++;
							if (bHaveDeliverd)
							{
								root[""delivered""] = true;
							}
						}
					}
					else if (!bIsManagedCounter)
					{
						result = m_sql.safe_query(
							""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q')"",
							idx, szDateEnd.c_str());
						if (!result.empty())
						{
							std::vector<std::string> sd = result[0];
							unsigned long long total_min = std::strtoull(sd[0].c_str(), nullptr, 10);
							unsigned long long total_max = std::strtoull(sd[1].c_str(), nullptr, 10);
							unsigned long long total_real;

							total_real = total_max - total_min;
							sprintf(szTmp, ""%llu"", total_real);

							std::string szValue = szTmp;
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								szValue = szTmp;
								break;
							case MTYPE_GAS:
								sprintf(szTmp, ""%.2f"", atof(szValue.c_str()) / divider);
								szValue = szTmp;
								break;
							case MTYPE_WATER:
								sprintf(szTmp, ""%.3f"", atof(szValue.c_str()) / divider);
								szValue = szTmp;
								break;
							}

							root[""result""][ii][""d""] = szDateEnd;
							root[""result""][ii][""v""] = szValue;
							ii++;
						}
					}
				}
				else if (sensor == ""wind"") {
					root[""status""] = ""OK"";
					root[""title""] = ""Graph "" + sensor + "" "" + srange;

					int ii = 0;

					result = m_sql.safe_query(
						""SELECT Direction, Speed_Min, Speed_Max, Gust_Min,""
						"" Gust_Max, Date ""
						""FROM %s WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q'""
						"" AND Date<='%q') ORDER BY Date ASC"",
						dbasetable.c_str(), idx, szDateStart.c_str(), szDateEnd.c_str());
					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							root[""result""][ii][""d""] = sd[5].substr(0, 16);
							root[""result""][ii][""di""] = sd[0];

							int intSpeed = atoi(sd[2].c_str());
							int intGust = atoi(sd[4].c_str());
							if (m_sql.m_windunit != WINDUNIT_Beaufort)
							{
								sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
								root[""result""][ii][""sp""] = szTmp;
								sprintf(szTmp, ""%.1f"", float(intGust) * m_sql.m_windscale);
								root[""result""][ii][""gu""] = szTmp;
							}
							else
							{
								float windspeedms = float(intSpeed)*0.1f;
								float windgustms = float(intGust)*0.1f;
								sprintf(szTmp, ""%d"", MStoBeaufort(windspeedms));
								root[""result""][ii][""sp""] = szTmp;
								sprintf(szTmp, ""%d"", MStoBeaufort(windgustms));
								root[""result""][ii][""gu""] = szTmp;
							}
							ii++;
						}
					}
					result = m_sql.safe_query(
						""SELECT AVG(Direction), MIN(Speed), MAX(Speed), MIN(Gust), MAX(Gust) FROM Wind WHERE (DeviceRowID==%"" PRIu64 "" AND Date>='%q') ORDER BY Date ASC"",
						idx, szDateEnd.c_str());
					if (!result.empty())
					{
						std::vector<std::string> sd = result[0];

						root[""result""][ii][""d""] = szDateEnd;
						root[""result""][ii][""di""] = sd[0];

						int intSpeed = atoi(sd[2].c_str());
						int intGust = atoi(sd[4].c_str());
						if (m_sql.m_windunit != WINDUNIT_Beaufort)
						{
							sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
							root[""result""][ii][""sp""] = szTmp;
							sprintf(szTmp, ""%.1f"", float(intGust) * m_sql.m_windscale);
							root[""result""][ii][""gu""] = szTmp;
						}
						else
						{
							float windspeedms = float(intSpeed)*0.1f;
							float windgustms = float(intGust)*0.1f;
							sprintf(szTmp, ""%d"", MStoBeaufort(windspeedms));
							root[""result""][ii][""sp""] = szTmp;
							sprintf(szTmp, ""%d"", MStoBeaufort(windgustms));
							root[""result""][ii][""gu""] = szTmp;
						}
						ii++;
					}
				}
			}//custom range
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,244544569021256507749133743229435391406,,
"		void CWebServer::RType_LightLog(WebEmSession & session, const request& req, Json::Value &root)
		{
			uint64_t idx = 0;
			if (request::findValue(&req, ""idx"") != """")
			{
				idx = std::strtoull(request::findValue(&req, ""idx"").c_str(), nullptr, 10);
			}
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT Type, SubType, SwitchType, Options FROM DeviceStatus WHERE (ID == %"" PRIu64 "")"",
				idx);
			if (result.empty())
				return;

			unsigned char dType = atoi(result[0][0].c_str());
			unsigned char dSubType = atoi(result[0][1].c_str());
			_eSwitchType switchtype = (_eSwitchType)atoi(result[0][2].c_str());
			std::map<std::string, std::string> options = m_sql.BuildDeviceOptions(result[0][3].c_str());

			if (
				(dType != pTypeLighting1) &&
				(dType != pTypeLighting2) &&
				(dType != pTypeLighting3) &&
				(dType != pTypeLighting4) &&
				(dType != pTypeLighting5) &&
				(dType != pTypeLighting6) &&
				(dType != pTypeFan) &&
				(dType != pTypeColorSwitch) &&
				(dType != pTypeSecurity1) &&
				(dType != pTypeSecurity2) &&
				(dType != pTypeEvohome) &&
				(dType != pTypeEvohomeRelay) &&
				(dType != pTypeCurtain) &&
				(dType != pTypeBlinds) &&
				(dType != pTypeRFY) &&
				(dType != pTypeRego6XXValue) &&
				(dType != pTypeChime) &&
				(dType != pTypeThermostat2) &&
				(dType != pTypeThermostat3) &&
				(dType != pTypeThermostat4) &&
				(dType != pTypeRemote) &&
				(dType != pTypeGeneralSwitch) &&
				(dType != pTypeHomeConfort) &&
				(dType != pTypeFS20) &&
				(!((dType == pTypeRadiator1) && (dSubType == sTypeSmartwaresSwitchRadiator)))
				)
				return; //no light device! we should not be here!

			root[""status""] = ""OK"";
			root[""title""] = ""LightLog"";

			result = m_sql.safe_query(""SELECT ROWID, nValue, sValue, Date FROM LightingLog WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date DESC"", idx);
			if (!result.empty())
			{
				std::map<std::string, std::string> selectorStatuses;
				if (switchtype == STYPE_Selector) {
					GetSelectorSwitchStatuses(options, selectorStatuses);
				}

				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					int nValue = atoi(sd[1].c_str());
					std::string sValue = sd[2];

					if ((switchtype == STYPE_Media) && (sValue == ""0"")) continue;

					root[""result""][ii][""idx""] = sd[0];

					std::string lstatus = """";
					std::string ldata = """";
					int llevel = 0;
					bool bHaveDimmer = false;
					bool bHaveSelector = false;
					bool bHaveGroupCmd = false;
					int maxDimLevel = 0;

					if (switchtype == STYPE_Media) {
						lstatus = sValue;
						ldata = lstatus;

					}
					else if (switchtype == STYPE_Selector)
					{
						if (ii == 0) {
							bHaveSelector = true;
							maxDimLevel = selectorStatuses.size();
						}
						if (!selectorStatuses.empty()) {

							std::string sLevel = selectorStatuses[sValue];
							ldata = sLevel;
							lstatus = ""Set Level: "" + sLevel;
							llevel = atoi(sValue.c_str());
						}
					}
					else {
						GetLightStatus(dType, dSubType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);
						ldata = lstatus;
					}

					if (ii == 0)
					{
						root[""HaveDimmer""] = bHaveDimmer;
						root[""result""][ii][""MaxDimLevel""] = maxDimLevel;
						root[""HaveGroupCmd""] = bHaveGroupCmd;
						root[""HaveSelector""] = bHaveSelector;
					}

					root[""result""][ii][""Date""] = sd[3];
					root[""result""][ii][""Data""] = ldata;
					root[""result""][ii][""Status""] = lstatus;
					root[""result""][ii][""Level""] = llevel;

					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,157807416036109456307274036338704294781,,
"		void CWebServer::RType_Mobiles(WebEmSession & session, const request& req, Json::Value &root)
		{
			bool bHaveUser = (session.username != """");
			int urights = 3;
			if (bHaveUser)
			{
				int iUser = FindUser(session.username.c_str());
				if (iUser != -1)
					urights = static_cast<int>(m_users[iUser].userrights);
			}
			if (urights < 2)
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""Mobiles"";

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Active, Name, UUID, LastUpdate, DeviceType FROM MobileDevices ORDER BY Name ASC"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Enabled""] = (sd[1] == ""1"") ? ""true"" : ""false"";
					root[""result""][ii][""Name""] = sd[2];
					root[""result""][ii][""UUID""] = sd[3];
					root[""result""][ii][""LastUpdate""] = sd[4];
					root[""result""][ii][""DeviceType""] = sd[5];
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,179597872139354215929085528913815886466,,
"		void CWebServer::RType_SceneLog(WebEmSession & session, const request& req, Json::Value &root)
		{
			uint64_t idx = 0;
			if (request::findValue(&req, ""idx"") != """")
			{
				idx = std::strtoull(request::findValue(&req, ""idx"").c_str(), nullptr, 10);
			}
			std::vector<std::vector<std::string> > result;

			root[""status""] = ""OK"";
			root[""title""] = ""SceneLog"";

			result = m_sql.safe_query(""SELECT ROWID, nValue, Date FROM SceneLog WHERE (SceneRowID==%"" PRIu64 "") ORDER BY Date DESC"", idx);
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					int nValue = atoi(sd[1].c_str());
					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Date""] = sd[2];
					root[""result""][ii][""Data""] = (nValue == 0) ? ""Off"" : ""On"";
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,298966562760950017335871731717985874912,,
"		void CWebServer::RType_SetSharedUserDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string idx = request::findValue(&req, ""idx"");
			std::string userdevices = request::findValue(&req, ""devices"");
			if (idx.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""SetSharedUserDevices"";
			std::vector<std::string> strarray;
			StringSplit(userdevices, "";"", strarray);

			m_sql.safe_query(""DELETE FROM SharedDevices WHERE (SharedUserID == '%q')"", idx.c_str());

			int nDevices = static_cast<int>(strarray.size());
			for (int ii = 0; ii < nDevices; ii++)
			{
				m_sql.safe_query(""INSERT INTO SharedDevices (SharedUserID,DeviceRowID) VALUES ('%q','%q')"", idx.c_str(), strarray[ii].c_str());
			}
			LoadUsers();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,138285106417124473995998618580092391671,,
"		void CWebServer::RType_SetUsed(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			std::string deviceid = request::findValue(&req, ""deviceid"");
			std::string name = request::findValue(&req, ""name"");
			std::string description = request::findValue(&req, ""description"");
			std::string sused = request::findValue(&req, ""used"");
			std::string sswitchtype = request::findValue(&req, ""switchtype"");
			std::string maindeviceidx = request::findValue(&req, ""maindeviceidx"");
			std::string addjvalue = request::findValue(&req, ""addjvalue"");
			std::string addjmulti = request::findValue(&req, ""addjmulti"");
			std::string addjvalue2 = request::findValue(&req, ""addjvalue2"");
			std::string addjmulti2 = request::findValue(&req, ""addjmulti2"");
			std::string setPoint = request::findValue(&req, ""setpoint"");
			std::string state = request::findValue(&req, ""state"");
			std::string mode = request::findValue(&req, ""mode"");
			std::string until = request::findValue(&req, ""until"");
			std::string clock = request::findValue(&req, ""clock"");
			std::string tmode = request::findValue(&req, ""tmode"");
			std::string fmode = request::findValue(&req, ""fmode"");
			std::string sCustomImage = request::findValue(&req, ""customimage"");

			std::string strunit = request::findValue(&req, ""unit"");
			std::string strParam1 = base64_decode(request::findValue(&req, ""strparam1""));
			std::string strParam2 = base64_decode(request::findValue(&req, ""strparam2""));
			std::string tmpstr = request::findValue(&req, ""protected"");
			bool bHasstrParam1 = request::hasValue(&req, ""strparam1"");
			int iProtected = (tmpstr == ""true"") ? 1 : 0;

			std::string sOptions = base64_decode(request::findValue(&req, ""options""));
			std::string devoptions = CURLEncode::URLDecode(request::findValue(&req, ""devoptions""));
			std::string EnergyMeterMode = CURLEncode::URLDecode(request::findValue(&req, ""EnergyMeterMode""));

			char szTmp[200];

			bool bHaveUser = (session.username != """");
			int iUser = -1;
			if (bHaveUser)
			{
				iUser = FindUser(session.username.c_str());
			}

			int switchtype = -1;
			if (sswitchtype != """")
				switchtype = atoi(sswitchtype.c_str());

			if ((idx.empty()) || (sused.empty()))
				return;
			int used = (sused == ""true"") ? 1 : 0;
			if (maindeviceidx != """")
				used = 0;

			int CustomImage = 0;
			if (sCustomImage != """")
				CustomImage = atoi(sCustomImage.c_str());

			name = stdstring_trim(name);

			description = stdstring_trim(description);

			std::vector<std::vector<std::string> > result;

			result = m_sql.safe_query(""SELECT Type,SubType,HardwareID FROM DeviceStatus WHERE (ID == '%q')"", idx.c_str());
			if (result.empty())
				return;
			std::vector<std::string> sd = result[0];

			unsigned char dType = atoi(sd[0].c_str());
			int HwdID = atoi(sd[2].c_str());
			std::string sHwdID = sd[2];

			if (setPoint != """" || state != """")
			{
				double tempcelcius = atof(setPoint.c_str());
				if (m_sql.m_tempunit == TEMPUNIT_F)
				{
					tempcelcius = ConvertToCelsius(tempcelcius);
				}
				sprintf(szTmp, ""%.2f"", tempcelcius);

				if (dType != pTypeEvohomeZone && dType != pTypeEvohomeWater)//sql update now done in setsetpoint for evohome devices
				{
					m_sql.safe_query(""UPDATE DeviceStatus SET Used=%d, sValue='%q' WHERE (ID == '%q')"",
						used, szTmp, idx.c_str());
				}
			}
			if (name.empty())
			{
				m_sql.safe_query(""UPDATE DeviceStatus SET Used=%d WHERE (ID == '%q')"",
					used, idx.c_str());
			}
			else
			{
				if (switchtype == -1)
				{
					m_sql.safe_query(""UPDATE DeviceStatus SET Used=%d, Name='%q', Description='%q' WHERE (ID == '%q')"",
						used, name.c_str(), description.c_str(), idx.c_str());
				}
				else
				{
					m_sql.safe_query(
						""UPDATE DeviceStatus SET Used=%d, Name='%q', Description='%q', SwitchType=%d, CustomImage=%d WHERE (ID == '%q')"",
						used, name.c_str(), description.c_str(), switchtype, CustomImage, idx.c_str());
				}
			}

			if (bHasstrParam1)
			{
				m_sql.safe_query(""UPDATE DeviceStatus SET StrParam1='%q', StrParam2='%q' WHERE (ID == '%q')"",
					strParam1.c_str(), strParam2.c_str(), idx.c_str());
			}

			m_sql.safe_query(""UPDATE DeviceStatus SET Protected=%d WHERE (ID == '%q')"", iProtected, idx.c_str());

			if (!setPoint.empty() || !state.empty())
			{
				int urights = 3;
				if (bHaveUser)
				{
					int iUser = FindUser(session.username.c_str());
					if (iUser != -1)
					{
						urights = static_cast<int>(m_users[iUser].userrights);
						_log.Log(LOG_STATUS, ""User: %s initiated a SetPoint command"", m_users[iUser].Username.c_str());
					}
				}
				if (urights < 1)
					return;
				if (dType == pTypeEvohomeWater)
					m_mainworker.SetSetPoint(idx, (state == ""On"") ? 1.0f : 0.0f, mode, until);//FIXME float not guaranteed precise?
				else if (dType == pTypeEvohomeZone)
					m_mainworker.SetSetPoint(idx, static_cast<float>(atof(setPoint.c_str())), mode, until);
				else
					m_mainworker.SetSetPoint(idx, static_cast<float>(atof(setPoint.c_str())));
			}
			else if (!clock.empty())
			{
				int urights = 3;
				if (bHaveUser)
				{
					int iUser = FindUser(session.username.c_str());
					if (iUser != -1)
					{
						urights = static_cast<int>(m_users[iUser].userrights);
						_log.Log(LOG_STATUS, ""User: %s initiated a SetClock command"", m_users[iUser].Username.c_str());
					}
				}
				if (urights < 1)
					return;
				m_mainworker.SetClock(idx, clock);
			}
			else if (!tmode.empty())
			{
				int urights = 3;
				if (bHaveUser)
				{
					int iUser = FindUser(session.username.c_str());
					if (iUser != -1)
					{
						urights = static_cast<int>(m_users[iUser].userrights);
						_log.Log(LOG_STATUS, ""User: %s initiated a Thermostat Mode command"", m_users[iUser].Username.c_str());
					}
				}
				if (urights < 1)
					return;
				m_mainworker.SetZWaveThermostatMode(idx, atoi(tmode.c_str()));
			}
			else if (!fmode.empty())
			{
				int urights = 3;
				if (bHaveUser)
				{
					int iUser = FindUser(session.username.c_str());
					if (iUser != -1)
					{
						urights = static_cast<int>(m_users[iUser].userrights);
						_log.Log(LOG_STATUS, ""User: %s initiated a Thermostat Fan Mode command"", m_users[iUser].Username.c_str());
					}
				}
				if (urights < 1)
					return;
				m_mainworker.SetZWaveThermostatFanMode(idx, atoi(fmode.c_str()));
			}

			if (!strunit.empty())
			{
				bool bUpdateUnit = true;
#ifdef ENABLE_PYTHON
				std::vector<std::vector<std::string> > result;
				result = m_sql.safe_query(""SELECT Type FROM Hardware WHERE (ID == %d)"", HwdID);
				if (!result.empty())
				{
					std::vector<std::string> sd = result[0];
					_eHardwareTypes Type = (_eHardwareTypes)atoi(sd[0].c_str());
					if (Type == HTYPE_PythonPlugin)
					{
						bUpdateUnit = false;
						_log.Log(LOG_ERROR, ""CWebServer::RType_SetUsed: Not allowed to change unit of device owned by plugin %u!"", HwdID);
					}
				}
#endif
				if (bUpdateUnit)
				{
					m_sql.safe_query(""UPDATE DeviceStatus SET Unit='%q' WHERE (ID == '%q')"",
						strunit.c_str(), idx.c_str());
				}
			}
			if (!deviceid.empty())
			{
				m_sql.safe_query(""UPDATE DeviceStatus SET DeviceID='%q' WHERE (ID == '%q')"",
					deviceid.c_str(), idx.c_str());
			}
			if (!addjvalue.empty())
			{
				double faddjvalue = atof(addjvalue.c_str());
				m_sql.safe_query(""UPDATE DeviceStatus SET AddjValue=%f WHERE (ID == '%q')"",
					faddjvalue, idx.c_str());
			}
			if (!addjmulti.empty())
			{
				double faddjmulti = atof(addjmulti.c_str());
				if (faddjmulti == 0)
					faddjmulti = 1;
				m_sql.safe_query(""UPDATE DeviceStatus SET AddjMulti=%f WHERE (ID == '%q')"",
					faddjmulti, idx.c_str());
			}
			if (!addjvalue2.empty())
			{
				double faddjvalue2 = atof(addjvalue2.c_str());
				m_sql.safe_query(""UPDATE DeviceStatus SET AddjValue2=%f WHERE (ID == '%q')"",
					faddjvalue2, idx.c_str());
			}
			if (!addjmulti2.empty())
			{
				double faddjmulti2 = atof(addjmulti2.c_str());
				if (faddjmulti2 == 0)
					faddjmulti2 = 1;
				m_sql.safe_query(""UPDATE DeviceStatus SET AddjMulti2=%f WHERE (ID == '%q')"",
					faddjmulti2, idx.c_str());
			}
			if (!EnergyMeterMode.empty())
			{
				auto options = m_sql.GetDeviceOptions(idx);
				options[""EnergyMeterMode""] = EnergyMeterMode;
				uint64_t ullidx = std::strtoull(idx.c_str(), nullptr, 10);
				m_sql.SetDeviceOptions(ullidx, options);
			}

			if (!devoptions.empty())
			{
				m_sql.safe_query(""UPDATE DeviceStatus SET Options='%q' WHERE (ID == '%q')"", devoptions.c_str(), idx.c_str());
			}

			if (used == 0)
			{
				bool bRemoveSubDevices = (request::findValue(&req, ""RemoveSubDevices"") == ""true"");

				if (bRemoveSubDevices)
				{
					m_sql.safe_query(""DELETE FROM LightSubDevices WHERE (DeviceRowID == '%q')"", idx.c_str());
				}
				m_sql.safe_query(""DELETE FROM LightSubDevices WHERE (ParentID == '%q')"", idx.c_str());

				m_sql.safe_query(""DELETE FROM Timers WHERE (DeviceRowID == '%q')"", idx.c_str());
			}

			if (!sOptions.empty())
			{
				uint64_t ullidx = std::strtoull(idx.c_str(), nullptr, 10);
				m_sql.SetDeviceOptions(ullidx, m_sql.BuildDeviceOptions(sOptions, false));
			}

			if (maindeviceidx != """")
			{
				if (maindeviceidx != idx)
				{
					result = m_sql.safe_query(""SELECT ID FROM LightSubDevices WHERE (DeviceRowID=='%q') AND (ParentID =='%q')"",
						idx.c_str(), maindeviceidx.c_str());
					if (result.empty())
					{
						m_sql.safe_query(
							""INSERT INTO LightSubDevices (DeviceRowID, ParentID) VALUES ('%q','%q')"",
							idx.c_str(),
							maindeviceidx.c_str()
						);
					}
				}
			}
			if ((used == 0) && (maindeviceidx.empty()))
			{
				m_sql.DeleteDevices(idx);
			}
			else
			{
#ifdef ENABLE_PYTHON
				m_mainworker.m_pluginsystem.DeviceModified(atoi(idx.c_str()));
#endif
			}
			if (!result.empty())
			{
				root[""status""] = ""OK"";
				root[""title""] = ""SetUsed"";
			}
			if (m_sql.m_bEnableEventSystem)
				m_mainworker.m_eventsystem.GetCurrentStates();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,317514930796263943813055144836144427900,,
"		void CWebServer::RType_Settings(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::vector<std::vector<std::string> > result;
			char szTmp[100];

			result = m_sql.safe_query(""SELECT Key, nValue, sValue FROM Preferences"");
			if (result.empty())
				return;
			root[""status""] = ""OK"";
			root[""title""] = ""settings"";
#ifndef NOCLOUD
			root[""cloudenabled""] = true;
#else
			root[""cloudenabled""] = false;
#endif

			for (const auto & itt : result)
			{
				std::vector<std::string> sd = itt;
				std::string Key = sd[0];
				int nValue = atoi(sd[1].c_str());
				std::string sValue = sd[2];

				if (Key == ""Location"")
				{
					std::vector<std::string> strarray;
					StringSplit(sValue, "";"", strarray);

					if (strarray.size() == 2)
					{
						root[""Location""][""Latitude""] = strarray[0];
						root[""Location""][""Longitude""] = strarray[1];
					}
				}
				/* RK: notification settings */
				if (m_notifications.IsInConfig(Key)) {
					if (sValue.empty() && nValue > 0) {
						root[Key] = nValue;
					}
					else {
						root[Key] = sValue;
					}
				}
				else if (Key == ""DashboardType"")
				{
					root[""DashboardType""] = nValue;
				}
				else if (Key == ""MobileType"")
				{
					root[""MobileType""] = nValue;
				}
				else if (Key == ""LightHistoryDays"")
				{
					root[""LightHistoryDays""] = nValue;
				}
				else if (Key == ""5MinuteHistoryDays"")
				{
					root[""ShortLogDays""] = nValue;
				}
				else if (Key == ""ShortLogInterval"")
				{
					root[""ShortLogInterval""] = nValue;
				}
				else if (Key == ""WebUserName"")
				{
					root[""WebUserName""] = base64_decode(sValue);
				}
				else if (Key == ""SecPassword"")
				{
					root[""SecPassword""] = sValue;
				}
				else if (Key == ""ProtectionPassword"")
				{
					root[""ProtectionPassword""] = sValue;
				}
				else if (Key == ""WebLocalNetworks"")
				{
					root[""WebLocalNetworks""] = sValue;
				}
				else if (Key == ""WebRemoteProxyIPs"")
				{
					root[""WebRemoteProxyIPs""] = sValue;
				}
				else if (Key == ""RandomTimerFrame"")
				{
					root[""RandomTimerFrame""] = nValue;
				}
				else if (Key == ""MeterDividerEnergy"")
				{
					root[""EnergyDivider""] = nValue;
				}
				else if (Key == ""MeterDividerGas"")
				{
					root[""GasDivider""] = nValue;
				}
				else if (Key == ""MeterDividerWater"")
				{
					root[""WaterDivider""] = nValue;
				}
				else if (Key == ""ElectricVoltage"")
				{
					root[""ElectricVoltage""] = nValue;
				}
				else if (Key == ""CM113DisplayType"")
				{
					root[""CM113DisplayType""] = nValue;
				}
				else if (Key == ""UseAutoUpdate"")
				{
					root[""UseAutoUpdate""] = nValue;
				}
				else if (Key == ""UseAutoBackup"")
				{
					root[""UseAutoBackup""] = nValue;
				}
				else if (Key == ""Rego6XXType"")
				{
					root[""Rego6XXType""] = nValue;
				}
				else if (Key == ""CostEnergy"")
				{
					sprintf(szTmp, ""%.4f"", (float)(nValue) / 10000.0f);
					root[""CostEnergy""] = szTmp;
				}
				else if (Key == ""CostEnergyT2"")
				{
					sprintf(szTmp, ""%.4f"", (float)(nValue) / 10000.0f);
					root[""CostEnergyT2""] = szTmp;
				}
				else if (Key == ""CostEnergyR1"")
				{
					sprintf(szTmp, ""%.4f"", (float)(nValue) / 10000.0f);
					root[""CostEnergyR1""] = szTmp;
				}
				else if (Key == ""CostEnergyR2"")
				{
					sprintf(szTmp, ""%.4f"", (float)(nValue) / 10000.0f);
					root[""CostEnergyR2""] = szTmp;
				}
				else if (Key == ""CostGas"")
				{
					sprintf(szTmp, ""%.4f"", (float)(nValue) / 10000.0f);
					root[""CostGas""] = szTmp;
				}
				else if (Key == ""CostWater"")
				{
					sprintf(szTmp, ""%.4f"", (float)(nValue) / 10000.0f);
					root[""CostWater""] = szTmp;
				}
				else if (Key == ""ActiveTimerPlan"")
				{
					root[""ActiveTimerPlan""] = nValue;
				}
				else if (Key == ""DoorbellCommand"")
				{
					root[""DoorbellCommand""] = nValue;
				}
				else if (Key == ""SmartMeterType"")
				{
					root[""SmartMeterType""] = nValue;
				}
				else if (Key == ""EnableTabFloorplans"")
				{
					root[""EnableTabFloorplans""] = nValue;
				}
				else if (Key == ""EnableTabLights"")
				{
					root[""EnableTabLights""] = nValue;
				}
				else if (Key == ""EnableTabTemp"")
				{
					root[""EnableTabTemp""] = nValue;
				}
				else if (Key == ""EnableTabWeather"")
				{
					root[""EnableTabWeather""] = nValue;
				}
				else if (Key == ""EnableTabUtility"")
				{
					root[""EnableTabUtility""] = nValue;
				}
				else if (Key == ""EnableTabScenes"")
				{
					root[""EnableTabScenes""] = nValue;
				}
				else if (Key == ""EnableTabCustom"")
				{
					root[""EnableTabCustom""] = nValue;
				}
				else if (Key == ""NotificationSensorInterval"")
				{
					root[""NotificationSensorInterval""] = nValue;
				}
				else if (Key == ""NotificationSwitchInterval"")
				{
					root[""NotificationSwitchInterval""] = nValue;
				}
				else if (Key == ""RemoteSharedPort"")
				{
					root[""RemoteSharedPort""] = nValue;
				}
				else if (Key == ""Language"")
				{
					root[""Language""] = sValue;
				}
				else if (Key == ""Title"")
				{
					root[""Title""] = sValue;
				}
				else if (Key == ""WindUnit"")
				{
					root[""WindUnit""] = nValue;
				}
				else if (Key == ""TempUnit"")
				{
					root[""TempUnit""] = nValue;
				}
				else if (Key == ""WeightUnit"")
				{
					root[""WeightUnit""] = nValue;
				}
				else if (Key == ""AuthenticationMethod"")
				{
					root[""AuthenticationMethod""] = nValue;
				}
				else if (Key == ""ReleaseChannel"")
				{
					root[""ReleaseChannel""] = nValue;
				}
				else if (Key == ""RaspCamParams"")
				{
					root[""RaspCamParams""] = sValue;
				}
				else if (Key == ""UVCParams"")
				{
					root[""UVCParams""] = sValue;
				}
				else if (Key == ""AcceptNewHardware"")
				{
					root[""AcceptNewHardware""] = nValue;
				}
				else if (Key == ""HideDisabledHardwareSensors"")
				{
					root[""HideDisabledHardwareSensors""] = nValue;
				}
				else if (Key == ""ShowUpdateEffect"")
				{
					root[""ShowUpdateEffect""] = nValue;
				}
				else if (Key == ""DegreeDaysBaseTemperature"")
				{
					root[""DegreeDaysBaseTemperature""] = sValue;
				}
				else if (Key == ""EnableEventScriptSystem"")
				{
					root[""EnableEventScriptSystem""] = nValue;
				}
				else if (Key == ""DisableDzVentsSystem"")
				{
					root[""DisableDzVentsSystem""] = nValue;
				}
				else if (Key == ""DzVentsLogLevel"")
				{
					root[""DzVentsLogLevel""] = nValue;
				}
				else if (Key == ""LogEventScriptTrigger"")
				{
					root[""LogEventScriptTrigger""] = nValue;
				}
				else if (Key == ""(1WireSensorPollPeriod"")
				{
					root[""1WireSensorPollPeriod""] = nValue;
				}
				else if (Key == ""(1WireSwitchPollPeriod"")
				{
					root[""1WireSwitchPollPeriod""] = nValue;
				}
				else if (Key == ""SecOnDelay"")
				{
					root[""SecOnDelay""] = nValue;
				}
				else if (Key == ""AllowWidgetOrdering"")
				{
					root[""AllowWidgetOrdering""] = nValue;
				}
				else if (Key == ""FloorplanPopupDelay"")
				{
					root[""FloorplanPopupDelay""] = nValue;
				}
				else if (Key == ""FloorplanFullscreenMode"")
				{
					root[""FloorplanFullscreenMode""] = nValue;
				}
				else if (Key == ""FloorplanAnimateZoom"")
				{
					root[""FloorplanAnimateZoom""] = nValue;
				}
				else if (Key == ""FloorplanShowSensorValues"")
				{
					root[""FloorplanShowSensorValues""] = nValue;
				}
				else if (Key == ""FloorplanShowSwitchValues"")
				{
					root[""FloorplanShowSwitchValues""] = nValue;
				}
				else if (Key == ""FloorplanShowSceneNames"")
				{
					root[""FloorplanShowSceneNames""] = nValue;
				}
				else if (Key == ""FloorplanRoomColour"")
				{
					root[""FloorplanRoomColour""] = sValue;
				}
				else if (Key == ""FloorplanActiveOpacity"")
				{
					root[""FloorplanActiveOpacity""] = nValue;
				}
				else if (Key == ""FloorplanInactiveOpacity"")
				{
					root[""FloorplanInactiveOpacity""] = nValue;
				}
				else if (Key == ""SensorTimeout"")
				{
					root[""SensorTimeout""] = nValue;
				}
				else if (Key == ""BatteryLowNotification"")
				{
					root[""BatterLowLevel""] = nValue;
				}
				else if (Key == ""WebTheme"")
				{
					root[""WebTheme""] = sValue;
				}
#ifndef NOCLOUD
				else if (Key == ""MyDomoticzInstanceId"") {
					root[""MyDomoticzInstanceId""] = sValue;
				}
				else if (Key == ""MyDomoticzUserId"") {
					root[""MyDomoticzUserId""] = sValue;
				}
				else if (Key == ""MyDomoticzPassword"") {
					root[""MyDomoticzPassword""] = sValue;
				}
				else if (Key == ""MyDomoticzSubsystems"") {
					root[""MyDomoticzSubsystems""] = nValue;
				}
#endif
				else if (Key == ""MyDomoticzSubsystems"") {
					root[""MyDomoticzSubsystems""] = nValue;
				}
				else if (Key == ""SendErrorsAsNotification"") {
					root[""SendErrorsAsNotification""] = nValue;
				}
				else if (Key == ""DeltaTemperatureLog"") {
					root[Key] = sValue;
				}
				else if (Key == ""IFTTTEnabled"") {
					root[""IFTTTEnabled""] = nValue;
				}
				else if (Key == ""IFTTTAPI"") {
					root[""IFTTTAPI""] = sValue;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,189471541050943128321802712493222908544,,
"		void CWebServer::RType_TextLog(WebEmSession & session, const request& req, Json::Value &root)
		{
			uint64_t idx = 0;
			if (request::findValue(&req, ""idx"") != """")
			{
				idx = std::strtoull(request::findValue(&req, ""idx"").c_str(), nullptr, 10);
			}
			std::vector<std::vector<std::string> > result;

			root[""status""] = ""OK"";
			root[""title""] = ""TextLog"";

			result = m_sql.safe_query(""SELECT ROWID, sValue, Date FROM LightingLog WHERE (DeviceRowID==%"" PRIu64 "") ORDER BY Date DESC"",
				idx);
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Date""] = sd[2];
					root[""result""][ii][""Data""] = sd[1];
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,97111795116398762761528613593585823386,,
"		void CWebServer::RType_TransferDevice(WebEmSession & session, const request& req, Json::Value &root)
		{
			std::string sidx = request::findValue(&req, ""idx"");
			if (sidx.empty())
				return;

			std::string newidx = request::findValue(&req, ""newidx"");
			if (newidx.empty())
				return;

			std::vector<std::vector<std::string> > result;


			time_t now = mytime(NULL);
			struct tm tm1;
			localtime_r(&now, &tm1);
			struct tm LastUpdateTime_A;
			struct tm LastUpdateTime_B;

			result = m_sql.safe_query(
				""SELECT A.LastUpdate, B.LastUpdate FROM DeviceStatus as A, DeviceStatus as B WHERE (A.ID == '%q') AND (B.ID == '%q')"",
				sidx.c_str(), newidx.c_str());
			if (result.empty())
				return;

			std::string sLastUpdate_A = result[0][0];
			std::string sLastUpdate_B = result[0][1];

			time_t timeA, timeB;
			ParseSQLdatetime(timeA, LastUpdateTime_A, sLastUpdate_A, tm1.tm_isdst);
			ParseSQLdatetime(timeB, LastUpdateTime_B, sLastUpdate_B, tm1.tm_isdst);

			if (timeA < timeB)
			{
				sidx.swap(newidx);
			}

			result = m_sql.safe_query(
				""SELECT HardwareID, DeviceID, Unit, Name, Type, SubType, SignalLevel, BatteryLevel, nValue, sValue FROM DeviceStatus WHERE (ID == '%q')"",
				newidx.c_str());
			if (result.empty())
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""TransferDevice"";

			m_sql.TransferDevice(newidx, sidx);

			m_sql.DeleteDevices(newidx);

			m_mainworker.m_scheduler.ReloadSchedules();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,184449334688500772307338485883448630057,,
"		void CWebServer::RType_Users(WebEmSession & session, const request& req, Json::Value &root)
		{
			bool bHaveUser = (session.username != """");
			int urights = 3;
			if (bHaveUser)
			{
				int iUser = FindUser(session.username.c_str());
				if (iUser != -1)
					urights = static_cast<int>(m_users[iUser].userrights);
			}
			if (urights < 2)
				return;

			root[""status""] = ""OK"";
			root[""title""] = ""Users"";

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Active, Username, Password, Rights, RemoteSharing, TabsEnabled FROM USERS ORDER BY ID ASC"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Enabled""] = (sd[1] == ""1"") ? ""true"" : ""false"";
					root[""result""][ii][""Username""] = base64_decode(sd[2]);
					root[""result""][ii][""Password""] = sd[3];
					root[""result""][ii][""Rights""] = atoi(sd[4].c_str());
					root[""result""][ii][""RemoteSharing""] = atoi(sd[5].c_str());
					root[""result""][ii][""TabsEnabled""] = atoi(sd[6].c_str());
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,166148269571022843195199987632890041783,,
"		void CWebServer::RegisterCommandCode(const char* idname, webserver_response_function ResponseFunction, bool bypassAuthentication)
		{
			m_webcommands.insert(std::pair<std::string, webserver_response_function >(std::string(idname), ResponseFunction));
			if (bypassAuthentication)
			{
				m_pWebEm->RegisterWhitelistURLString(idname);
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,2015512652454060920035420857543366057,,
"		void CWebServer::RegisterRType(const char* idname, webserver_response_function ResponseFunction)
		{
			m_webrtypes.insert(std::pair<std::string, webserver_response_function >(std::string(idname), ResponseFunction));
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,309002342123945777372280255857996835055,,
"		void CWebServer::ReloadCustomSwitchIcons()
		{
			m_custom_light_icons.clear();
			m_custom_light_icons_lookup.clear();
			std::string sLine = """";

			std::ifstream infile;
			std::string switchlightsfile = szWWWFolder + ""/switch_icons.txt"";
			infile.open(switchlightsfile.c_str());
			if (infile.is_open())
			{
				int index = 0;
				while (!infile.eof())
				{
					getline(infile, sLine);
					if (sLine.size() != 0)
					{
						std::vector<std::string> results;
						StringSplit(sLine, "";"", results);
						if (results.size() == 3)
						{
							_tCustomIcon cImage;
							cImage.idx = index++;
							cImage.RootFile = results[0];
							cImage.Title = results[1];
							cImage.Description = results[2];
							m_custom_light_icons.push_back(cImage);
							m_custom_light_icons_lookup[cImage.idx] = m_custom_light_icons.size() - 1;
						}
					}
				}
				infile.close();
			}
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID,Base,Name,Description FROM CustomImages"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					int ID = atoi(sd[0].c_str());

					_tCustomIcon cImage;
					cImage.idx = 100 + ID;
					cImage.RootFile = sd[1];
					cImage.Title = sd[2];
					cImage.Description = sd[3];

					std::string IconFile16 = cImage.RootFile + "".png"";
					std::string IconFile48On = cImage.RootFile + ""48_On.png"";
					std::string IconFile48Off = cImage.RootFile + ""48_Off.png"";

					std::map<std::string, std::string> _dbImageFiles;
					_dbImageFiles[""IconSmall""] = szWWWFolder + ""/images/"" + IconFile16;
					_dbImageFiles[""IconOn""] = szWWWFolder + ""/images/"" + IconFile48On;
					_dbImageFiles[""IconOff""] = szWWWFolder + ""/images/"" + IconFile48Off;

					for (const auto & iItt : _dbImageFiles)
					{
						std::string TableField = iItt.first;
						std::string IconFile = iItt.second;

						if (!file_exist(IconFile.c_str()))
						{
							std::vector<std::vector<std::string> > result2;
							result2 = m_sql.safe_queryBlob(""SELECT %s FROM CustomImages WHERE ID=%d"", TableField.c_str(), ID);
							if (!result2.empty())
							{
								std::ofstream file;
								file.open(IconFile.c_str(), std::ios::out | std::ios::binary);
								if (!file.is_open())
									return;

								file << result2[0][0];
								file.close();
							}
						}
					}

					m_custom_light_icons.push_back(cImage);
					m_custom_light_icons_lookup[cImage.idx] = m_custom_light_icons.size() - 1;
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,285520992365248360026663711530896169457,,
"		void CWebServer::RemoveSession(const std::string & sessionId) {
			if (sessionId.empty()) {
				return;
			}
			m_sql.safe_query(
				""DELETE FROM UserSessions WHERE SessionID = '%q'"",
				sessionId.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,309817115926846295529665153141469996045,,
"		void CWebServer::RemoveUsersSessions(const std::string& username, const WebEmSession & exceptSession) {
			m_sql.safe_query(""DELETE FROM UserSessions WHERE (Username=='%q') and (SessionID!='%q')"", username.c_str(), exceptSession.id.c_str());
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,175618291267598785212534650041146694639,,
"		void CWebServer::RestoreDatabase(WebEmSession & session, const request& req, std::string & redirect_uri)
		{
			redirect_uri = ""/index.html"";
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string dbasefile = request::findValue(&req, ""dbasefile"");
			if (dbasefile.empty()) {
				return;
			}

			m_mainworker.StopDomoticzHardware();

			m_sql.RestoreDatabase(dbasefile);
			m_mainworker.AddAllDomoticzHardware();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,190394584619419872750402009037833360963,,
"		void CWebServer::SetAuthenticationMethod(const _eAuthenticationMethod amethod)
		{
			if (m_pWebEm == NULL)
				return;
			m_pWebEm->SetAuthenticationMethod(amethod);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,300876852616188633692160758001752021468,,
"		void CWebServer::SetWebCompressionMode(const _eWebCompressionMode gzmode)
		{
			if (m_pWebEm == NULL)
				return;
			m_pWebEm->SetWebCompressionMode(gzmode);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,180385234189785088890225742383580855432,,
"		void CWebServer::SetWebRoot(const std::string &webRoot)
		{
			if (m_pWebEm == NULL)
				return;
			m_pWebEm->SetWebRoot(webRoot);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,83146877540897339355931515695486194177,,
"		void CWebServer::SetWebTheme(const std::string &themename)
		{
			if (m_pWebEm == NULL)
				return;
			m_pWebEm->SetWebTheme(themename);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,229319431120231525678431502113928689568,,
"		bool CWebServer::StartServer(server_settings & settings, const std::string & serverpath, const bool bIgnoreUsernamePassword)
		{
			m_server_alias = (settings.is_secure() == true) ? ""SSL"" : ""HTTP"";

			if (!settings.is_enabled())
				return true;

			ReloadCustomSwitchIcons();

			int tries = 0;
			bool exception = false;

			do {
				try {
					exception = false;
					m_pWebEm = new http::server::cWebem(settings, serverpath.c_str());
				}
				catch (std::exception& e) {
					exception = true;
					switch (tries) {
					case 0:
						settings.listening_address = ""::"";
						break;
					case 1:
						settings.listening_address = ""0.0.0.0"";
						break;
					case 2:
						_log.Log(LOG_ERROR, ""WebServer(%s) startup failed on address %s with port: %s: %s"", m_server_alias.c_str(), settings.listening_address.c_str(), settings.listening_port.c_str(), e.what());
						if (atoi(settings.listening_port.c_str()) < 1024)
							_log.Log(LOG_ERROR, ""WebServer(%s) check privileges for opening ports below 1024"", m_server_alias.c_str());
						else
							_log.Log(LOG_ERROR, ""WebServer(%s) check if no other application is using port: %s"", m_server_alias.c_str(), settings.listening_port.c_str());
						return false;
					}
					tries++;
				}
			} while (exception);

			_log.Log(LOG_STATUS, ""WebServer(%s) started on address: %s with port %s"", m_server_alias.c_str(), settings.listening_address.c_str(), settings.listening_port.c_str());

			m_pWebEm->SetDigistRealm(""Domoticz.com"");
			m_pWebEm->SetSessionStore(this);

			if (!bIgnoreUsernamePassword)
			{
				LoadUsers();
				std::string WebLocalNetworks;
				int nValue;
				if (m_sql.GetPreferencesVar(""WebLocalNetworks"", nValue, WebLocalNetworks))
				{
					std::vector<std::string> strarray;
					StringSplit(WebLocalNetworks, "";"", strarray);
					for (const auto & itt : strarray)
						m_pWebEm->AddLocalNetworks(itt);
					m_pWebEm->AddLocalNetworks("""");
				}
			}

			std::string WebRemoteProxyIPs;
			int nValue;
			if (m_sql.GetPreferencesVar(""WebRemoteProxyIPs"", nValue, WebRemoteProxyIPs))
			{
				std::vector<std::string> strarray;
				StringSplit(WebRemoteProxyIPs, "";"", strarray);
				for (const auto & itt : strarray)
					m_pWebEm->AddRemoteProxyIPs(itt);
			}

			m_pWebEm->RegisterIncludeCode(""switchtypes"", boost::bind(&CWebServer::DisplaySwitchTypesCombo, this, _1));
			m_pWebEm->RegisterIncludeCode(""metertypes"", boost::bind(&CWebServer::DisplayMeterTypesCombo, this, _1));
			m_pWebEm->RegisterIncludeCode(""timertypes"", boost::bind(&CWebServer::DisplayTimerTypesCombo, this, _1));
			m_pWebEm->RegisterIncludeCode(""combolanguage"", boost::bind(&CWebServer::DisplayLanguageCombo, this, _1));

			m_pWebEm->RegisterPageCode(""/json.htm"", boost::bind(&CWebServer::GetJSonPage, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/uploadcustomicon"", boost::bind(&CWebServer::Post_UploadCustomIcon, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/html5.appcache"", boost::bind(&CWebServer::GetAppCache, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/camsnapshot.jpg"", boost::bind(&CWebServer::GetCameraSnapshot, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/backupdatabase.php"", boost::bind(&CWebServer::GetDatabaseBackup, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/raspberry.cgi"", boost::bind(&CWebServer::GetInternalCameraSnapshot, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/uvccapture.cgi"", boost::bind(&CWebServer::GetInternalCameraSnapshot, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/images/floorplans/plan"", boost::bind(&CWebServer::GetFloorplanImage, this, _1, _2, _3));

			m_pWebEm->RegisterActionCode(""storesettings"", boost::bind(&CWebServer::PostSettings, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""setrfxcommode"", boost::bind(&CWebServer::SetRFXCOMMode, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""rfxupgradefirmware"", boost::bind(&CWebServer::RFXComUpgradeFirmware, this, _1, _2, _3));
			RegisterCommandCode(""rfxfirmwaregetpercentage"", boost::bind(&CWebServer::Cmd_RFXComGetFirmwarePercentage, this, _1, _2, _3), true);
			m_pWebEm->RegisterActionCode(""setrego6xxtype"", boost::bind(&CWebServer::SetRego6XXType, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""sets0metertype"", boost::bind(&CWebServer::SetS0MeterType, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""setlimitlesstype"", boost::bind(&CWebServer::SetLimitlessType, this, _1, _2, _3));

			m_pWebEm->RegisterActionCode(""uploadfloorplanimage"", boost::bind(&CWebServer::UploadFloorplanImage, this, _1, _2, _3));


			m_pWebEm->RegisterActionCode(""setopenthermsettings"", boost::bind(&CWebServer::SetOpenThermSettings, this, _1, _2, _3));
			RegisterCommandCode(""sendopenthermcommand"", boost::bind(&CWebServer::Cmd_SendOpenThermCommand, this, _1, _2, _3), true);

			m_pWebEm->RegisterActionCode(""reloadpiface"", boost::bind(&CWebServer::ReloadPiFace, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""setcurrentcostmetertype"", boost::bind(&CWebServer::SetCurrentCostUSBType, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""restoredatabase"", boost::bind(&CWebServer::RestoreDatabase, this, _1, _2, _3));
			m_pWebEm->RegisterActionCode(""sbfspotimportolddata"", boost::bind(&CWebServer::SBFSpotImportOldData, this, _1, _2, _3));

			m_pWebEm->RegisterActionCode(""event_create"", boost::bind(&CWebServer::EventCreate, this, _1, _2, _3));

			RegisterCommandCode(""getlanguage"", boost::bind(&CWebServer::Cmd_GetLanguage, this, _1, _2, _3), true);
			RegisterCommandCode(""getthemes"", boost::bind(&CWebServer::Cmd_GetThemes, this, _1, _2, _3), true);
			RegisterCommandCode(""gettitle"", boost::bind(&CWebServer::Cmd_GetTitle, this, _1, _2, _3), true);

			RegisterCommandCode(""logincheck"", boost::bind(&CWebServer::Cmd_LoginCheck, this, _1, _2, _3), true);
			RegisterCommandCode(""getversion"", boost::bind(&CWebServer::Cmd_GetVersion, this, _1, _2, _3), true);
			RegisterCommandCode(""getlog"", boost::bind(&CWebServer::Cmd_GetLog, this, _1, _2, _3));
			RegisterCommandCode(""clearlog"", boost::bind(&CWebServer::Cmd_ClearLog, this, _1, _2, _3));
			RegisterCommandCode(""getauth"", boost::bind(&CWebServer::Cmd_GetAuth, this, _1, _2, _3), true);
			RegisterCommandCode(""getuptime"", boost::bind(&CWebServer::Cmd_GetUptime, this, _1, _2, _3), true);


			RegisterCommandCode(""gethardwaretypes"", boost::bind(&CWebServer::Cmd_GetHardwareTypes, this, _1, _2, _3));
			RegisterCommandCode(""addhardware"", boost::bind(&CWebServer::Cmd_AddHardware, this, _1, _2, _3));
			RegisterCommandCode(""updatehardware"", boost::bind(&CWebServer::Cmd_UpdateHardware, this, _1, _2, _3));
			RegisterCommandCode(""deletehardware"", boost::bind(&CWebServer::Cmd_DeleteHardware, this, _1, _2, _3));

			RegisterCommandCode(""addcamera"", boost::bind(&CWebServer::Cmd_AddCamera, this, _1, _2, _3));
			RegisterCommandCode(""updatecamera"", boost::bind(&CWebServer::Cmd_UpdateCamera, this, _1, _2, _3));
			RegisterCommandCode(""deletecamera"", boost::bind(&CWebServer::Cmd_DeleteCamera, this, _1, _2, _3));

			RegisterCommandCode(""wolgetnodes"", boost::bind(&CWebServer::Cmd_WOLGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""woladdnode"", boost::bind(&CWebServer::Cmd_WOLAddNode, this, _1, _2, _3));
			RegisterCommandCode(""wolupdatenode"", boost::bind(&CWebServer::Cmd_WOLUpdateNode, this, _1, _2, _3));
			RegisterCommandCode(""wolremovenode"", boost::bind(&CWebServer::Cmd_WOLRemoveNode, this, _1, _2, _3));
			RegisterCommandCode(""wolclearnodes"", boost::bind(&CWebServer::Cmd_WOLClearNodes, this, _1, _2, _3));

			RegisterCommandCode(""mysensorsgetnodes"", boost::bind(&CWebServer::Cmd_MySensorsGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""mysensorsgetchilds"", boost::bind(&CWebServer::Cmd_MySensorsGetChilds, this, _1, _2, _3));
			RegisterCommandCode(""mysensorsupdatenode"", boost::bind(&CWebServer::Cmd_MySensorsUpdateNode, this, _1, _2, _3));
			RegisterCommandCode(""mysensorsremovenode"", boost::bind(&CWebServer::Cmd_MySensorsRemoveNode, this, _1, _2, _3));
			RegisterCommandCode(""mysensorsremovechild"", boost::bind(&CWebServer::Cmd_MySensorsRemoveChild, this, _1, _2, _3));
			RegisterCommandCode(""mysensorsupdatechild"", boost::bind(&CWebServer::Cmd_MySensorsUpdateChild, this, _1, _2, _3));

			RegisterCommandCode(""pingersetmode"", boost::bind(&CWebServer::Cmd_PingerSetMode, this, _1, _2, _3));
			RegisterCommandCode(""pingergetnodes"", boost::bind(&CWebServer::Cmd_PingerGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""pingeraddnode"", boost::bind(&CWebServer::Cmd_PingerAddNode, this, _1, _2, _3));
			RegisterCommandCode(""pingerupdatenode"", boost::bind(&CWebServer::Cmd_PingerUpdateNode, this, _1, _2, _3));
			RegisterCommandCode(""pingerremovenode"", boost::bind(&CWebServer::Cmd_PingerRemoveNode, this, _1, _2, _3));
			RegisterCommandCode(""pingerclearnodes"", boost::bind(&CWebServer::Cmd_PingerClearNodes, this, _1, _2, _3));

			RegisterCommandCode(""kodisetmode"", boost::bind(&CWebServer::Cmd_KodiSetMode, this, _1, _2, _3));
			RegisterCommandCode(""kodigetnodes"", boost::bind(&CWebServer::Cmd_KodiGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""kodiaddnode"", boost::bind(&CWebServer::Cmd_KodiAddNode, this, _1, _2, _3));
			RegisterCommandCode(""kodiupdatenode"", boost::bind(&CWebServer::Cmd_KodiUpdateNode, this, _1, _2, _3));
			RegisterCommandCode(""kodiremovenode"", boost::bind(&CWebServer::Cmd_KodiRemoveNode, this, _1, _2, _3));
			RegisterCommandCode(""kodiclearnodes"", boost::bind(&CWebServer::Cmd_KodiClearNodes, this, _1, _2, _3));
			RegisterCommandCode(""kodimediacommand"", boost::bind(&CWebServer::Cmd_KodiMediaCommand, this, _1, _2, _3));

			RegisterCommandCode(""panasonicsetmode"", boost::bind(&CWebServer::Cmd_PanasonicSetMode, this, _1, _2, _3));
			RegisterCommandCode(""panasonicgetnodes"", boost::bind(&CWebServer::Cmd_PanasonicGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""panasonicaddnode"", boost::bind(&CWebServer::Cmd_PanasonicAddNode, this, _1, _2, _3));
			RegisterCommandCode(""panasonicupdatenode"", boost::bind(&CWebServer::Cmd_PanasonicUpdateNode, this, _1, _2, _3));
			RegisterCommandCode(""panasonicremovenode"", boost::bind(&CWebServer::Cmd_PanasonicRemoveNode, this, _1, _2, _3));
			RegisterCommandCode(""panasonicclearnodes"", boost::bind(&CWebServer::Cmd_PanasonicClearNodes, this, _1, _2, _3));
			RegisterCommandCode(""panasonicmediacommand"", boost::bind(&CWebServer::Cmd_PanasonicMediaCommand, this, _1, _2, _3));

			RegisterCommandCode(""heossetmode"", boost::bind(&CWebServer::Cmd_HEOSSetMode, this, _1, _2, _3));
			RegisterCommandCode(""heosmediacommand"", boost::bind(&CWebServer::Cmd_HEOSMediaCommand, this, _1, _2, _3));

			RegisterCommandCode(""onkyoeiscpcommand"", boost::bind(&CWebServer::Cmd_OnkyoEiscpCommand, this, _1, _2, _3));

			RegisterCommandCode(""bleboxsetmode"", boost::bind(&CWebServer::Cmd_BleBoxSetMode, this, _1, _2, _3));
			RegisterCommandCode(""bleboxgetnodes"", boost::bind(&CWebServer::Cmd_BleBoxGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""bleboxaddnode"", boost::bind(&CWebServer::Cmd_BleBoxAddNode, this, _1, _2, _3));
			RegisterCommandCode(""bleboxremovenode"", boost::bind(&CWebServer::Cmd_BleBoxRemoveNode, this, _1, _2, _3));
			RegisterCommandCode(""bleboxclearnodes"", boost::bind(&CWebServer::Cmd_BleBoxClearNodes, this, _1, _2, _3));
			RegisterCommandCode(""bleboxautosearchingnodes"", boost::bind(&CWebServer::Cmd_BleBoxAutoSearchingNodes, this, _1, _2, _3));
			RegisterCommandCode(""bleboxupdatefirmware"", boost::bind(&CWebServer::Cmd_BleBoxUpdateFirmware, this, _1, _2, _3));

			RegisterCommandCode(""lmssetmode"", boost::bind(&CWebServer::Cmd_LMSSetMode, this, _1, _2, _3));
			RegisterCommandCode(""lmsgetnodes"", boost::bind(&CWebServer::Cmd_LMSGetNodes, this, _1, _2, _3));
			RegisterCommandCode(""lmsgetplaylists"", boost::bind(&CWebServer::Cmd_LMSGetPlaylists, this, _1, _2, _3));
			RegisterCommandCode(""lmsmediacommand"", boost::bind(&CWebServer::Cmd_LMSMediaCommand, this, _1, _2, _3));
			RegisterCommandCode(""lmsdeleteunuseddevices"", boost::bind(&CWebServer::Cmd_LMSDeleteUnusedDevices, this, _1, _2, _3));

			RegisterCommandCode(""savefibarolinkconfig"", boost::bind(&CWebServer::Cmd_SaveFibaroLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""getfibarolinkconfig"", boost::bind(&CWebServer::Cmd_GetFibaroLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""getfibarolinks"", boost::bind(&CWebServer::Cmd_GetFibaroLinks, this, _1, _2, _3));
			RegisterCommandCode(""savefibarolink"", boost::bind(&CWebServer::Cmd_SaveFibaroLink, this, _1, _2, _3));
			RegisterCommandCode(""deletefibarolink"", boost::bind(&CWebServer::Cmd_DeleteFibaroLink, this, _1, _2, _3));

			RegisterCommandCode(""saveinfluxlinkconfig"", boost::bind(&CWebServer::Cmd_SaveInfluxLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""getinfluxlinkconfig"", boost::bind(&CWebServer::Cmd_GetInfluxLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""getinfluxlinks"", boost::bind(&CWebServer::Cmd_GetInfluxLinks, this, _1, _2, _3));
			RegisterCommandCode(""saveinfluxlink"", boost::bind(&CWebServer::Cmd_SaveInfluxLink, this, _1, _2, _3));
			RegisterCommandCode(""deleteinfluxlink"", boost::bind(&CWebServer::Cmd_DeleteInfluxLink, this, _1, _2, _3));

			RegisterCommandCode(""savehttplinkconfig"", boost::bind(&CWebServer::Cmd_SaveHttpLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""gethttplinkconfig"", boost::bind(&CWebServer::Cmd_GetHttpLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""gethttplinks"", boost::bind(&CWebServer::Cmd_GetHttpLinks, this, _1, _2, _3));
			RegisterCommandCode(""savehttplink"", boost::bind(&CWebServer::Cmd_SaveHttpLink, this, _1, _2, _3));
			RegisterCommandCode(""deletehttplink"", boost::bind(&CWebServer::Cmd_DeleteHttpLink, this, _1, _2, _3));

			RegisterCommandCode(""savegooglepubsublinkconfig"", boost::bind(&CWebServer::Cmd_SaveGooglePubSubLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""getgooglepubsublinkconfig"", boost::bind(&CWebServer::Cmd_GetGooglePubSubLinkConfig, this, _1, _2, _3));
			RegisterCommandCode(""getgooglepubsublinks"", boost::bind(&CWebServer::Cmd_GetGooglePubSubLinks, this, _1, _2, _3));
			RegisterCommandCode(""savegooglepubsublink"", boost::bind(&CWebServer::Cmd_SaveGooglePubSubLink, this, _1, _2, _3));
			RegisterCommandCode(""deletegooglepubsublink"", boost::bind(&CWebServer::Cmd_DeleteGooglePubSubLink, this, _1, _2, _3));

			RegisterCommandCode(""getdevicevalueoptions"", boost::bind(&CWebServer::Cmd_GetDeviceValueOptions, this, _1, _2, _3));
			RegisterCommandCode(""getdevicevalueoptionwording"", boost::bind(&CWebServer::Cmd_GetDeviceValueOptionWording, this, _1, _2, _3));

			RegisterCommandCode(""adduservariable"", boost::bind(&CWebServer::Cmd_AddUserVariable, this, _1, _2, _3));
			RegisterCommandCode(""updateuservariable"", boost::bind(&CWebServer::Cmd_UpdateUserVariable, this, _1, _2, _3));
			RegisterCommandCode(""deleteuservariable"", boost::bind(&CWebServer::Cmd_DeleteUserVariable, this, _1, _2, _3));
			RegisterCommandCode(""getuservariables"", boost::bind(&CWebServer::Cmd_GetUserVariables, this, _1, _2, _3));
			RegisterCommandCode(""getuservariable"", boost::bind(&CWebServer::Cmd_GetUserVariable, this, _1, _2, _3));

			RegisterCommandCode(""allownewhardware"", boost::bind(&CWebServer::Cmd_AllowNewHardware, this, _1, _2, _3));

			RegisterCommandCode(""addplan"", boost::bind(&CWebServer::Cmd_AddPlan, this, _1, _2, _3));
			RegisterCommandCode(""updateplan"", boost::bind(&CWebServer::Cmd_UpdatePlan, this, _1, _2, _3));
			RegisterCommandCode(""deleteplan"", boost::bind(&CWebServer::Cmd_DeletePlan, this, _1, _2, _3));
			RegisterCommandCode(""getunusedplandevices"", boost::bind(&CWebServer::Cmd_GetUnusedPlanDevices, this, _1, _2, _3));
			RegisterCommandCode(""addplanactivedevice"", boost::bind(&CWebServer::Cmd_AddPlanActiveDevice, this, _1, _2, _3));
			RegisterCommandCode(""getplandevices"", boost::bind(&CWebServer::Cmd_GetPlanDevices, this, _1, _2, _3));
			RegisterCommandCode(""deleteplandevice"", boost::bind(&CWebServer::Cmd_DeletePlanDevice, this, _1, _2, _3));
			RegisterCommandCode(""setplandevicecoords"", boost::bind(&CWebServer::Cmd_SetPlanDeviceCoords, this, _1, _2, _3));
			RegisterCommandCode(""deleteallplandevices"", boost::bind(&CWebServer::Cmd_DeleteAllPlanDevices, this, _1, _2, _3));
			RegisterCommandCode(""changeplanorder"", boost::bind(&CWebServer::Cmd_ChangePlanOrder, this, _1, _2, _3));
			RegisterCommandCode(""changeplandeviceorder"", boost::bind(&CWebServer::Cmd_ChangePlanDeviceOrder, this, _1, _2, _3));

			RegisterCommandCode(""gettimerplans"", boost::bind(&CWebServer::Cmd_GetTimerPlans, this, _1, _2, _3));
			RegisterCommandCode(""addtimerplan"", boost::bind(&CWebServer::Cmd_AddTimerPlan, this, _1, _2, _3));
			RegisterCommandCode(""updatetimerplan"", boost::bind(&CWebServer::Cmd_UpdateTimerPlan, this, _1, _2, _3));
			RegisterCommandCode(""deletetimerplan"", boost::bind(&CWebServer::Cmd_DeleteTimerPlan, this, _1, _2, _3));
			RegisterCommandCode(""duplicatetimerplan"", boost::bind(&CWebServer::Cmd_DuplicateTimerPlan, this, _1, _2, _3));

			RegisterCommandCode(""getactualhistory"", boost::bind(&CWebServer::Cmd_GetActualHistory, this, _1, _2, _3));
			RegisterCommandCode(""getnewhistory"", boost::bind(&CWebServer::Cmd_GetNewHistory, this, _1, _2, _3));

			RegisterCommandCode(""getconfig"", boost::bind(&CWebServer::Cmd_GetConfig, this, _1, _2, _3), true);
			RegisterCommandCode(""sendnotification"", boost::bind(&CWebServer::Cmd_SendNotification, this, _1, _2, _3));
			RegisterCommandCode(""emailcamerasnapshot"", boost::bind(&CWebServer::Cmd_EmailCameraSnapshot, this, _1, _2, _3));
			RegisterCommandCode(""udevice"", boost::bind(&CWebServer::Cmd_UpdateDevice, this, _1, _2, _3));
			RegisterCommandCode(""udevices"", boost::bind(&CWebServer::Cmd_UpdateDevices, this, _1, _2, _3));
			RegisterCommandCode(""thermostatstate"", boost::bind(&CWebServer::Cmd_SetThermostatState, this, _1, _2, _3));
			RegisterCommandCode(""system_shutdown"", boost::bind(&CWebServer::Cmd_SystemShutdown, this, _1, _2, _3));
			RegisterCommandCode(""system_reboot"", boost::bind(&CWebServer::Cmd_SystemReboot, this, _1, _2, _3));
			RegisterCommandCode(""execute_script"", boost::bind(&CWebServer::Cmd_ExcecuteScript, this, _1, _2, _3));
			RegisterCommandCode(""getcosts"", boost::bind(&CWebServer::Cmd_GetCosts, this, _1, _2, _3));
			RegisterCommandCode(""checkforupdate"", boost::bind(&CWebServer::Cmd_CheckForUpdate, this, _1, _2, _3));
			RegisterCommandCode(""downloadupdate"", boost::bind(&CWebServer::Cmd_DownloadUpdate, this, _1, _2, _3));
			RegisterCommandCode(""downloadready"", boost::bind(&CWebServer::Cmd_DownloadReady, this, _1, _2, _3));
			RegisterCommandCode(""deletedatapoint"", boost::bind(&CWebServer::Cmd_DeleteDatePoint, this, _1, _2, _3));

			RegisterCommandCode(""setactivetimerplan"", boost::bind(&CWebServer::Cmd_SetActiveTimerPlan, this, _1, _2, _3));
			RegisterCommandCode(""addtimer"", boost::bind(&CWebServer::Cmd_AddTimer, this, _1, _2, _3));
			RegisterCommandCode(""updatetimer"", boost::bind(&CWebServer::Cmd_UpdateTimer, this, _1, _2, _3));
			RegisterCommandCode(""deletetimer"", boost::bind(&CWebServer::Cmd_DeleteTimer, this, _1, _2, _3));
			RegisterCommandCode(""enabletimer"", boost::bind(&CWebServer::Cmd_EnableTimer, this, _1, _2, _3));
			RegisterCommandCode(""disabletimer"", boost::bind(&CWebServer::Cmd_DisableTimer, this, _1, _2, _3));
			RegisterCommandCode(""cleartimers"", boost::bind(&CWebServer::Cmd_ClearTimers, this, _1, _2, _3));

			RegisterCommandCode(""addscenetimer"", boost::bind(&CWebServer::Cmd_AddSceneTimer, this, _1, _2, _3));
			RegisterCommandCode(""updatescenetimer"", boost::bind(&CWebServer::Cmd_UpdateSceneTimer, this, _1, _2, _3));
			RegisterCommandCode(""deletescenetimer"", boost::bind(&CWebServer::Cmd_DeleteSceneTimer, this, _1, _2, _3));
			RegisterCommandCode(""enablescenetimer"", boost::bind(&CWebServer::Cmd_EnableSceneTimer, this, _1, _2, _3));
			RegisterCommandCode(""disablescenetimer"", boost::bind(&CWebServer::Cmd_DisableSceneTimer, this, _1, _2, _3));
			RegisterCommandCode(""clearscenetimers"", boost::bind(&CWebServer::Cmd_ClearSceneTimers, this, _1, _2, _3));
			RegisterCommandCode(""getsceneactivations"", boost::bind(&CWebServer::Cmd_GetSceneActivations, this, _1, _2, _3));
			RegisterCommandCode(""addscenecode"", boost::bind(&CWebServer::Cmd_AddSceneCode, this, _1, _2, _3));
			RegisterCommandCode(""removescenecode"", boost::bind(&CWebServer::Cmd_RemoveSceneCode, this, _1, _2, _3));
			RegisterCommandCode(""clearscenecodes"", boost::bind(&CWebServer::Cmd_ClearSceneCodes, this, _1, _2, _3));
			RegisterCommandCode(""renamescene"", boost::bind(&CWebServer::Cmd_RenameScene, this, _1, _2, _3));

			RegisterCommandCode(""setsetpoint"", boost::bind(&CWebServer::Cmd_SetSetpoint, this, _1, _2, _3));
			RegisterCommandCode(""addsetpointtimer"", boost::bind(&CWebServer::Cmd_AddSetpointTimer, this, _1, _2, _3));
			RegisterCommandCode(""updatesetpointtimer"", boost::bind(&CWebServer::Cmd_UpdateSetpointTimer, this, _1, _2, _3));
			RegisterCommandCode(""deletesetpointtimer"", boost::bind(&CWebServer::Cmd_DeleteSetpointTimer, this, _1, _2, _3));
			RegisterCommandCode(""enablesetpointtimer"", boost::bind(&CWebServer::Cmd_EnableSetpointTimer, this, _1, _2, _3));
			RegisterCommandCode(""disablesetpointtimer"", boost::bind(&CWebServer::Cmd_DisableSetpointTimer, this, _1, _2, _3));
			RegisterCommandCode(""clearsetpointtimers"", boost::bind(&CWebServer::Cmd_ClearSetpointTimers, this, _1, _2, _3));

			RegisterCommandCode(""serial_devices"", boost::bind(&CWebServer::Cmd_GetSerialDevices, this, _1, _2, _3));
			RegisterCommandCode(""devices_list"", boost::bind(&CWebServer::Cmd_GetDevicesList, this, _1, _2, _3));
			RegisterCommandCode(""devices_list_onoff"", boost::bind(&CWebServer::Cmd_GetDevicesListOnOff, this, _1, _2, _3));

			RegisterCommandCode(""registerhue"", boost::bind(&CWebServer::Cmd_PhilipsHueRegister, this, _1, _2, _3));

			RegisterCommandCode(""getcustomiconset"", boost::bind(&CWebServer::Cmd_GetCustomIconSet, this, _1, _2, _3));
			RegisterCommandCode(""deletecustomicon"", boost::bind(&CWebServer::Cmd_DeleteCustomIcon, this, _1, _2, _3));
			RegisterCommandCode(""updatecustomicon"", boost::bind(&CWebServer::Cmd_UpdateCustomIcon, this, _1, _2, _3));

			RegisterCommandCode(""renamedevice"", boost::bind(&CWebServer::Cmd_RenameDevice, this, _1, _2, _3));
			RegisterCommandCode(""setunused"", boost::bind(&CWebServer::Cmd_SetUnused, this, _1, _2, _3));

			RegisterCommandCode(""addlogmessage"", boost::bind(&CWebServer::Cmd_AddLogMessage, this, _1, _2, _3));
			RegisterCommandCode(""clearshortlog"", boost::bind(&CWebServer::Cmd_ClearShortLog, this, _1, _2, _3));
			RegisterCommandCode(""vacuumdatabase"", boost::bind(&CWebServer::Cmd_VacuumDatabase, this, _1, _2, _3));

			RegisterCommandCode(""addmobiledevice"", boost::bind(&CWebServer::Cmd_AddMobileDevice, this, _1, _2, _3));
			RegisterCommandCode(""updatemobiledevice"", boost::bind(&CWebServer::Cmd_UpdateMobileDevice, this, _1, _2, _3));
			RegisterCommandCode(""deletemobiledevice"", boost::bind(&CWebServer::Cmd_DeleteMobileDevice, this, _1, _2, _3));

			RegisterCommandCode(""addyeelight"", boost::bind(&CWebServer::Cmd_AddYeeLight, this, _1, _2, _3));

			RegisterCommandCode(""addArilux"", boost::bind(&CWebServer::Cmd_AddArilux, this, _1, _2, _3));

			RegisterRType(""graph"", boost::bind(&CWebServer::RType_HandleGraph, this, _1, _2, _3));
			RegisterRType(""lightlog"", boost::bind(&CWebServer::RType_LightLog, this, _1, _2, _3));
			RegisterRType(""textlog"", boost::bind(&CWebServer::RType_TextLog, this, _1, _2, _3));
			RegisterRType(""scenelog"", boost::bind(&CWebServer::RType_SceneLog, this, _1, _2, _3));
			RegisterRType(""settings"", boost::bind(&CWebServer::RType_Settings, this, _1, _2, _3));
			RegisterRType(""events"", boost::bind(&CWebServer::RType_Events, this, _1, _2, _3));

			RegisterRType(""hardware"", boost::bind(&CWebServer::RType_Hardware, this, _1, _2, _3));
			RegisterRType(""devices"", boost::bind(&CWebServer::RType_Devices, this, _1, _2, _3));
			RegisterRType(""deletedevice"", boost::bind(&CWebServer::RType_DeleteDevice, this, _1, _2, _3));
			RegisterRType(""cameras"", boost::bind(&CWebServer::RType_Cameras, this, _1, _2, _3));
			RegisterRType(""cameras_user"", boost::bind(&CWebServer::RType_CamerasUser, this, _1, _2, _3));
			RegisterRType(""users"", boost::bind(&CWebServer::RType_Users, this, _1, _2, _3));
			RegisterRType(""mobiles"", boost::bind(&CWebServer::RType_Mobiles, this, _1, _2, _3));

			RegisterRType(""timers"", boost::bind(&CWebServer::RType_Timers, this, _1, _2, _3));
			RegisterRType(""scenetimers"", boost::bind(&CWebServer::RType_SceneTimers, this, _1, _2, _3));
			RegisterRType(""setpointtimers"", boost::bind(&CWebServer::RType_SetpointTimers, this, _1, _2, _3));

			RegisterRType(""gettransfers"", boost::bind(&CWebServer::RType_GetTransfers, this, _1, _2, _3));
			RegisterRType(""transferdevice"", boost::bind(&CWebServer::RType_TransferDevice, this, _1, _2, _3));
			RegisterRType(""notifications"", boost::bind(&CWebServer::RType_Notifications, this, _1, _2, _3));
			RegisterRType(""schedules"", boost::bind(&CWebServer::RType_Schedules, this, _1, _2, _3));
			RegisterRType(""getshareduserdevices"", boost::bind(&CWebServer::RType_GetSharedUserDevices, this, _1, _2, _3));
			RegisterRType(""setshareduserdevices"", boost::bind(&CWebServer::RType_SetSharedUserDevices, this, _1, _2, _3));
			RegisterRType(""setused"", boost::bind(&CWebServer::RType_SetUsed, this, _1, _2, _3));
			RegisterRType(""scenes"", boost::bind(&CWebServer::RType_Scenes, this, _1, _2, _3));
			RegisterRType(""addscene"", boost::bind(&CWebServer::RType_AddScene, this, _1, _2, _3));
			RegisterRType(""deletescene"", boost::bind(&CWebServer::RType_DeleteScene, this, _1, _2, _3));
			RegisterRType(""updatescene"", boost::bind(&CWebServer::RType_UpdateScene, this, _1, _2, _3));
			RegisterRType(""createvirtualsensor"", boost::bind(&CWebServer::RType_CreateMappedSensor, this, _1, _2, _3));
			RegisterRType(""createdevice"", boost::bind(&CWebServer::RType_CreateDevice, this, _1, _2, _3));

			RegisterRType(""createevohomesensor"", boost::bind(&CWebServer::RType_CreateEvohomeSensor, this, _1, _2, _3));
			RegisterRType(""bindevohome"", boost::bind(&CWebServer::RType_BindEvohome, this, _1, _2, _3));
			RegisterRType(""createrflinkdevice"", boost::bind(&CWebServer::RType_CreateRFLinkDevice, this, _1, _2, _3));

			RegisterRType(""custom_light_icons"", boost::bind(&CWebServer::RType_CustomLightIcons, this, _1, _2, _3));
			RegisterRType(""plans"", boost::bind(&CWebServer::RType_Plans, this, _1, _2, _3));
			RegisterRType(""floorplans"", boost::bind(&CWebServer::RType_FloorPlans, this, _1, _2, _3));
#ifdef WITH_OPENZWAVE
			RegisterCommandCode(""updatezwavenode"", boost::bind(&CWebServer::Cmd_ZWaveUpdateNode, this, _1, _2, _3));
			RegisterCommandCode(""deletezwavenode"", boost::bind(&CWebServer::Cmd_ZWaveDeleteNode, this, _1, _2, _3));
			RegisterCommandCode(""zwaveinclude"", boost::bind(&CWebServer::Cmd_ZWaveInclude, this, _1, _2, _3));
			RegisterCommandCode(""zwaveexclude"", boost::bind(&CWebServer::Cmd_ZWaveExclude, this, _1, _2, _3));

			RegisterCommandCode(""zwaveisnodeincluded"", boost::bind(&CWebServer::Cmd_ZWaveIsNodeIncluded, this, _1, _2, _3));
			RegisterCommandCode(""zwaveisnodeexcluded"", boost::bind(&CWebServer::Cmd_ZWaveIsNodeExcluded, this, _1, _2, _3));

			RegisterCommandCode(""zwavesoftreset"", boost::bind(&CWebServer::Cmd_ZWaveSoftReset, this, _1, _2, _3));
			RegisterCommandCode(""zwavehardreset"", boost::bind(&CWebServer::Cmd_ZWaveHardReset, this, _1, _2, _3));
			RegisterCommandCode(""zwavenetworkheal"", boost::bind(&CWebServer::Cmd_ZWaveNetworkHeal, this, _1, _2, _3));
			RegisterCommandCode(""zwavenodeheal"", boost::bind(&CWebServer::Cmd_ZWaveNodeHeal, this, _1, _2, _3));
			RegisterCommandCode(""zwavenetworkinfo"", boost::bind(&CWebServer::Cmd_ZWaveNetworkInfo, this, _1, _2, _3));
			RegisterCommandCode(""zwaveremovegroupnode"", boost::bind(&CWebServer::Cmd_ZWaveRemoveGroupNode, this, _1, _2, _3));
			RegisterCommandCode(""zwaveaddgroupnode"", boost::bind(&CWebServer::Cmd_ZWaveAddGroupNode, this, _1, _2, _3));
			RegisterCommandCode(""zwavegroupinfo"", boost::bind(&CWebServer::Cmd_ZWaveGroupInfo, this, _1, _2, _3));
			RegisterCommandCode(""zwavecancel"", boost::bind(&CWebServer::Cmd_ZWaveCancel, this, _1, _2, _3));
			RegisterCommandCode(""applyzwavenodeconfig"", boost::bind(&CWebServer::Cmd_ApplyZWaveNodeConfig, this, _1, _2, _3));
			RegisterCommandCode(""requestzwavenodeconfig"", boost::bind(&CWebServer::Cmd_ZWaveRequestNodeConfig, this, _1, _2, _3));
			RegisterCommandCode(""zwavestatecheck"", boost::bind(&CWebServer::Cmd_ZWaveStateCheck, this, _1, _2, _3));
			RegisterCommandCode(""zwavereceiveconfigurationfromothercontroller"", boost::bind(&CWebServer::Cmd_ZWaveReceiveConfigurationFromOtherController, this, _1, _2, _3));
			RegisterCommandCode(""zwavesendconfigurationtosecondcontroller"", boost::bind(&CWebServer::Cmd_ZWaveSendConfigurationToSecondaryController, this, _1, _2, _3));
			RegisterCommandCode(""zwavetransferprimaryrole"", boost::bind(&CWebServer::Cmd_ZWaveTransferPrimaryRole, this, _1, _2, _3));
			RegisterCommandCode(""zwavestartusercodeenrollmentmode"", boost::bind(&CWebServer::Cmd_ZWaveSetUserCodeEnrollmentMode, this, _1, _2, _3));
			RegisterCommandCode(""zwavegetusercodes"", boost::bind(&CWebServer::Cmd_ZWaveGetNodeUserCodes, this, _1, _2, _3));
			RegisterCommandCode(""zwaveremoveusercode"", boost::bind(&CWebServer::Cmd_ZWaveRemoveUserCode, this, _1, _2, _3));

			m_pWebEm->RegisterPageCode(""/zwavegetconfig.php"", boost::bind(&CWebServer::ZWaveGetConfigFile, this, _1, _2, _3));

			m_pWebEm->RegisterPageCode(""/ozwcp/poll.xml"", boost::bind(&CWebServer::ZWaveCPPollXml, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/cp.html"", boost::bind(&CWebServer::ZWaveCPIndex, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/confparmpost.html"", boost::bind(&CWebServer::ZWaveCPNodeGetConf, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/refreshpost.html"", boost::bind(&CWebServer::ZWaveCPNodeGetValues, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/valuepost.html"", boost::bind(&CWebServer::ZWaveCPNodeSetValue, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/buttonpost.html"", boost::bind(&CWebServer::ZWaveCPNodeSetButton, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/admpost.html"", boost::bind(&CWebServer::ZWaveCPAdminCommand, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/nodepost.html"", boost::bind(&CWebServer::ZWaveCPNodeChange, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/savepost.html"", boost::bind(&CWebServer::ZWaveCPSaveConfig, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/thpost.html"", boost::bind(&CWebServer::ZWaveCPTestHeal, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/topopost.html"", boost::bind(&CWebServer::ZWaveCPGetTopo, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/statpost.html"", boost::bind(&CWebServer::ZWaveCPGetStats, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/grouppost.html"", boost::bind(&CWebServer::ZWaveCPSetGroup, this, _1, _2, _3));
			m_pWebEm->RegisterPageCode(""/ozwcp/scenepost.html"", boost::bind(&CWebServer::ZWaveCPSceneCommand, this, _1, _2, _3));
			RegisterRType(""openzwavenodes"", boost::bind(&CWebServer::RType_OpenZWaveNodes, this, _1, _2, _3));
#endif
			RegisterCommandCode(""tellstickApplySettings"", boost::bind(&CWebServer::Cmd_TellstickApplySettings, this, _1, _2, _3));

			m_pWebEm->RegisterWhitelistURLString(""/html5.appcache"");
			m_pWebEm->RegisterWhitelistURLString(""/images/floorplans/plan"");

			m_bDoStop = false;
			m_thread = std::make_shared<std::thread>(&CWebServer::Do_Work, this);
			std::string server_name = ""WebServer_"" + settings.listening_port;
			SetThreadName(m_thread->native_handle(), server_name.c_str());
			return (m_thread != nullptr);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,38774103154322698504935559154280587976,,
"		void CWebServer::StoreSession(const WebEmStoredSession & session) {
			if (session.id.empty()) {
				_log.Log(LOG_ERROR, ""SessionStore : cannot store session without id."");
				return;
			}

			char szExpires[30];
			struct tm ltime;
			localtime_r(&session.expires, &ltime);
			strftime(szExpires, sizeof(szExpires), ""%Y-%m-%d %H:%M:%S"", &ltime);

			std::string remote_host = (session.remote_host.size() <= 50) ? // IPv4 : 15, IPv6 : (39|45)
				session.remote_host : session.remote_host.substr(0, 50);

			WebEmStoredSession storedSession = GetSession(session.id);
			if (storedSession.id.empty()) {
				m_sql.safe_query(
					""INSERT INTO UserSessions (SessionID, Username, AuthToken, ExpirationDate, RemoteHost) VALUES ('%q', '%q', '%q', '%q', '%q')"",
					session.id.c_str(),
					base64_encode(session.username).c_str(),
					session.auth_token.c_str(),
					szExpires,
					remote_host.c_str());
			}
			else {
				m_sql.safe_query(
					""UPDATE UserSessions set AuthToken = '%q', ExpirationDate = '%q', RemoteHost = '%q', LastUpdate = datetime('now', 'localtime') WHERE SessionID = '%q'"",
					session.auth_token.c_str(),
					szExpires,
					remote_host.c_str(),
					session.id.c_str());
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,169221903769055324340426873113258870664,,
"		void CWebServer::UploadFloorplanImage(WebEmSession & session, const request& req, std::string & redirect_uri)
		{
			redirect_uri = ""/index.html"";
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string planname = request::findValue(&req, ""planname"");
			std::string scalefactor = request::findValue(&req, ""scalefactor"");
			std::string imagefile = request::findValue(&req, ""imagefile"");

			std::vector<std::vector<std::string> > result;
			m_sql.safe_query(""INSERT INTO Floorplans ([Name],[ScaleFactor]) VALUES('%s','%s')"", planname.c_str(),scalefactor.c_str());
			result = m_sql.safe_query(""SELECT MAX(ID) FROM Floorplans"");
			if (!result.empty())
			{
				if (!m_sql.safe_UpdateBlobInTableWithID(""Floorplans"", ""Image"", result[0][0], imagefile))
					_log.Log(LOG_ERROR, ""SQL: Problem inserting floorplan image into database! "");
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,186808374244552299643215119225674453449,,
"		bool compareIconsByName(const http::server::CWebServer::_tCustomIcon &a, const http::server::CWebServer::_tCustomIcon &b)
		{
			return a.Title < b.Title;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,53291722781369445688433444453506930597,,
"		CWebServer::~CWebServer(void)
		{
			StopServer();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,54902717953516314917345092952213411644,,
"int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)
{
  char **atimes, **aranges = NULL;
  int numtimes=0,i=0,numranges=0;
  size_t buffer_size = 512;
  char buffer[512], bufferTmp[512];

  buffer[0] = '\0';
  bufferTmp[0] = '\0';

   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
  if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
     msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
     return MS_FALSE;
  }

   /* discrete time */
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) { /* discrete time */
    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);
  } else {

    /* multiple times, or ranges */
    atimes = msStringSplit (timestring, ',', &numtimes);
    if (atimes == NULL || numtimes < 1)
      return MS_FALSE;

    strlcat(buffer, ""("", buffer_size);
    for(i=0; i<numtimes; i++) {
      if(i!=0) {
        strlcat(buffer, "" OR "", buffer_size);
      }
      strlcat(buffer, ""("", buffer_size);
      aranges = msStringSplit(atimes[i],  '/', &numranges);
      if(!aranges) return MS_FALSE;
      if(numranges == 1) {
        /* we don't have range, just a simple time */
        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else if(numranges == 2) {
        /* we have a range */
        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else {
        return MS_FALSE;
      }
      msFreeCharArray(aranges, numranges);
      strlcat(buffer, "")"", buffer_size);
    }
    strlcat(buffer, "")"", buffer_size);
    msFreeCharArray(atimes, numtimes);
  }
  if(!*buffer) {
    return MS_FALSE;
  }
  if(lp->filteritem) free(lp->filteritem);
  lp->filteritem = msStrdup(timefield);
  if (&lp->filter) {
    /* if the filter is set and it's a string type, concatenate it with
       the time. If not just free it */
    if (lp->filter.type == MS_EXPRESSION) {
      snprintf(bufferTmp, buffer_size, ""(%s) and %s"", lp->filter.string, buffer);
      loadExpressionString(&lp->filter, bufferTmp);
    } else {
      freeExpression(&lp->filter);
      loadExpressionString(&lp->filter, buffer);
    }
  }


  return MS_TRUE;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,276142830574984393993186005844111442808,,
"		void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx == """") {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
			std::string oname = ""floorplan"";
			if (result[0][0].size() > 10)
			{
				if (result[0][0][0] == 'P')
					oname += "".png"";
				else if (result[0][0][0] == -1)
					oname += "".jpg"";
				else if (result[0][0][0] == 'B')
					oname += "".bmp"";
				else if (result[0][0][0] == 'G')
					oname += "".gif"";
			}
			reply::add_header_attachment(&rep, oname);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,197783324510857228323747681493007558923,,
"int createPostgresTimeCompareSimple(const char *timecol, const char *timestring, char *dest, size_t destsize)
{
  int timeresolution = msTimeGetResolution(timestring);
  char timeStamp[100];
  char *interval;
  if (timeresolution < 0)
    return MS_FALSE;
  postgresTimeStampForTimeString(timestring,timeStamp,100);

  switch(timeresolution) {
    case TIME_RESOLUTION_YEAR:
      interval = ""year"";
      break;
    case TIME_RESOLUTION_MONTH:
      interval = ""month"";
      break;
    case TIME_RESOLUTION_DAY:
      interval = ""day"";
      break;
    case TIME_RESOLUTION_HOUR:
      interval = ""hour"";
      break;
    case TIME_RESOLUTION_MINUTE:
      interval = ""minute"";
      break;
    case TIME_RESOLUTION_SECOND:
      interval = ""second"";
      break;
    default:
      return MS_FAILURE;
  }
  snprintf(dest, destsize,""(%s >= date_trunc('%s',%s) and %s < date_trunc('%s',%s) + interval '1 %s')"",
           timecol, interval, timeStamp, timecol, interval, timeStamp, interval);
  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,207976180324643811815427376130957453899,,
"char *msPostGISBuildSQLFrom(layerObj *layer, rectObj *rect)
{
  char *strFrom = 0;
  msPostGISLayerInfo *layerinfo;

  if (layer->debug) {
    msDebug(""msPostGISBuildSQLFrom called.\n"");
  }

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;

  if ( ! layerinfo->fromsource ) {
    msSetError(MS_MISCERR, ""Layerinfo->fromsource is not initialized."", ""msPostGISBuildSQLFrom()"");
    return NULL;
  }

  /*
  ** If there's a '!BOX!' in our source we need to substitute the
  ** current rectangle for it...
  */
  strFrom = msPostGISReplaceBoxToken(layer, rect, layerinfo->fromsource);

  return strFrom;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,331749848109308098183202019399933611290,,
"char *msPostGISBuildSQLSRID(layerObj *layer)
{

  char *strSRID = NULL;
  msPostGISLayerInfo *layerinfo = NULL;

  if (layer->debug) {
    msDebug(""msPostGISBuildSQLSRID called.\n"");
  }

  assert( layer->layerinfo != NULL);

  layerinfo = (msPostGISLayerInfo *)layer->layerinfo;

  /* An SRID was already provided in the DATA line. */
  if ( layerinfo->srid && (strlen(layerinfo->srid) > 0) ) {
    strSRID = msStrdup(layerinfo->srid);
    if( layer->debug > 1 ) {
      msDebug(""msPostGISBuildSQLSRID: SRID provided (%s)\n"", strSRID);
    }
  }
  /*
  ** No SRID in data line, so extract target table from the 'fromsource'.
  ** Either of form ""thetable"" (one word) or ""(select ... from thetable)""
  ** or ""(select ... from thetable where ...)"".
  */
  else {
    char *f_table_name;
    char *strSRIDTemplate = ""find_srid('','%s','%s')"";
    char *pos = strstr(layerinfo->fromsource, "" "");
    if( layer->debug > 1 ) {
      msDebug(""msPostGISBuildSQLSRID: Building find_srid line.\n"", strSRID);
    }

    if ( ! pos ) {
      /* target table is one word */
      f_table_name = msStrdup(layerinfo->fromsource);
      if( layer->debug > 1 ) {
        msDebug(""msPostGISBuildSQLSRID: Found table (%s)\n"", f_table_name);
      }
    } else {
      /* target table is hiding in sub-select clause */
      pos = strcasestr(layerinfo->fromsource, "" from "");
      if ( pos ) {
        char *pos_paren;
        char *pos_space;
        pos += 6; /* should be start of table name */
        pos_paren = strstr(pos, "")""); /* first ) after table name */
        pos_space = strstr(pos, "" ""); /* first space after table name */
        if ( pos_space < pos_paren ) {
          /* found space first */
          f_table_name = (char*)msSmallMalloc(pos_space - pos + 1);
          strlcpy(f_table_name, pos, pos_space - pos+1);
        } else {
          /* found ) first */
          f_table_name = (char*)msSmallMalloc(pos_paren - pos + 1);
          strlcpy(f_table_name, pos, pos_paren - pos+1);
        }
      } else {
        /* should not happen */
        return NULL;
      }
    }
    strSRID = msSmallMalloc(strlen(strSRIDTemplate) + strlen(f_table_name) + strlen(layerinfo->geomcolumn));
    sprintf(strSRID, strSRIDTemplate, f_table_name, layerinfo->geomcolumn);
    if ( f_table_name ) free(f_table_name);
  }
  return strSRID;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,141315025140384852628629110347820472708,,
"void msPostGISCloseConnection(void *pgconn)
{
  PQfinish((PGconn*)pgconn);
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,215088212367910619099263987710649312798,,
"void msPostGISLayerFreeItemInfo(layerObj *layer)
{
#ifdef USE_POSTGIS
  if (layer->debug) {
    msDebug(""msPostGISLayerFreeItemInfo called.\n"");
  }

  if (layer->iteminfo) {
    free(layer->iteminfo);
  }
  layer->iteminfo = NULL;
#endif
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,114073735291717571728906183060809708051,,
"wkbConvCircularStringToShape(wkbObj *w, shapeObj *shape)
{
  int type;
  lineObj line = {0, NULL};

  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));

  if( type != WKB_CIRCULARSTRING ) return MS_FAILURE;

  /* Stroke the string into a point array */
  if ( arcStrokeCircularString(w, SEGMENT_ANGLE, &line) == MS_FAILURE ) {
    if(line.point) free(line.point);
    return MS_FAILURE;
  }

  /* Fill in the lineObj */
  if ( line.numpoints > 0 ) {
    msAddLine(shape, &line);
    if(line.point) free(line.point);
  }

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,193369738825397811694366507400820966535,,
"wkbConvCompoundCurveToShape(wkbObj *w, shapeObj *shape)
{
  int npoints = 0;
  int type, ncomponents, i, j;
  lineObj *line;
  shapeObj shapebuf;

  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));

  /* Init our shape buffer */
  msInitShape(&shapebuf);

  if( type != WKB_COMPOUNDCURVE ) return MS_FAILURE;

  /* How many components in the compound curve? */
  ncomponents = wkbReadInt(w);

  /* We'll load each component onto a line in a shape */
  for( i = 0; i < ncomponents; i++ )
    wkbConvGeometryToShape(w, &shapebuf);

  /* Do nothing on empty */
  if ( shapebuf.numlines == 0 )
    return MS_FAILURE;

  /* Count the total number of points */
  for( i = 0; i < shapebuf.numlines; i++ )
    npoints += shapebuf.line[i].numpoints;

  /* Do nothing on empty */
  if ( npoints == 0 )
    return MS_FAILURE;

  /* Allocate space for the new line */
  line = msSmallMalloc(sizeof(lineObj));
  line->numpoints = npoints;
  line->point = msSmallMalloc(sizeof(pointObj) * npoints);

  /* Copy in the points */
  npoints = 0;
  for ( i = 0; i < shapebuf.numlines; i++ ) {
    for ( j = 0; j < shapebuf.line[i].numpoints; j++ ) {
      /* Don't add a start point that duplicates an endpoint */
      if( j == 0 && i > 0 &&
          memcmp(&(line->point[npoints - 1]),&(shapebuf.line[i].point[j]),sizeof(pointObj)) == 0 ) {
        continue;
      }
      line->point[npoints++] = shapebuf.line[i].point[j];
    }
  }
  line->numpoints = npoints;

  /* Clean up */
  msFreeShape(&shapebuf);

  /* Fill in the lineObj */
  msAddLineDirectly(shape, line);

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,100221076467807733643880413457096143919,,
"wkbConvGeometryToShape(wkbObj *w, shapeObj *shape)
{
  int wkbtype = wkbType(w); /* Peak at the type number */

  switch(wkbtype) {
      /* Recurse into anonymous collections */
    case WKB_GEOMETRYCOLLECTION:
      return wkbConvCollectionToShape(w, shape);
      /* Handle area types */
    case WKB_POLYGON:
      return wkbConvPolygonToShape(w, shape);
    case WKB_MULTIPOLYGON:
      return wkbConvCollectionToShape(w, shape);
    case WKB_CURVEPOLYGON:
      return wkbConvCurvePolygonToShape(w, shape);
    case WKB_MULTISURFACE:
      return wkbConvCollectionToShape(w, shape);
  }

  /* We can't convert any of the following types into polygons */
  if ( shape->type == MS_SHAPE_POLYGON ) return MS_FAILURE;

  /* Handle linear types */
  switch(wkbtype) {
    case WKB_LINESTRING:
      return wkbConvLineStringToShape(w, shape);
    case WKB_CIRCULARSTRING:
      return wkbConvCircularStringToShape(w, shape);
    case WKB_COMPOUNDCURVE:
      return wkbConvCompoundCurveToShape(w, shape);
    case WKB_MULTILINESTRING:
      return wkbConvCollectionToShape(w, shape);
    case WKB_MULTICURVE:
      return wkbConvCollectionToShape(w, shape);
  }

  /* We can't convert any of the following types into lines */
  if ( shape->type == MS_SHAPE_LINE ) return MS_FAILURE;

  /* Handle point types */
  switch(wkbtype) {
    case WKB_POINT:
      return wkbConvPointToShape(w, shape);
    case WKB_MULTIPOINT:
      return wkbConvCollectionToShape(w, shape);
  }

  /* This is a WKB type we don't know about! */
  return MS_FAILURE;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,288645604783855078750885769851990353817,,
"wkbConvLineStringToShape(wkbObj *w, shapeObj *shape)
{
  int type;
  lineObj line;

  /*endian = */wkbReadChar(w);
  type = wkbTypeMap(w,wkbReadInt(w));

  if( type != WKB_LINESTRING ) return MS_FAILURE;

  wkbReadLine(w,&line);
  msAddLineDirectly(shape, &line);

  return MS_SUCCESS;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,108670213651035825768112430873940903405,,
"wkbReadChar(wkbObj *w)
{
  char c;
  memcpy(&c, w->ptr, sizeof(char));
  w->ptr += sizeof(char);
  return c;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,331806738241350646472778257157853722628,,
"wkbReadPointP(wkbObj *w, pointObj *p)
{
  memcpy(&(p->x), w->ptr, sizeof(double));
  w->ptr += sizeof(double);
  memcpy(&(p->y), w->ptr, sizeof(double));
  w->ptr += sizeof(double);
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,163288132485096492954955868483025146590,,
"wkbTypeMap(wkbObj *w, int type)
{
  if ( type < WKB_TYPE_COUNT )
    return w->typemap[type];
  else
    return 0;
}
",0,CWE-89,mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,255508661210081160970368418275141676113,,
"		void CWebServer::Cmd_DeleteHardware(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			if (idx.empty())
				return;
			int hwID = atoi(idx.c_str());

			CDomoticzHardwareBase *pBaseHardware = m_mainworker.GetHardware(hwID);
			if ((pBaseHardware != NULL) && (pBaseHardware->HwdType == HTYPE_DomoticzInternal)) {
				return;
			}

			root[""status""] = ""OK"";
			root[""title""] = ""DeleteHardware"";

			m_mainworker.RemoveDomoticzHardware(hwID);
			m_sql.DeleteHardware(idx);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,122946127822177212329300047223875788934,,
"		void CWebServer::Cmd_GetDevicesList(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetDevicesList"";
			int ii = 0;
			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Name FROM DeviceStatus WHERE (Used == 1) ORDER BY Name"");
			if (!result.empty())
			{
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;
					root[""result""][ii][""name""] = sd[1];
					root[""result""][ii][""value""] = sd[0];
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,92427035224870453700987951918727623503,,
"		void CWebServer::Cmd_GetUnusedPlanDevices(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetUnusedPlanDevices"";
			std::string sunique = request::findValue(&req, ""unique"");
			if (sunique.empty())
				return;
			int iUnique = (sunique == ""true"") ? 1 : 0;
			int ii = 0;

			std::vector<std::vector<std::string> > result;
			std::vector<std::vector<std::string> > result2;
			result = m_sql.safe_query(""SELECT T1.[ID], T1.[Name], T1.[Type], T1.[SubType], T2.[Name] AS HardwareName FROM DeviceStatus as T1, Hardware as T2 WHERE (T1.[Used]==1) AND (T2.[ID]==T1.[HardwareID]) ORDER BY T2.[Name], T1.[Name]"");
			if (!result.empty())
			{
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					bool bDoAdd = true;
					if (iUnique)
					{
						result2 = m_sql.safe_query(""SELECT ID FROM DeviceToPlansMap WHERE (DeviceRowID=='%q') AND (DevSceneType==0)"",
							sd[0].c_str());
						bDoAdd = (result2.size() == 0);
					}
					if (bDoAdd)
					{
						int _dtype = atoi(sd[2].c_str());
						std::string Name = ""["" + sd[4] + ""] "" + sd[1] + "" ("" + RFX_Type_Desc(_dtype, 1) + ""/"" + RFX_Type_SubType_Desc(_dtype, atoi(sd[3].c_str())) + "")"";
						root[""result""][ii][""type""] = 0;
						root[""result""][ii][""idx""] = sd[0];
						root[""result""][ii][""Name""] = Name;
						ii++;
					}
				}
			}
			result = m_sql.safe_query(""SELECT ID, Name FROM Scenes ORDER BY Name"");
			if (!result.empty())
			{
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					bool bDoAdd = true;
					if (iUnique)
					{
						result2 = m_sql.safe_query(""SELECT ID FROM DeviceToPlansMap WHERE (DeviceRowID=='%q') AND (DevSceneType==1)"",
							sd[0].c_str());
						bDoAdd = (result2.size() == 0);
					}
					if (bDoAdd)
					{
						root[""result""][ii][""type""] = 1;
						root[""result""][ii][""idx""] = sd[0];
						std::string sname = ""[Scene] "" + sd[1];
						root[""result""][ii][""Name""] = sname;
						ii++;
					}
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,12329706027671991358385274805259915570,,
"		void CWebServer::Cmd_RenameScene(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			std::string sname = request::findValue(&req, ""name"");
			if (
				(sidx.empty()) ||
				(sname.empty())
				)
				return;
			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""RenameScene"";

			m_sql.safe_query(""UPDATE Scenes SET Name='%q' WHERE (ID == %d)"", sname.c_str(), idx);
			uint64_t ullidx = std::strtoull(sidx.c_str(), nullptr, 10);
			m_mainworker.m_eventsystem.WWWUpdateSingleState(ullidx, sname, m_mainworker.m_eventsystem.REASON_SCENEGROUP);
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,104002209980369061450644890297692465428,,
"		void CWebServer::Cmd_UpdateCustomIcon(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string sidx = request::findValue(&req, ""idx"");
			std::string sname = request::findValue(&req, ""name"");
			std::string sdescription = request::findValue(&req, ""description"");
			if (
				(sidx.empty()) ||
				(sname.empty()) ||
				(sdescription.empty())
				)
				return;

			int idx = atoi(sidx.c_str());
			root[""status""] = ""OK"";
			root[""title""] = ""UpdateCustomIcon"";

			m_sql.safe_query(""UPDATE CustomImages SET Name='%q', Description='%q' WHERE (ID == %d)"", sname.c_str(), sdescription.c_str(), idx);
			ReloadCustomSwitchIcons();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,269573447793560003946676800717634384003,,
"		void CWebServer::Cmd_UpdateUserVariable(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string idx = request::findValue(&req, ""idx"");
			std::string variablename = request::findValue(&req, ""vname"");
			std::string variablevalue = request::findValue(&req, ""vvalue"");
			std::string variabletype = request::findValue(&req, ""vtype"");

			if (
				(variablename.empty()) ||
				(variabletype.empty()) ||
				((variablevalue.empty()) && (variabletype != ""2""))
				)
				return;

			std::vector<std::vector<std::string> > result;
			if (idx.empty())
			{
				result = m_sql.safe_query(""SELECT ID FROM UserVariables WHERE Name='%q'"", variablename.c_str());
				if (result.empty())
					return;
				idx = result[0][0];
			}

			result = m_sql.safe_query(""SELECT Name, ValueType FROM UserVariables WHERE ID='%q'"", idx.c_str());
			if (result.empty())
				return;

			bool bTypeNameChanged = false;
			if (variablename != result[0][0])
				bTypeNameChanged = true; //new name
			else if (variabletype != result[0][1])
				bTypeNameChanged = true; //new type

			root[""title""] = ""UpdateUserVariable"";

			std::string errorMessage;
			if (!m_sql.UpdateUserVariable(idx, variablename, (const _eUsrVariableType)atoi(variabletype.c_str()), variablevalue, !bTypeNameChanged, errorMessage))
			{
				root[""status""] = ""ERR"";
				root[""message""] = errorMessage;
			}
			else {
				root[""status""] = ""OK"";
				if (bTypeNameChanged)
				{
					if (m_sql.m_bEnableEventSystem)
						m_mainworker.m_eventsystem.GetCurrentUserVariables();
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,258538414783475045217323067678665122219,,
"		void CWebServer::Cmd_VacuumDatabase(WebEmSession & session, const request& req, Json::Value &root)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
			root[""status""] = ""OK"";
			root[""title""] = ""VacuumDatabase"";

			m_sql.VacuumDatabase();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,59460728648583799902511180991088771242,,
"		void CWebServer::DisplayTimerTypesCombo(std::string & content_part)
		{
			char szTmp[200];
			for (int ii = 0; ii < TTYPE_END; ii++)
			{
				sprintf(szTmp, ""<option data-i18n=\""%s\"" value=\""%d\"">%s</option>\n"", Timer_Type_Desc(ii), ii, Timer_Type_Desc(ii));
				content_part += szTmp;
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,244906499850963786457606881049303086992,,
"		bool CWebServer::FindAdminUser()
		{
			for (const auto & itt : m_users)
			{
				if (itt.userrights == URIGHTS_ADMIN)
					return true;
			}
			return false;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,200128774116663625736789808977437288005,,
"		void CWebServer::GetDatabaseBackup(WebEmSession & session, const request& req, reply & rep)
		{
			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}
#ifdef WIN32
			std::string OutputFileName = szUserDataFolder + ""backup.db"";
#else
			std::string OutputFileName = ""/tmp/backup.db"";
#endif
			if (m_sql.BackupDatabase(OutputFileName))
			{
				std::string szAttachmentName = ""domoticz.db"";
				std::string szVar;
				if (m_sql.GetPreferencesVar(""Title"", szVar))
				{
					stdreplace(szVar, "" "", ""_"");
					stdreplace(szVar, ""/"", ""_"");
					stdreplace(szVar, ""\\"", ""_"");
					if (!szVar.empty()) {
						szAttachmentName = szVar + "".db"";
					}
				}
				reply::set_content_from_file(&rep, OutputFileName, szAttachmentName, true);
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,145891466464831560950299158418665787834,,
"		void CWebServer::GetJSonDevices(
			Json::Value &root,
			const std::string &rused,
			const std::string &rfilter,
			const std::string &order,
			const std::string &rowid,
			const std::string &planID,
			const std::string &floorID,
			const bool bDisplayHidden,
			const bool bDisplayDisabled,
			const bool bFetchFavorites,
			const time_t LastUpdate,
			const std::string &username,
			const std::string &hardwareid)
		{
			std::vector<std::vector<std::string> > result;

			time_t now = mytime(NULL);
			struct tm tm1;
			localtime_r(&now, &tm1);
			struct tm tLastUpdate;
			localtime_r(&now, &tLastUpdate);

			const time_t iLastUpdate = LastUpdate - 1;

			int SensorTimeOut = 60;
			m_sql.GetPreferencesVar(""SensorTimeout"", SensorTimeOut);

			std::map<int, _tHardwareListInt> _hardwareNames;
			result = m_sql.safe_query(""SELECT ID, Name, Enabled, Type, Mode1, Mode2 FROM Hardware"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;
					_tHardwareListInt tlist;
					int ID = atoi(sd[0].c_str());
					tlist.Name = sd[1];
					tlist.Enabled = (atoi(sd[2].c_str()) != 0);
					tlist.HardwareTypeVal = atoi(sd[3].c_str());
#ifndef ENABLE_PYTHON
					tlist.HardwareType = Hardware_Type_Desc(tlist.HardwareTypeVal);
#else
					if (tlist.HardwareTypeVal != HTYPE_PythonPlugin)
					{
						tlist.HardwareType = Hardware_Type_Desc(tlist.HardwareTypeVal);
					}
					else
					{
						tlist.HardwareType = PluginHardwareDesc(ID);
					}
#endif
					tlist.Mode1 = sd[4];
					tlist.Mode2 = sd[5];
					_hardwareNames[ID] = tlist;
				}
			}

			root[""ActTime""] = static_cast<int>(now);

			char szTmp[300];

			if (!m_mainworker.m_LastSunriseSet.empty())
			{
				std::vector<std::string> strarray;
				StringSplit(m_mainworker.m_LastSunriseSet, "";"", strarray);
				if (strarray.size() == 10)
				{
					strftime(szTmp, 80, ""%Y-%m-%d %X"", &tm1);
					root[""ServerTime""] = szTmp;
					root[""Sunrise""] = strarray[0];
					root[""Sunset""] = strarray[1];
					root[""SunAtSouth""] = strarray[2];
					root[""CivTwilightStart""] = strarray[3];
					root[""CivTwilightEnd""] = strarray[4];
					root[""NautTwilightStart""] = strarray[5];
					root[""NautTwilightEnd""] = strarray[6];
					root[""AstrTwilightStart""] = strarray[7];
					root[""AstrTwilightEnd""] = strarray[8];
					root[""DayLength""] = strarray[9];
				}
			}

			char szOrderBy[50];
			std::string szQuery;
			bool isAlpha = true;
			const std::string orderBy = order.c_str();
			for (size_t i = 0; i < orderBy.size(); i++) {
				if (!isalpha(orderBy[i])) {
					isAlpha = false;
				}
			}
			if (order.empty() || (!isAlpha)) {
				strcpy(szOrderBy, ""A.[Order],A.LastUpdate DESC"");
			} else {
				sprintf(szOrderBy, ""A.[Order],A.%%s ASC"");
			}

			unsigned char tempsign = m_sql.m_tempsign[0];

			bool bHaveUser = false;
			int iUser = -1;
			unsigned int totUserDevices = 0;
			bool bShowScenes = true;
			bHaveUser = (username != """");
			if (bHaveUser)
			{
				iUser = FindUser(username.c_str());
				if (iUser != -1)
				{
					_eUserRights urights = m_users[iUser].userrights;
					if (urights != URIGHTS_ADMIN)
					{
						result = m_sql.safe_query(""SELECT DeviceRowID FROM SharedDevices WHERE (SharedUserID == %lu)"", m_users[iUser].ID);
						totUserDevices = (unsigned int)result.size();
						bShowScenes = (m_users[iUser].ActiveTabs&(1 << 1)) != 0;
					}
				}
			}

			std::set<std::string> _HiddenDevices;
			bool bAllowDeviceToBeHidden = false;

			int ii = 0;
			if (rfilter == ""all"")
			{
				if (
					(bShowScenes) &&
					((rused == ""all"") || (rused == ""true""))
					)
				{
					if (rowid != """")
						result = m_sql.safe_query(
							""SELECT A.ID, A.Name, A.nValue, A.LastUpdate, A.Favorite, A.SceneType,""
							"" A.Protected, B.XOffset, B.YOffset, B.PlanID, A.Description""
							"" FROM Scenes as A""
							"" LEFT OUTER JOIN DeviceToPlansMap as B ON (B.DeviceRowID==a.ID) AND (B.DevSceneType==1)""
							"" WHERE (A.ID=='%q')"",
							rowid.c_str());
					else if ((planID != """") && (planID != ""0""))
						result = m_sql.safe_query(
							""SELECT A.ID, A.Name, A.nValue, A.LastUpdate, A.Favorite, A.SceneType,""
							"" A.Protected, B.XOffset, B.YOffset, B.PlanID, A.Description""
							"" FROM Scenes as A, DeviceToPlansMap as B WHERE (B.PlanID=='%q')""
							"" AND (B.DeviceRowID==a.ID) AND (B.DevSceneType==1) ORDER BY B.[Order]"",
							planID.c_str());
					else if ((floorID != """") && (floorID != ""0""))
						result = m_sql.safe_query(
							""SELECT A.ID, A.Name, A.nValue, A.LastUpdate, A.Favorite, A.SceneType,""
							"" A.Protected, B.XOffset, B.YOffset, B.PlanID, A.Description""
							"" FROM Scenes as A, DeviceToPlansMap as B, Plans as C""
							"" WHERE (C.FloorplanID=='%q') AND (C.ID==B.PlanID) AND (B.DeviceRowID==a.ID)""
							"" AND (B.DevSceneType==1) ORDER BY B.[Order]"",
							floorID.c_str());
					else {
						szQuery = (
							""SELECT A.ID, A.Name, A.nValue, A.LastUpdate, A.Favorite, A.SceneType,""
							"" A.Protected, B.XOffset, B.YOffset, B.PlanID, A.Description""
							"" FROM Scenes as A""
							"" LEFT OUTER JOIN DeviceToPlansMap as B ON (B.DeviceRowID==a.ID) AND (B.DevSceneType==1)""
							"" ORDER BY "");
						szQuery += szOrderBy;
                                                result = m_sql.safe_query(szQuery.c_str(), order.c_str());
					}

					if (!result.empty())
					{
						for (const auto & itt : result)
						{
							std::vector<std::string> sd = itt;

							unsigned char favorite = atoi(sd[4].c_str());
							if ((bFetchFavorites) && (!favorite))
								continue;

							std::string sLastUpdate = sd[3];

							if (iLastUpdate != 0)
							{
								time_t cLastUpdate;
								ParseSQLdatetime(cLastUpdate, tLastUpdate, sLastUpdate, tm1.tm_isdst);
								if (cLastUpdate <= iLastUpdate)
									continue;
							}

							int nValue = atoi(sd[2].c_str());

							unsigned char scenetype = atoi(sd[5].c_str());
							int iProtected = atoi(sd[6].c_str());

							std::string sSceneName = sd[1];
							if (!bDisplayHidden && sSceneName[0] == '$')
							{
								continue;
							}

							if (scenetype == 0)
							{
								root[""result""][ii][""Type""] = ""Scene"";
								root[""result""][ii][""TypeImg""] = ""scene"";
							}
							else
							{
								root[""result""][ii][""Type""] = ""Group"";
								root[""result""][ii][""TypeImg""] = ""group"";
							}

							std::string thisIdx = sd[0];

							if ((ii > 0) && thisIdx == root[""result""][ii - 1][""idx""].asString()) {
								std::string typeOfThisOne = root[""result""][ii][""Type""].asString();
								if (typeOfThisOne == root[""result""][ii - 1][""Type""].asString()) {
									root[""result""][ii - 1][""PlanIDs""].append(atoi(sd[9].c_str()));
									continue;
								}
							}

							root[""result""][ii][""idx""] = sd[0];
							root[""result""][ii][""Name""] = sSceneName;
							root[""result""][ii][""Description""] = sd[10];
							root[""result""][ii][""Favorite""] = favorite;
							root[""result""][ii][""Protected""] = (iProtected != 0);
							root[""result""][ii][""LastUpdate""] = sLastUpdate;
							root[""result""][ii][""PlanID""] = sd[9].c_str();
							Json::Value jsonArray;
							jsonArray.append(atoi(sd[9].c_str()));
							root[""result""][ii][""PlanIDs""] = jsonArray;

							if (nValue == 0)
								root[""result""][ii][""Status""] = ""Off"";
							else if (nValue == 1)
								root[""result""][ii][""Status""] = ""On"";
							else
								root[""result""][ii][""Status""] = ""Mixed"";
							root[""result""][ii][""Data""] = root[""result""][ii][""Status""];
							uint64_t camIDX = m_mainworker.m_cameras.IsDevSceneInCamera(1, sd[0]);
							root[""result""][ii][""UsedByCamera""] = (camIDX != 0) ? true : false;
							if (camIDX != 0) {
								std::stringstream scidx;
								scidx << camIDX;
								root[""result""][ii][""CameraIdx""] = scidx.str();
							}
							root[""result""][ii][""XOffset""] = atoi(sd[7].c_str());
							root[""result""][ii][""YOffset""] = atoi(sd[8].c_str());
							ii++;
						}
					}
				}
			}

			char szData[250];
			if (totUserDevices == 0)
			{
				if (rowid != """")
				{
					result = m_sql.safe_query(
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used, A.Type, A.SubType,""
						"" A.SignalLevel, A.BatteryLevel, A.nValue, A.sValue,""
						"" A.LastUpdate, A.Favorite, A.SwitchType, A.HardwareID,""
						"" A.AddjValue, A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1, A.StrParam2,""
						"" A.Protected, IFNULL(B.XOffset,0), IFNULL(B.YOffset,0), IFNULL(B.PlanID,0), A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus A LEFT OUTER JOIN DeviceToPlansMap as B ON (B.DeviceRowID==a.ID) ""
						""WHERE (A.ID=='%q')"",
						rowid.c_str());
				}
				else if ((planID != """") && (planID != ""0""))
					result = m_sql.safe_query(
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,""
						"" A.Type, A.SubType, A.SignalLevel, A.BatteryLevel,""
						"" A.nValue, A.sValue, A.LastUpdate, A.Favorite,""
						"" A.SwitchType, A.HardwareID, A.AddjValue,""
						"" A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1,""
						"" A.StrParam2, A.Protected, B.XOffset, B.YOffset,""
						"" B.PlanID, A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus as A, DeviceToPlansMap as B ""
						""WHERE (B.PlanID=='%q') AND (B.DeviceRowID==a.ID)""
						"" AND (B.DevSceneType==0) ORDER BY B.[Order]"",
						planID.c_str());
				else if ((floorID != """") && (floorID != ""0""))
					result = m_sql.safe_query(
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,""
						"" A.Type, A.SubType, A.SignalLevel, A.BatteryLevel,""
						"" A.nValue, A.sValue, A.LastUpdate, A.Favorite,""
						"" A.SwitchType, A.HardwareID, A.AddjValue,""
						"" A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1,""
						"" A.StrParam2, A.Protected, B.XOffset, B.YOffset,""
						"" B.PlanID, A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus as A, DeviceToPlansMap as B,""
						"" Plans as C ""
						""WHERE (C.FloorplanID=='%q') AND (C.ID==B.PlanID)""
						"" AND (B.DeviceRowID==a.ID) AND (B.DevSceneType==0) ""
						""ORDER BY B.[Order]"",
						floorID.c_str());
				else {
					if (!bDisplayHidden)
					{
						result = m_sql.safe_query(""SELECT ID FROM Plans WHERE (Name=='$Hidden Devices')"");
						if (!result.empty())
						{
							std::string pID = result[0][0];
							result = m_sql.safe_query(""SELECT DeviceRowID FROM DeviceToPlansMap WHERE (PlanID=='%q') AND (DevSceneType==0)"",
								pID.c_str());
							if (!result.empty())
							{
								std::vector<std::vector<std::string> >::const_iterator ittP;
								for (ittP = result.begin(); ittP != result.end(); ++ittP)
								{
									_HiddenDevices.insert(ittP[0][0]);
								}
							}
						}
						bAllowDeviceToBeHidden = true;
					}

					if (order.empty() || (!isAlpha))
						strcpy(szOrderBy, ""A.[Order],A.LastUpdate DESC"");
					else
					{
						sprintf(szOrderBy, ""A.[Order],A.%%s ASC"");
					}
					if (hardwareid != """") {
						szQuery = (
							""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,A.Type, A.SubType,""
							"" A.SignalLevel, A.BatteryLevel, A.nValue, A.sValue,""
							"" A.LastUpdate, A.Favorite, A.SwitchType, A.HardwareID,""
							"" A.AddjValue, A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
							"" A.LastLevel, A.CustomImage, A.StrParam1, A.StrParam2,""
							"" A.Protected, IFNULL(B.XOffset,0), IFNULL(B.YOffset,0), IFNULL(B.PlanID,0), A.Description,""
							"" A.Options, A.Color ""
							""FROM DeviceStatus as A LEFT OUTER JOIN DeviceToPlansMap as B ""
							""ON (B.DeviceRowID==a.ID) AND (B.DevSceneType==0) ""
							""WHERE (A.HardwareID == %q) ""
							""ORDER BY "");
						szQuery += szOrderBy;
						result = m_sql.safe_query(szQuery.c_str(), hardwareid.c_str(), order.c_str());
					}
					else {
						szQuery = (
							""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,A.Type, A.SubType,""
							"" A.SignalLevel, A.BatteryLevel, A.nValue, A.sValue,""
							"" A.LastUpdate, A.Favorite, A.SwitchType, A.HardwareID,""
							"" A.AddjValue, A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
							"" A.LastLevel, A.CustomImage, A.StrParam1, A.StrParam2,""
							"" A.Protected, IFNULL(B.XOffset,0), IFNULL(B.YOffset,0), IFNULL(B.PlanID,0), A.Description,""
							"" A.Options, A.Color ""
							""FROM DeviceStatus as A LEFT OUTER JOIN DeviceToPlansMap as B ""
							""ON (B.DeviceRowID==a.ID) AND (B.DevSceneType==0) ""
							""ORDER BY "");
						szQuery += szOrderBy;
						result = m_sql.safe_query(szQuery.c_str(), order.c_str());
					}
				}
			}
			else
			{
				if (iUser == -1) {
					return;
				}
				if (rowid != """")
				{
					result = m_sql.safe_query(
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,""
						"" A.Type, A.SubType, A.SignalLevel, A.BatteryLevel,""
						"" A.nValue, A.sValue, A.LastUpdate, A.Favorite,""
						"" A.SwitchType, A.HardwareID, A.AddjValue,""
						"" A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1,""
						"" A.StrParam2, A.Protected, 0 as XOffset,""
						"" 0 as YOffset, 0 as PlanID, A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus as A, SharedDevices as B ""
						""WHERE (B.DeviceRowID==a.ID)""
						"" AND (B.SharedUserID==%lu) AND (A.ID=='%q')"",
						m_users[iUser].ID, rowid.c_str());
				}
				else if ((planID != """") && (planID != ""0""))
					result = m_sql.safe_query(
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,""
						"" A.Type, A.SubType, A.SignalLevel, A.BatteryLevel,""
						"" A.nValue, A.sValue, A.LastUpdate, A.Favorite,""
						"" A.SwitchType, A.HardwareID, A.AddjValue,""
						"" A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1,""
						"" A.StrParam2, A.Protected, C.XOffset,""
						"" C.YOffset, C.PlanID, A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus as A, SharedDevices as B,""
						"" DeviceToPlansMap as C ""
						""WHERE (C.PlanID=='%q') AND (C.DeviceRowID==a.ID)""
						"" AND (B.DeviceRowID==a.ID) ""
						""AND (B.SharedUserID==%lu) ORDER BY C.[Order]"",
						planID.c_str(), m_users[iUser].ID);
				else if ((floorID != """") && (floorID != ""0""))
					result = m_sql.safe_query(
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,""
						"" A.Type, A.SubType, A.SignalLevel, A.BatteryLevel,""
						"" A.nValue, A.sValue, A.LastUpdate, A.Favorite,""
						"" A.SwitchType, A.HardwareID, A.AddjValue,""
						"" A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1,""
						"" A.StrParam2, A.Protected, C.XOffset, C.YOffset,""
						"" C.PlanID, A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus as A, SharedDevices as B,""
						"" DeviceToPlansMap as C, Plans as D ""
						""WHERE (D.FloorplanID=='%q') AND (D.ID==C.PlanID)""
						"" AND (C.DeviceRowID==a.ID) AND (B.DeviceRowID==a.ID)""
						"" AND (B.SharedUserID==%lu) ORDER BY C.[Order]"",
						floorID.c_str(), m_users[iUser].ID);
				else {
					if (!bDisplayHidden)
					{
						result = m_sql.safe_query(""SELECT ID FROM Plans WHERE (Name=='$Hidden Devices')"");
						if (!result.empty())
						{
							std::string pID = result[0][0];
							result = m_sql.safe_query(""SELECT DeviceRowID FROM DeviceToPlansMap WHERE (PlanID=='%q')  AND (DevSceneType==0)"",
								pID.c_str());
							if (!result.empty())
							{
								std::vector<std::vector<std::string> >::const_iterator ittP;
								for (ittP = result.begin(); ittP != result.end(); ++ittP)
								{
									_HiddenDevices.insert(ittP[0][0]);
								}
							}
						}
						bAllowDeviceToBeHidden = true;
					}

					if (order.empty() || (!isAlpha))
					{
						strcpy(szOrderBy, ""A.[Order],A.LastUpdate DESC"");
					}
					else
					{
						sprintf(szOrderBy, ""A.[Order],A.%%s ASC"");
					}
					szQuery = (
						""SELECT A.ID, A.DeviceID, A.Unit, A.Name, A.Used,""
						"" A.Type, A.SubType, A.SignalLevel, A.BatteryLevel,""
						"" A.nValue, A.sValue, A.LastUpdate, A.Favorite,""
						"" A.SwitchType, A.HardwareID, A.AddjValue,""
						"" A.AddjMulti, A.AddjValue2, A.AddjMulti2,""
						"" A.LastLevel, A.CustomImage, A.StrParam1,""
						"" A.StrParam2, A.Protected, IFNULL(C.XOffset,0),""
						"" IFNULL(C.YOffset,0), IFNULL(C.PlanID,0), A.Description,""
						"" A.Options, A.Color ""
						""FROM DeviceStatus as A, SharedDevices as B ""
						""LEFT OUTER JOIN DeviceToPlansMap as C  ON (C.DeviceRowID==A.ID)""
						""WHERE (B.DeviceRowID==A.ID)""
						"" AND (B.SharedUserID==%lu) ORDER BY "");
					szQuery += szOrderBy;
					result = m_sql.safe_query(szQuery.c_str(), m_users[iUser].ID, order.c_str());
				}
			}

			if (!result.empty())
			{
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					unsigned char favorite = atoi(sd[12].c_str());
					if ((planID != """") && (planID != ""0""))
						favorite = 1;

					if ((bFetchFavorites) && (!favorite))
						continue;

					std::string sDeviceName = sd[3];

					if (!bDisplayHidden)
					{
						if (_HiddenDevices.find(sd[0]) != _HiddenDevices.end())
							continue;
						if (sDeviceName[0] == '$')
						{
							if (bAllowDeviceToBeHidden)
								continue;
							if (planID.size() > 0)
								sDeviceName = sDeviceName.substr(1);
						}
					}
					int hardwareID = atoi(sd[14].c_str());
					std::map<int, _tHardwareListInt>::iterator hItt = _hardwareNames.find(hardwareID);
					if (hItt != _hardwareNames.end())
					{
						if ((!bDisplayDisabled) && (!(*hItt).second.Enabled))
							continue;
					}

					unsigned int dType = atoi(sd[5].c_str());
					unsigned int dSubType = atoi(sd[6].c_str());
					unsigned int used = atoi(sd[4].c_str());
					int nValue = atoi(sd[9].c_str());
					std::string sValue = sd[10];
					std::string sLastUpdate = sd[11];
					if (sLastUpdate.size() > 19)
						sLastUpdate = sLastUpdate.substr(0, 19);

					if (iLastUpdate != 0)
					{
						time_t cLastUpdate;
						ParseSQLdatetime(cLastUpdate, tLastUpdate, sLastUpdate, tm1.tm_isdst);
						if (cLastUpdate <= iLastUpdate)
							continue;
					}

					_eSwitchType switchtype = (_eSwitchType)atoi(sd[13].c_str());
					_eMeterType metertype = (_eMeterType)switchtype;
					double AddjValue = atof(sd[15].c_str());
					double AddjMulti = atof(sd[16].c_str());
					double AddjValue2 = atof(sd[17].c_str());
					double AddjMulti2 = atof(sd[18].c_str());
					int LastLevel = atoi(sd[19].c_str());
					int CustomImage = atoi(sd[20].c_str());
					std::string strParam1 = base64_encode(sd[21]);
					std::string strParam2 = base64_encode(sd[22]);
					int iProtected = atoi(sd[23].c_str());

					std::string Description = sd[27];
					std::string sOptions = sd[28];
					std::string sColor = sd[29];
					std::map<std::string, std::string> options = m_sql.BuildDeviceOptions(sOptions);

					struct tm ntime;
					time_t checktime;
					ParseSQLdatetime(checktime, ntime, sLastUpdate, tm1.tm_isdst);
					bool bHaveTimeout = (now - checktime >= SensorTimeOut * 60);

					if (dType == pTypeTEMP_RAIN)
						continue; //dont want you for now

					if ((rused == ""true"") && (!used))
						continue;

					if (
						(rused == ""false"") &&
						(used)
						)
						continue;
					if (rfilter != """")
					{
						if (rfilter == ""light"")
						{
							if (
								(dType != pTypeLighting1) &&
								(dType != pTypeLighting2) &&
								(dType != pTypeLighting3) &&
								(dType != pTypeLighting4) &&
								(dType != pTypeLighting5) &&
								(dType != pTypeLighting6) &&
								(dType != pTypeFan) &&
								(dType != pTypeColorSwitch) &&
								(dType != pTypeSecurity1) &&
								(dType != pTypeSecurity2) &&
								(dType != pTypeEvohome) &&
								(dType != pTypeEvohomeRelay) &&
								(dType != pTypeCurtain) &&
								(dType != pTypeBlinds) &&
								(dType != pTypeRFY) &&
								(dType != pTypeChime) &&
								(dType != pTypeThermostat2) &&
								(dType != pTypeThermostat3) &&
								(dType != pTypeThermostat4) &&
								(dType != pTypeRemote) &&
								(dType != pTypeGeneralSwitch) &&
								(dType != pTypeHomeConfort) &&
								(dType != pTypeChime) &&
								(dType != pTypeFS20) &&
								(!((dType == pTypeRego6XXValue) && (dSubType == sTypeRego6XXStatus))) &&
								(!((dType == pTypeRadiator1) && (dSubType == sTypeSmartwaresSwitchRadiator)))
								)
								continue;
						}
						else if (rfilter == ""temp"")
						{
							if (
								(dType != pTypeTEMP) &&
								(dType != pTypeHUM) &&
								(dType != pTypeTEMP_HUM) &&
								(dType != pTypeTEMP_HUM_BARO) &&
								(dType != pTypeTEMP_BARO) &&
								(dType != pTypeEvohomeZone) &&
								(dType != pTypeEvohomeWater) &&
								(!((dType == pTypeWIND) && (dSubType == sTypeWIND4))) &&
								(!((dType == pTypeUV) && (dSubType == sTypeUV3))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeSystemTemp))) &&
								(dType != pTypeThermostat1) &&
								(!((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp))) &&
								(dType != pTypeRego6XXTemp)
								)
								continue;
						}
						else if (rfilter == ""weather"")
						{
							if (
								(dType != pTypeWIND) &&
								(dType != pTypeRAIN) &&
								(dType != pTypeTEMP_HUM_BARO) &&
								(dType != pTypeTEMP_BARO) &&
								(dType != pTypeUV) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeVisibility))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeBaro))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeSolarRadiation)))
								)
								continue;
						}
						else if (rfilter == ""utility"")
						{
							if (
								(dType != pTypeRFXMeter) &&
								(!((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorAD))) &&
								(!((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorVolt))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeVoltage))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeCurrent))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeTextStatus))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeAlert))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypePressure))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeSoilMoisture))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeLeafWetness))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypePercentage))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeWaterflow))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeCustom))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeFan))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeSoundLevel))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeZWaveClock))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeZWaveThermostatMode))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeZWaveThermostatFanMode))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeDistance))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeCounterIncremental))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeManagedCounter))) &&
								(!((dType == pTypeGeneral) && (dSubType == sTypeKwh))) &&
								(dType != pTypeCURRENT) &&
								(dType != pTypeCURRENTENERGY) &&
								(dType != pTypeENERGY) &&
								(dType != pTypePOWER) &&
								(dType != pTypeP1Power) &&
								(dType != pTypeP1Gas) &&
								(dType != pTypeYouLess) &&
								(dType != pTypeAirQuality) &&
								(dType != pTypeLux) &&
								(dType != pTypeUsage) &&
								(!((dType == pTypeRego6XXValue) && (dSubType == sTypeRego6XXCounter))) &&
								(!((dType == pTypeThermostat) && (dSubType == sTypeThermSetpoint))) &&
								(dType != pTypeWEIGHT) &&
								(!((dType == pTypeRadiator1) && (dSubType == sTypeSmartwares)))
								)
								continue;
						}
						else if (rfilter == ""wind"")
						{
							if (
								(dType != pTypeWIND)
								)
								continue;
						}
						else if (rfilter == ""rain"")
						{
							if (
								(dType != pTypeRAIN)
								)
								continue;
						}
						else if (rfilter == ""uv"")
						{
							if (
								(dType != pTypeUV)
								)
								continue;
						}
						else if (rfilter == ""baro"")
						{
							if (
								(dType != pTypeTEMP_HUM_BARO) &&
								(dType != pTypeTEMP_BARO)
								)
								continue;
						}
						else if (rfilter == ""zwavealarms"")
						{
							if (!((dType == pTypeGeneral) && (dSubType == sTypeZWaveAlarm)))
								continue;
						}
					}

					std::string thisIdx = sd[0];
					int devIdx = atoi(thisIdx.c_str());

					if ((ii > 0) && thisIdx == root[""result""][ii - 1][""idx""].asString()) {
						std::string typeOfThisOne = RFX_Type_Desc(dType, 1);
						if (typeOfThisOne == root[""result""][ii - 1][""Type""].asString()) {
							root[""result""][ii - 1][""PlanIDs""].append(atoi(sd[26].c_str()));
							continue;
						}
					}

					root[""result""][ii][""HardwareID""] = hardwareID;
					if (_hardwareNames.find(hardwareID) == _hardwareNames.end())
					{
						root[""result""][ii][""HardwareName""] = ""Unknown?"";
						root[""result""][ii][""HardwareTypeVal""] = 0;
						root[""result""][ii][""HardwareType""] = ""Unknown?"";
					}
					else
					{
						root[""result""][ii][""HardwareName""] = _hardwareNames[hardwareID].Name;
						root[""result""][ii][""HardwareTypeVal""] = _hardwareNames[hardwareID].HardwareTypeVal;
						root[""result""][ii][""HardwareType""] = _hardwareNames[hardwareID].HardwareType;
					}
					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Protected""] = (iProtected != 0);

					CDomoticzHardwareBase *pHardware = m_mainworker.GetHardware(hardwareID);
					if (pHardware != NULL)
					{
						if (pHardware->HwdType == HTYPE_SolarEdgeAPI)
						{
							int seSensorTimeOut = 60 * 24 * 60;
							bHaveTimeout = (now - checktime >= seSensorTimeOut * 60);
						}
						else if (pHardware->HwdType == HTYPE_Wunderground)
						{
							CWunderground *pWHardware = reinterpret_cast<CWunderground *>(pHardware);
							std::string forecast_url = pWHardware->GetForecastURL();
							if (forecast_url != """")
							{
								root[""result""][ii][""forecast_url""] = base64_encode(forecast_url);
							}
						}
						else if (pHardware->HwdType == HTYPE_DarkSky)
						{
							CDarkSky *pWHardware = reinterpret_cast<CDarkSky*>(pHardware);
							std::string forecast_url = pWHardware->GetForecastURL();
							if (forecast_url != """")
							{
								root[""result""][ii][""forecast_url""] = base64_encode(forecast_url);
							}
						}
						else if (pHardware->HwdType == HTYPE_AccuWeather)
						{
							CAccuWeather *pWHardware = reinterpret_cast<CAccuWeather*>(pHardware);
							std::string forecast_url = pWHardware->GetForecastURL();
							if (forecast_url != """")
							{
								root[""result""][ii][""forecast_url""] = base64_encode(forecast_url);
							}
						}
						else if (pHardware->HwdType == HTYPE_OpenWeatherMap)
						{
							COpenWeatherMap *pWHardware = reinterpret_cast<COpenWeatherMap*>(pHardware);
							std::string forecast_url = pWHardware->GetForecastURL();
							if (forecast_url != """")
							{
								root[""result""][ii][""forecast_url""] = base64_encode(forecast_url);
							}
						}
					}

					if ((pHardware != NULL) && (pHardware->HwdType == HTYPE_PythonPlugin))
					{
						root[""result""][ii][""ID""] = sd[1];
					}
					else
					{
						sprintf(szData, ""%04X"", (unsigned int)atoi(sd[1].c_str()));
						if (
							(dType == pTypeTEMP) ||
							(dType == pTypeTEMP_BARO) ||
							(dType == pTypeTEMP_HUM) ||
							(dType == pTypeTEMP_HUM_BARO) ||
							(dType == pTypeBARO) ||
							(dType == pTypeHUM) ||
							(dType == pTypeWIND) ||
							(dType == pTypeRAIN) ||
							(dType == pTypeUV) ||
							(dType == pTypeCURRENT) ||
							(dType == pTypeCURRENTENERGY) ||
							(dType == pTypeENERGY) ||
							(dType == pTypeRFXMeter) ||
							(dType == pTypeAirQuality) ||
							(dType == pTypeRFXSensor) ||
							(dType == pTypeP1Power) ||
							(dType == pTypeP1Gas)
							)
						{
							root[""result""][ii][""ID""] = szData;
						}
						else
						{
							root[""result""][ii][""ID""] = sd[1];
						}
					}
					root[""result""][ii][""Unit""] = atoi(sd[2].c_str());
					root[""result""][ii][""Type""] = RFX_Type_Desc(dType, 1);
					root[""result""][ii][""SubType""] = RFX_Type_SubType_Desc(dType, dSubType);
					root[""result""][ii][""TypeImg""] = RFX_Type_Desc(dType, 2);
					root[""result""][ii][""Name""] = sDeviceName;
					root[""result""][ii][""Description""] = Description;
					root[""result""][ii][""Used""] = used;
					root[""result""][ii][""Favorite""] = favorite;

					int iSignalLevel = atoi(sd[7].c_str());
					if (iSignalLevel < 12)
						root[""result""][ii][""SignalLevel""] = iSignalLevel;
					else
						root[""result""][ii][""SignalLevel""] = ""-"";
					root[""result""][ii][""BatteryLevel""] = atoi(sd[8].c_str());
					root[""result""][ii][""LastUpdate""] = sLastUpdate;
					root[""result""][ii][""CustomImage""] = CustomImage;
					root[""result""][ii][""XOffset""] = sd[24].c_str();
					root[""result""][ii][""YOffset""] = sd[25].c_str();
					root[""result""][ii][""PlanID""] = sd[26].c_str();
					Json::Value jsonArray;
					jsonArray.append(atoi(sd[26].c_str()));
					root[""result""][ii][""PlanIDs""] = jsonArray;
					root[""result""][ii][""AddjValue""] = AddjValue;
					root[""result""][ii][""AddjMulti""] = AddjMulti;
					root[""result""][ii][""AddjValue2""] = AddjValue2;
					root[""result""][ii][""AddjMulti2""] = AddjMulti2;

					std::stringstream s_data;
					s_data << int(nValue) << "", "" << sValue;
					root[""result""][ii][""Data""] = s_data.str();

					root[""result""][ii][""Notifications""] = (m_notifications.HasNotifications(sd[0]) == true) ? ""true"" : ""false"";
					root[""result""][ii][""ShowNotifications""] = true;

					bool bHasTimers = false;

					if (
						(dType == pTypeLighting1) ||
						(dType == pTypeLighting2) ||
						(dType == pTypeLighting3) ||
						(dType == pTypeLighting4) ||
						(dType == pTypeLighting5) ||
						(dType == pTypeLighting6) ||
						(dType == pTypeFan) ||
						(dType == pTypeColorSwitch) ||
						(dType == pTypeCurtain) ||
						(dType == pTypeBlinds) ||
						(dType == pTypeRFY) ||
						(dType == pTypeChime) ||
						(dType == pTypeThermostat2) ||
						(dType == pTypeThermostat3) ||
						(dType == pTypeThermostat4) ||
						(dType == pTypeRemote) ||
						(dType == pTypeGeneralSwitch) ||
						(dType == pTypeHomeConfort) ||
						(dType == pTypeFS20) ||
						((dType == pTypeRadiator1) && (dSubType == sTypeSmartwaresSwitchRadiator)) ||
						((dType == pTypeRego6XXValue) && (dSubType == sTypeRego6XXStatus))
						)
					{
						bHasTimers = m_sql.HasTimers(sd[0]);

						bHaveTimeout = false;
#ifdef WITH_OPENZWAVE
						if (pHardware != NULL)
						{
							if (pHardware->HwdType == HTYPE_OpenZWave)
							{
								COpenZWave *pZWave = reinterpret_cast<COpenZWave*>(pHardware);
								unsigned long ID;
								std::stringstream s_strid;
								s_strid << std::hex << sd[1];
								s_strid >> ID;
								int nodeID = (ID & 0x0000FF00) >> 8;
								bHaveTimeout = pZWave->HasNodeFailed(nodeID);
							}
						}
#endif
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;

						std::string lstatus = """";
						int llevel = 0;
						bool bHaveDimmer = false;
						bool bHaveGroupCmd = false;
						int maxDimLevel = 0;

						GetLightStatus(dType, dSubType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);

						root[""result""][ii][""Status""] = lstatus;
						root[""result""][ii][""StrParam1""] = strParam1;
						root[""result""][ii][""StrParam2""] = strParam2;

						std::string IconFile = ""Light"";
						std::map<int, int>::const_iterator ittIcon = m_custom_light_icons_lookup.find(CustomImage);
						if (ittIcon != m_custom_light_icons_lookup.end())
						{
							IconFile = m_custom_light_icons[ittIcon->second].RootFile;
						}
						root[""result""][ii][""Image""] = IconFile;

						if (switchtype == STYPE_Dimmer)
						{
							root[""result""][ii][""Level""] = LastLevel;
							int iLevel = round((float(maxDimLevel) / 100.0f)*LastLevel);
							root[""result""][ii][""LevelInt""] = iLevel;
							if ((dType == pTypeColorSwitch) ||
							    (dType == pTypeLighting5 && dSubType == sTypeTRC02) ||
							    (dType == pTypeLighting5 && dSubType == sTypeTRC02_2) ||
							    (dType == pTypeGeneralSwitch && dSubType == sSwitchTypeTRC02) ||
							    (dType == pTypeGeneralSwitch && dSubType == sSwitchTypeTRC02_2))
							{
								_tColor color(sColor);
								std::string jsonColor = color.toJSONString();
								root[""result""][ii][""Color""] = jsonColor;
								llevel = LastLevel;
								if (lstatus == ""Set Level"" || lstatus == ""Set Color"")
								{
									sprintf(szTmp, ""Set Level: %d %%"", LastLevel);
									root[""result""][ii][""Status""] = szTmp;
								}
							}
						}
						else
						{
							root[""result""][ii][""Level""] = llevel;
							root[""result""][ii][""LevelInt""] = atoi(sValue.c_str());
						}
						root[""result""][ii][""HaveDimmer""] = bHaveDimmer;
						std::string DimmerType = ""none"";
						if (switchtype == STYPE_Dimmer)
						{
							DimmerType = ""abs"";
							if (_hardwareNames.find(hardwareID) != _hardwareNames.end())
							{
								if (_hardwareNames[hardwareID].HardwareTypeVal == HTYPE_LimitlessLights &&
								    atoi(_hardwareNames[hardwareID].Mode2.c_str()) != CLimitLess::LBTYPE_V6 &&
									(atoi(_hardwareNames[hardwareID].Mode1.c_str()) == sTypeColor_RGB ||
									 atoi(_hardwareNames[hardwareID].Mode1.c_str()) == sTypeColor_White ||
									 atoi(_hardwareNames[hardwareID].Mode1.c_str()) == sTypeColor_CW_WW))
								{
									DimmerType = ""rel"";
								}
							}
						}
						root[""result""][ii][""DimmerType""] = DimmerType;
						root[""result""][ii][""MaxDimLevel""] = maxDimLevel;
						root[""result""][ii][""HaveGroupCmd""] = bHaveGroupCmd;
						root[""result""][ii][""SwitchType""] = Switch_Type_Desc(switchtype);
						root[""result""][ii][""SwitchTypeVal""] = switchtype;
						uint64_t camIDX = m_mainworker.m_cameras.IsDevSceneInCamera(0, sd[0]);
						root[""result""][ii][""UsedByCamera""] = (camIDX != 0) ? true : false;
						if (camIDX != 0) {
							std::stringstream scidx;
							scidx << camIDX;
							root[""result""][ii][""CameraIdx""] = scidx.str();
						}

						bool bIsSubDevice = false;
						std::vector<std::vector<std::string> > resultSD;
						resultSD = m_sql.safe_query(""SELECT ID FROM LightSubDevices WHERE (DeviceRowID=='%q')"",
							sd[0].c_str());
						bIsSubDevice = (resultSD.size() > 0);

						root[""result""][ii][""IsSubDevice""] = bIsSubDevice;

						if (switchtype == STYPE_Doorbell)
						{
							root[""result""][ii][""TypeImg""] = ""doorbell"";
							root[""result""][ii][""Status""] = """";//""Pressed"";
						}
						else if (switchtype == STYPE_DoorContact)
						{
							if (CustomImage == 0)
							{
								root[""result""][ii][""Image""] = ""Door"";
							}
							root[""result""][ii][""TypeImg""] = ""door"";
							bool bIsOn = IsLightSwitchOn(lstatus);
							root[""result""][ii][""InternalState""] = (bIsOn == true) ? ""Open"" : ""Closed"";
							if (bIsOn) {
								lstatus = ""Open"";
							}
							else {
								lstatus = ""Closed"";
							}
							root[""result""][ii][""Status""] = lstatus;
						}
						else if (switchtype == STYPE_DoorLock)
						{
							if (CustomImage == 0)
							{
								root[""result""][ii][""Image""] = ""Door"";
							}
							root[""result""][ii][""TypeImg""] = ""door"";
							bool bIsOn = IsLightSwitchOn(lstatus);
							root[""result""][ii][""InternalState""] = (bIsOn == true) ? ""Locked"" : ""Unlocked"";
							if (bIsOn) {
								lstatus = ""Locked"";
							}
							else {
								lstatus = ""Unlocked"";
							}
							root[""result""][ii][""Status""] = lstatus;
						}
						else if (switchtype == STYPE_DoorLockInverted)
						{
							if (CustomImage == 0)
							{
								root[""result""][ii][""Image""] = ""Door"";
							}
							root[""result""][ii][""TypeImg""] = ""door"";
							bool bIsOn = IsLightSwitchOn(lstatus);
							root[""result""][ii][""InternalState""] = (bIsOn == true) ? ""Unlocked"" : ""Locked"";
							if (bIsOn) {
								lstatus = ""Unlocked"";
							}
							else {
								lstatus = ""Locked"";
							}
							root[""result""][ii][""Status""] = lstatus;
						}
						else if (switchtype == STYPE_PushOn)
						{
							if (CustomImage == 0)
							{
								root[""result""][ii][""Image""] = ""Push"";
							}
							root[""result""][ii][""TypeImg""] = ""push"";
							root[""result""][ii][""Status""] = """";
							root[""result""][ii][""InternalState""] = (IsLightSwitchOn(lstatus) == true) ? ""On"" : ""Off"";
						}
						else if (switchtype == STYPE_PushOff)
						{
							if (CustomImage == 0)
							{
								root[""result""][ii][""Image""] = ""Push"";
							}
							root[""result""][ii][""TypeImg""] = ""push"";
							root[""result""][ii][""Status""] = """";
							root[""result""][ii][""TypeImg""] = ""pushoff"";
						}
						else if (switchtype == STYPE_X10Siren)
							root[""result""][ii][""TypeImg""] = ""siren"";
						else if (switchtype == STYPE_SMOKEDETECTOR)
						{
							root[""result""][ii][""TypeImg""] = ""smoke"";
							root[""result""][ii][""SwitchTypeVal""] = STYPE_SMOKEDETECTOR;
							root[""result""][ii][""SwitchType""] = Switch_Type_Desc(STYPE_SMOKEDETECTOR);
						}
						else if (switchtype == STYPE_Contact)
						{
							if (CustomImage == 0)
							{
								root[""result""][ii][""Image""] = ""Contact"";
							}
							root[""result""][ii][""TypeImg""] = ""contact"";
							bool bIsOn = IsLightSwitchOn(lstatus);
							if (bIsOn) {
								lstatus = ""Open"";
							}
							else {
								lstatus = ""Closed"";
							}
							root[""result""][ii][""Status""] = lstatus;
						}
						else if (switchtype == STYPE_Media)
						{
							if ((pHardware != NULL) && (pHardware->HwdType == HTYPE_LogitechMediaServer))
								root[""result""][ii][""TypeImg""] = ""LogitechMediaServer"";
							else
								root[""result""][ii][""TypeImg""] = ""Media"";
							root[""result""][ii][""Status""] = Media_Player_States((_eMediaStatus)nValue);
							lstatus = sValue;
						}
						else if (
							(switchtype == STYPE_Blinds) ||
							(switchtype == STYPE_VenetianBlindsUS) ||
							(switchtype == STYPE_VenetianBlindsEU)
							)
						{
							root[""result""][ii][""TypeImg""] = ""blinds"";
							if ((lstatus == ""On"") || (lstatus == ""Close inline relay"")) {
								lstatus = ""Closed"";
							}
							else if ((lstatus == ""Stop"") || (lstatus == ""Stop inline relay"")) {
								lstatus = ""Stopped"";
							}
							else {
								lstatus = ""Open"";
							}
							root[""result""][ii][""Status""] = lstatus;
						}
						else if (switchtype == STYPE_BlindsInverted)
						{
							root[""result""][ii][""TypeImg""] = ""blinds"";
							if (lstatus == ""On"") {
								lstatus = ""Open"";
							}
							else {
								lstatus = ""Closed"";
							}
							root[""result""][ii][""Status""] = lstatus;
						}
						else if ((switchtype == STYPE_BlindsPercentage) || (switchtype == STYPE_BlindsPercentageInverted))
						{
							root[""result""][ii][""TypeImg""] = ""blinds"";
							root[""result""][ii][""Level""] = LastLevel;
							int iLevel = round((float(maxDimLevel) / 100.0f)*LastLevel);
							root[""result""][ii][""LevelInt""] = iLevel;
							if (lstatus == ""On"") {
								lstatus = (switchtype == STYPE_BlindsPercentage) ? ""Closed"" : ""Open"";
							}
							else if (lstatus == ""Off"") {
								lstatus = (switchtype == STYPE_BlindsPercentage) ? ""Open"" : ""Closed"";
							}

							root[""result""][ii][""Status""] = lstatus;
						}
						else if (switchtype == STYPE_Dimmer)
						{
							root[""result""][ii][""TypeImg""] = ""dimmer"";
						}
						else if (switchtype == STYPE_Motion)
						{
							root[""result""][ii][""TypeImg""] = ""motion"";
						}
						else if (switchtype == STYPE_Selector)
						{
							std::string selectorStyle = options[""SelectorStyle""];
							std::string levelOffHidden = options[""LevelOffHidden""];
							std::string levelNames = options[""LevelNames""];
							std::string levelActions = options[""LevelActions""];
							if (selectorStyle.empty()) {
								selectorStyle.assign(""0""); // default is 'button set'
							}
							if (levelOffHidden.empty()) {
								levelOffHidden.assign(""false""); // default is 'not hidden'
							}
							if (levelNames.empty()) {
								levelNames.assign(""Off""); // default is Off only
							}
							root[""result""][ii][""TypeImg""] = ""Light"";
							root[""result""][ii][""SelectorStyle""] = atoi(selectorStyle.c_str());
							root[""result""][ii][""LevelOffHidden""] = (levelOffHidden == ""true"");
							root[""result""][ii][""LevelNames""] = base64_encode(levelNames);
							root[""result""][ii][""LevelActions""] = base64_encode(levelActions);
						}
						sprintf(szData, ""%s"", lstatus.c_str());
						root[""result""][ii][""Data""] = szData;
					}
					else if (dType == pTypeSecurity1)
					{
						std::string lstatus = """";
						int llevel = 0;
						bool bHaveDimmer = false;
						bool bHaveGroupCmd = false;
						int maxDimLevel = 0;

						GetLightStatus(dType, dSubType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);

						root[""result""][ii][""Status""] = lstatus;
						root[""result""][ii][""HaveDimmer""] = bHaveDimmer;
						root[""result""][ii][""MaxDimLevel""] = maxDimLevel;
						root[""result""][ii][""HaveGroupCmd""] = bHaveGroupCmd;
						root[""result""][ii][""SwitchType""] = ""Security"";
						root[""result""][ii][""SwitchTypeVal""] = switchtype; //was 0?;
						root[""result""][ii][""TypeImg""] = ""security"";
						root[""result""][ii][""StrParam1""] = strParam1;
						root[""result""][ii][""StrParam2""] = strParam2;
						root[""result""][ii][""Protected""] = (iProtected != 0);

						if ((dSubType == sTypeKD101) || (dSubType == sTypeSA30) || (switchtype == STYPE_SMOKEDETECTOR))
						{
							root[""result""][ii][""SwitchTypeVal""] = STYPE_SMOKEDETECTOR;
							root[""result""][ii][""TypeImg""] = ""smoke"";
							root[""result""][ii][""SwitchType""] = Switch_Type_Desc(STYPE_SMOKEDETECTOR);
						}
						sprintf(szData, ""%s"", lstatus.c_str());
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""HaveTimeout""] = false;
					}
					else if (dType == pTypeSecurity2)
					{
						std::string lstatus = """";
						int llevel = 0;
						bool bHaveDimmer = false;
						bool bHaveGroupCmd = false;
						int maxDimLevel = 0;

						GetLightStatus(dType, dSubType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);

						root[""result""][ii][""Status""] = lstatus;
						root[""result""][ii][""HaveDimmer""] = bHaveDimmer;
						root[""result""][ii][""MaxDimLevel""] = maxDimLevel;
						root[""result""][ii][""HaveGroupCmd""] = bHaveGroupCmd;
						root[""result""][ii][""SwitchType""] = ""Security"";
						root[""result""][ii][""SwitchTypeVal""] = switchtype; //was 0?;
						root[""result""][ii][""TypeImg""] = ""security"";
						root[""result""][ii][""StrParam1""] = strParam1;
						root[""result""][ii][""StrParam2""] = strParam2;
						root[""result""][ii][""Protected""] = (iProtected != 0);
						sprintf(szData, ""%s"", lstatus.c_str());
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""HaveTimeout""] = false;
					}
					else if (dType == pTypeEvohome || dType == pTypeEvohomeRelay)
					{
						std::string lstatus = """";
						int llevel = 0;
						bool bHaveDimmer = false;
						bool bHaveGroupCmd = false;
						int maxDimLevel = 0;

						GetLightStatus(dType, dSubType, switchtype, nValue, sValue, lstatus, llevel, bHaveDimmer, maxDimLevel, bHaveGroupCmd);

						root[""result""][ii][""Status""] = lstatus;
						root[""result""][ii][""HaveDimmer""] = bHaveDimmer;
						root[""result""][ii][""MaxDimLevel""] = maxDimLevel;
						root[""result""][ii][""HaveGroupCmd""] = bHaveGroupCmd;
						root[""result""][ii][""SwitchType""] = ""evohome"";
						root[""result""][ii][""SwitchTypeVal""] = switchtype; //was 0?;
						root[""result""][ii][""TypeImg""] = ""override_mini"";
						root[""result""][ii][""StrParam1""] = strParam1;
						root[""result""][ii][""StrParam2""] = strParam2;
						root[""result""][ii][""Protected""] = (iProtected != 0);

						sprintf(szData, ""%s"", lstatus.c_str());
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""HaveTimeout""] = false;

						if (dType == pTypeEvohomeRelay)
						{
							root[""result""][ii][""SwitchType""] = ""TPI"";
							root[""result""][ii][""Level""] = llevel;
							root[""result""][ii][""LevelInt""] = atoi(sValue.c_str());
							if (root[""result""][ii][""Unit""].asInt() > 100)
								root[""result""][ii][""Protected""] = true;

							sprintf(szData, ""%s: %d"", lstatus.c_str(), atoi(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
						}
					}
					else if ((dType == pTypeEvohomeZone) || (dType == pTypeEvohomeWater))
					{
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						root[""result""][ii][""TypeImg""] = ""override_mini"";

						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() >= 3)
						{
							int i = 0;
							double tempCelcius = atof(strarray[i++].c_str());
							double temp = ConvertTemperature(tempCelcius, tempsign);
							double tempSetPoint;
							root[""result""][ii][""Temp""] = temp;
							if (dType == pTypeEvohomeZone)
							{
								tempCelcius = atof(strarray[i++].c_str());
								tempSetPoint = ConvertTemperature(tempCelcius, tempsign);
								root[""result""][ii][""SetPoint""] = tempSetPoint;
							}
							else
								root[""result""][ii][""State""] = strarray[i++];

							std::string strstatus = strarray[i++];
							root[""result""][ii][""Status""] = strstatus;

							if ((dType == pTypeEvohomeZone || dType == pTypeEvohomeWater) && strarray.size() >= 4)
							{
								root[""result""][ii][""Until""] = strarray[i++];
							}
							if (dType == pTypeEvohomeZone)
							{
								if (tempCelcius == 325.1)
									sprintf(szTmp, ""Off"");
								else
									sprintf(szTmp, ""%.1f %c"", tempSetPoint, tempsign);
								if (strarray.size() >= 4)
									sprintf(szData, ""%.1f %c, (%s), %s until %s"", temp, tempsign, szTmp, strstatus.c_str(), strarray[3].c_str());
								else
									sprintf(szData, ""%.1f %c, (%s), %s"", temp, tempsign, szTmp, strstatus.c_str());
							}
							else
								if (strarray.size() >= 4)
									sprintf(szData, ""%.1f %c, %s, %s until %s"", temp, tempsign, strarray[1].c_str(), strstatus.c_str(), strarray[3].c_str());
								else
									sprintf(szData, ""%.1f %c, %s, %s"", temp, tempsign, strarray[1].c_str(), strstatus.c_str());
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if ((dType == pTypeTEMP) || (dType == pTypeRego6XXTemp))
					{
						double tvalue = ConvertTemperature(atof(sValue.c_str()), tempsign);
						root[""result""][ii][""Temp""] = tvalue;
						sprintf(szData, ""%.1f %c"", tvalue, tempsign);
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;

						_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
						uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
						if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
						{
							tstate = m_mainworker.m_trend_calculator[tID].m_state;
						}
						root[""result""][ii][""trend""] = (int)tstate;
					}
					else if (dType == pTypeThermostat1)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 4)
						{
							double tvalue = ConvertTemperature(atof(strarray[0].c_str()), tempsign);
							root[""result""][ii][""Temp""] = tvalue;
							sprintf(szData, ""%.1f %c"", tvalue, tempsign);
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if ((dType == pTypeRFXSensor) && (dSubType == sTypeRFXSensorTemp))
					{
						double tvalue = ConvertTemperature(atof(sValue.c_str()), tempsign);
						root[""result""][ii][""Temp""] = tvalue;
						sprintf(szData, ""%.1f %c"", tvalue, tempsign);
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""TypeImg""] = ""temperature"";
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
						uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
						if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
						{
							tstate = m_mainworker.m_trend_calculator[tID].m_state;
						}
						root[""result""][ii][""trend""] = (int)tstate;
					}
					else if (dType == pTypeHUM)
					{
						root[""result""][ii][""Humidity""] = nValue;
						root[""result""][ii][""HumidityStatus""] = RFX_Humidity_Status_Desc(atoi(sValue.c_str()));
						sprintf(szData, ""Humidity %d %%"", nValue);
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
					}
					else if (dType == pTypeTEMP_HUM)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 3)
						{
							double tempCelcius = atof(strarray[0].c_str());
							double temp = ConvertTemperature(tempCelcius, tempsign);
							int humidity = atoi(strarray[1].c_str());

							root[""result""][ii][""Temp""] = temp;
							root[""result""][ii][""Humidity""] = humidity;
							root[""result""][ii][""HumidityStatus""] = RFX_Humidity_Status_Desc(atoi(strarray[2].c_str()));
							sprintf(szData, ""%.1f %c, %d %%"", temp, tempsign, atoi(strarray[1].c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;


							sprintf(szTmp, ""%.2f"", ConvertTemperature(CalculateDewPoint(tempCelcius, humidity), tempsign));
							root[""result""][ii][""DewPoint""] = szTmp;

							_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
							uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
							if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
							{
								tstate = m_mainworker.m_trend_calculator[tID].m_state;
							}
							root[""result""][ii][""trend""] = (int)tstate;
						}
					}
					else if (dType == pTypeTEMP_HUM_BARO)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 5)
						{
							double tempCelcius = atof(strarray[0].c_str());
							double temp = ConvertTemperature(tempCelcius, tempsign);
							int humidity = atoi(strarray[1].c_str());

							root[""result""][ii][""Temp""] = temp;
							root[""result""][ii][""Humidity""] = humidity;
							root[""result""][ii][""HumidityStatus""] = RFX_Humidity_Status_Desc(atoi(strarray[2].c_str()));
							root[""result""][ii][""Forecast""] = atoi(strarray[4].c_str());

							sprintf(szTmp, ""%.2f"", ConvertTemperature(CalculateDewPoint(tempCelcius, humidity), tempsign));
							root[""result""][ii][""DewPoint""] = szTmp;

							if (dSubType == sTypeTHBFloat)
							{
								root[""result""][ii][""Barometer""] = atof(strarray[3].c_str());
								root[""result""][ii][""ForecastStr""] = RFX_WSForecast_Desc(atoi(strarray[4].c_str()));
							}
							else
							{
								root[""result""][ii][""Barometer""] = atoi(strarray[3].c_str());
								root[""result""][ii][""ForecastStr""] = RFX_Forecast_Desc(atoi(strarray[4].c_str()));
							}
							if (dSubType == sTypeTHBFloat)
							{
								sprintf(szData, ""%.1f %c, %d %%, %.1f hPa"",
									temp,
									tempsign,
									atoi(strarray[1].c_str()),
									atof(strarray[3].c_str())
								);
							}
							else
							{
								sprintf(szData, ""%.1f %c, %d %%, %d hPa"",
									temp,
									tempsign,
									atoi(strarray[1].c_str()),
									atoi(strarray[3].c_str())
								);
							}
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;

							_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
							uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
							if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
							{
								tstate = m_mainworker.m_trend_calculator[tID].m_state;
							}
							root[""result""][ii][""trend""] = (int)tstate;
						}
					}
					else if (dType == pTypeTEMP_BARO)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() >= 3)
						{
							double tvalue = ConvertTemperature(atof(strarray[0].c_str()), tempsign);
							root[""result""][ii][""Temp""] = tvalue;
							int forecast = atoi(strarray[2].c_str());
							root[""result""][ii][""Forecast""] = forecast;
							root[""result""][ii][""ForecastStr""] = BMP_Forecast_Desc(forecast);
							root[""result""][ii][""Barometer""] = atof(strarray[1].c_str());

							sprintf(szData, ""%.1f %c, %.1f hPa"",
								tvalue,
								tempsign,
								atof(strarray[1].c_str())
							);
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;

							_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
							uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
							if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
							{
								tstate = m_mainworker.m_trend_calculator[tID].m_state;
							}
							root[""result""][ii][""trend""] = (int)tstate;
						}
					}
					else if (dType == pTypeUV)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 2)
						{
							float UVI = static_cast<float>(atof(strarray[0].c_str()));
							root[""result""][ii][""UVI""] = strarray[0];
							if (dSubType == sTypeUV3)
							{
								double tvalue = ConvertTemperature(atof(strarray[1].c_str()), tempsign);

								root[""result""][ii][""Temp""] = tvalue;
								sprintf(szData, ""%.1f UVI, %.1f&deg; %c"", UVI, tvalue, tempsign);

								_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
								uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
								if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
								{
									tstate = m_mainworker.m_trend_calculator[tID].m_state;
								}
								root[""result""][ii][""trend""] = (int)tstate;
							}
							else
							{
								sprintf(szData, ""%.1f UVI"", UVI);
							}
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if (dType == pTypeWIND)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 6)
						{
							root[""result""][ii][""Direction""] = atof(strarray[0].c_str());
							root[""result""][ii][""DirectionStr""] = strarray[1];

							if (dSubType != sTypeWIND5)
							{
								int intSpeed = atoi(strarray[2].c_str());
								if (m_sql.m_windunit != WINDUNIT_Beaufort)
								{
									sprintf(szTmp, ""%.1f"", float(intSpeed) * m_sql.m_windscale);
								}
								else
								{
									float windms = float(intSpeed) * 0.1f;
									sprintf(szTmp, ""%d"", MStoBeaufort(windms));
								}
								root[""result""][ii][""Speed""] = szTmp;
							}

							{
								int intGust = atoi(strarray[3].c_str());
								if (m_sql.m_windunit != WINDUNIT_Beaufort)
								{
									sprintf(szTmp, ""%.1f"", float(intGust) *m_sql.m_windscale);
								}
								else
								{
									float gustms = float(intGust) * 0.1f;
									sprintf(szTmp, ""%d"", MStoBeaufort(gustms));
								}
								root[""result""][ii][""Gust""] = szTmp;
							}
							if ((dSubType == sTypeWIND4) || (dSubType == sTypeWINDNoTemp))
							{
								if (dSubType == sTypeWIND4)
								{
									double tvalue = ConvertTemperature(atof(strarray[4].c_str()), tempsign);
									root[""result""][ii][""Temp""] = tvalue;
								}
								double tvalue = ConvertTemperature(atof(strarray[5].c_str()), tempsign);
								root[""result""][ii][""Chill""] = tvalue;

								_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
								uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
								if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
								{
									tstate = m_mainworker.m_trend_calculator[tID].m_state;
								}
								root[""result""][ii][""trend""] = (int)tstate;
							}
							root[""result""][ii][""Data""] = sValue;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if (dType == pTypeRAIN)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 2)
						{
							time_t now = mytime(NULL);
							struct tm ltime;
							localtime_r(&now, &ltime);
							char szDate[40];
							sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

							std::vector<std::vector<std::string> > result2;

							if (dSubType != sTypeRAINWU)
							{
								result2 = m_sql.safe_query(
									""SELECT MIN(Total), MAX(Total) FROM Rain WHERE (DeviceRowID='%q' AND Date>='%q')"", sd[0].c_str(), szDate);
							}
							else
							{
								result2 = m_sql.safe_query(
									""SELECT Total, Total FROM Rain WHERE (DeviceRowID='%q' AND Date>='%q') ORDER BY ROWID DESC LIMIT 1"", sd[0].c_str(), szDate);
							}
							if (!result2.empty())
							{
								double total_real = 0;
								float rate = 0;
								std::vector<std::string> sd2 = result2[0];
								if (dSubType != sTypeRAINWU)
								{
									double total_min = atof(sd2[0].c_str());
									double total_max = atof(strarray[1].c_str());
									total_real = total_max - total_min;
								}
								else
								{
									total_real = atof(sd2[1].c_str());
								}
								total_real *= AddjMulti;
								rate = (static_cast<float>(atof(strarray[0].c_str())) / 100.0f)*float(AddjMulti);

								sprintf(szTmp, ""%.1f"", total_real);
								root[""result""][ii][""Rain""] = szTmp;
								sprintf(szTmp, ""%g"", rate);
								root[""result""][ii][""RainRate""] = szTmp;
								root[""result""][ii][""Data""] = sValue;
								root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							}
							else
							{
								root[""result""][ii][""Rain""] = ""0"";
								root[""result""][ii][""RainRate""] = ""0"";
								root[""result""][ii][""Data""] = ""0"";
								root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							}
						}
					}
					else if (dType == pTypeRFXMeter)
					{
						std::string ValueQuantity = options[""ValueQuantity""];
						std::string ValueUnits = options[""ValueUnits""];

						if (ValueQuantity.empty()) {
							ValueQuantity.assign(""Count"");
						}
						if (ValueUnits.empty()) {
							ValueUnits.assign("""");
						}

						time_t now = mytime(NULL);
						struct tm ltime;
						localtime_r(&now, &ltime);
						char szDate[40];
						sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

						std::vector<std::vector<std::string> > result2;
						strcpy(szTmp, ""0"");
						result2 = m_sql.safe_query(""SELECT MIN(Value) FROM Meter WHERE (DeviceRowID='%q' AND Date>='%q')"", sd[0].c_str(), szDate);
						if (!result2.empty())
						{
							std::vector<std::string> sd2 = result2[0];

							uint64_t total_min = std::stoull(sd2[0]);
							uint64_t total_max = std::stoull(sValue);
							uint64_t total_real = total_max - total_min;
							sprintf(szTmp, ""%"" PRIu64, total_real);

							float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));
							float musage = 0.0f;
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f kWh"", musage);
								break;
							case MTYPE_GAS:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f m3"", musage);
								break;
							case MTYPE_WATER:
								musage = float(total_real) / (divider / 1000.0f);
								sprintf(szTmp, ""%d Liter"", round(musage));
								break;
							case MTYPE_COUNTER:
								sprintf(szTmp, ""%"" PRIu64, total_real);
								if (!ValueUnits.empty())
								{
									strcat(szTmp, "" "");
									strcat(szTmp, ValueUnits.c_str());
								}
								break;
							default:
								strcpy(szTmp, ""?"");
								break;
							}
						}
						root[""result""][ii][""CounterToday""] = szTmp;

						root[""result""][ii][""SwitchTypeVal""] = metertype;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						root[""result""][ii][""ValueQuantity""] = """";
						root[""result""][ii][""ValueUnits""] = """";

						double meteroffset = AddjValue;
						float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

						double dvalue = static_cast<double>(atof(sValue.c_str()));

						switch (metertype)
						{
						case MTYPE_ENERGY:
						case MTYPE_ENERGY_GENERATED:
							sprintf(szTmp, ""%.3f kWh"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_GAS:
							sprintf(szTmp, ""%.3f m3"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_WATER:
							sprintf(szTmp, ""%.3f m3"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_COUNTER:
							sprintf(szTmp, ""%g %s"", meteroffset + dvalue, ValueUnits.c_str());
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						default:
							root[""result""][ii][""Data""] = ""?"";
							root[""result""][ii][""Counter""] = ""?"";
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						}
					}
					else if ((dType == pTypeGeneral) && (dSubType == sTypeCounterIncremental))
					{
						std::string ValueQuantity = options[""ValueQuantity""];
						std::string ValueUnits = options[""ValueUnits""];
						if (ValueQuantity.empty()) {
							ValueQuantity.assign(""Count"");
						}
						if (ValueUnits.empty()) {
							ValueUnits.assign("""");
						}
						float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

						time_t now = mytime(NULL);
						struct tm ltime;
						localtime_r(&now, &ltime);
						char szDate[40];
						sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

						std::vector<std::vector<std::string> > result2;
						strcpy(szTmp, ""0"");
						result2 = m_sql.safe_query(""SELECT MIN(Value) FROM Meter WHERE (DeviceRowID='%q' AND Date>='%q')"", sd[0].c_str(), szDate);
						if (!result2.empty())
						{
							std::vector<std::string> sd2 = result2[0];

							uint64_t total_min = std::stoull(sd2[0]);
							uint64_t total_max = std::stoull(sValue);
							uint64_t total_real = total_max - total_min;
							sprintf(szTmp, ""%"" PRIu64, total_real);

							float musage = 0;
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f kWh"", musage);
								break;
							case MTYPE_GAS:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f m3"", musage);
								break;
							case MTYPE_WATER:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f m3"", musage);
								break;
							case MTYPE_COUNTER:
								sprintf(szTmp, ""%"" PRIu64, total_real);
								if (!ValueUnits.empty())
								{
									strcat(szTmp, "" "");
									strcat(szTmp, ValueUnits.c_str());
								}
								break;
							default:
								strcpy(szTmp, ""0"");
								break;
							}
						}
						root[""result""][ii][""Counter""] = sValue;
						root[""result""][ii][""CounterToday""] = szTmp;
						root[""result""][ii][""SwitchTypeVal""] = metertype;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						root[""result""][ii][""TypeImg""] = ""counter"";
						root[""result""][ii][""ValueQuantity""] = """";
						root[""result""][ii][""ValueUnits""] = """";
						double dvalue = static_cast<double>(atof(sValue.c_str()));
						double meteroffset = AddjValue;

						switch (metertype)
						{
						case MTYPE_ENERGY:
						case MTYPE_ENERGY_GENERATED:
							sprintf(szTmp, ""%.3f kWh"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_GAS:
							sprintf(szTmp, ""%.3f m3"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_WATER:
							sprintf(szTmp, ""%.3f m3"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_COUNTER:
							sprintf(szTmp, ""%"" PRIu64 "" %s"", static_cast<uint64_t>(meteroffset + dvalue), ValueUnits.c_str());
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						default:
							root[""result""][ii][""Data""] = ""?"";
							root[""result""][ii][""Counter""] = ""?"";
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						}
					}
					else if ((dType == pTypeGeneral) && (dSubType == sTypeManagedCounter))
					{
						std::string ValueQuantity = options[""ValueQuantity""];
						std::string ValueUnits = options[""ValueUnits""];
						if (ValueQuantity.empty()) {
							ValueQuantity.assign(""Count"");
						}
						if (ValueUnits.empty()) {
							ValueUnits.assign("""");
						}
						float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

						std::vector<std::string> splitresults;
						StringSplit(sValue, "";"", splitresults);
						double dvalue;
						if (splitresults.size() < 2) {
							dvalue = static_cast<double>(atof(sValue.c_str()));
						}
						else {
							dvalue = static_cast<double>(atof(splitresults[1].c_str()));
							if (dvalue < 0.0) {
								dvalue = static_cast<double>(atof(splitresults[0].c_str()));
							}
						}
						root[""result""][ii][""Data""] = root[""result""][ii][""Counter""];

						root[""result""][ii][""SwitchTypeVal""] = metertype;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						root[""result""][ii][""TypeImg""] = ""counter"";
						root[""result""][ii][""ValueQuantity""] = """";
						root[""result""][ii][""ValueUnits""] = """";
						root[""result""][ii][""ShowNotifications""] = false;
						double meteroffset = AddjValue;

						switch (metertype)
						{
						case MTYPE_ENERGY:
						case MTYPE_ENERGY_GENERATED:
							sprintf(szTmp, ""%.3f kWh"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_GAS:
							sprintf(szTmp, ""%.3f m3"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_WATER:
							sprintf(szTmp, ""%.3f m3"", meteroffset + (dvalue / divider));
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							break;
						case MTYPE_COUNTER:
							sprintf(szTmp, ""%g %s"", meteroffset + dvalue, ValueUnits.c_str());
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Counter""] = szTmp;
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						default:
							root[""result""][ii][""Data""] = ""?"";
							root[""result""][ii][""Counter""] = ""?"";
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						}
					}
					else if (dType == pTypeYouLess)
					{
						std::string ValueQuantity = options[""ValueQuantity""];
						std::string ValueUnits = options[""ValueUnits""];
						float musage = 0;
						if (ValueQuantity.empty()) {
							ValueQuantity.assign(""Count"");
						}
						if (ValueUnits.empty()) {
							ValueUnits.assign("""");
						}
						float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

						time_t now = mytime(NULL);
						struct tm ltime;
						localtime_r(&now, &ltime);
						char szDate[40];
						sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

						std::vector<std::vector<std::string> > result2;
						strcpy(szTmp, ""0"");
						result2 = m_sql.safe_query(""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID='%q' AND Date>='%q')"", sd[0].c_str(), szDate);
						if (!result2.empty())
						{
							std::vector<std::string> sd2 = result2[0];

							unsigned long long total_min = std::strtoull(sd2[0].c_str(), nullptr, 10);
							unsigned long long total_max = std::strtoull(sd2[1].c_str(), nullptr, 10);
							unsigned long long total_real;

							total_real = total_max - total_min;
							sprintf(szTmp, ""%llu"", total_real);

							musage = 0;
							switch (metertype)
							{
							case MTYPE_ENERGY:
							case MTYPE_ENERGY_GENERATED:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f kWh"", musage);
								break;
							case MTYPE_GAS:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f m3"", musage);
								break;
							case MTYPE_WATER:
								musage = float(total_real) / divider;
								sprintf(szTmp, ""%.3f m3"", musage);
								break;
							case MTYPE_COUNTER:
								sprintf(szTmp, ""%llu %s"", total_real, ValueUnits.c_str());
								break;
							default:
								strcpy(szTmp, ""0"");
								break;
							}
						}
						root[""result""][ii][""CounterToday""] = szTmp;


						std::vector<std::string> splitresults;
						StringSplit(sValue, "";"", splitresults);
						if (splitresults.size() < 2)
							continue;

						unsigned long long total_actual = std::strtoull(splitresults[0].c_str(), nullptr, 10);
						musage = 0;
						switch (metertype)
						{
						case MTYPE_ENERGY:
						case MTYPE_ENERGY_GENERATED:
							musage = float(total_actual) / divider;
							sprintf(szTmp, ""%.03f"", musage);
							break;
						case MTYPE_GAS:
						case MTYPE_WATER:
							musage = float(total_actual) / divider;
							sprintf(szTmp, ""%.03f"", musage);
							break;
						case MTYPE_COUNTER:
							sprintf(szTmp, ""%llu"", total_actual);
							break;
						default:
							strcpy(szTmp, ""0"");
							break;
						}
						root[""result""][ii][""Counter""] = szTmp;

						root[""result""][ii][""SwitchTypeVal""] = metertype;

						unsigned long long acounter = std::strtoull(sValue.c_str(), nullptr, 10);
						musage = 0;
						switch (metertype)
						{
						case MTYPE_ENERGY:
						case MTYPE_ENERGY_GENERATED:
							musage = float(acounter) / divider;
							sprintf(szTmp, ""%.3f kWh %s Watt"", musage, splitresults[1].c_str());
							break;
						case MTYPE_GAS:
							musage = float(acounter) / divider;
							sprintf(szTmp, ""%.3f m3"", musage);
							break;
						case MTYPE_WATER:
							musage = float(acounter) / divider;
							sprintf(szTmp, ""%.3f m3"", musage);
							break;
						case MTYPE_COUNTER:
							sprintf(szTmp, ""%llu %s"", acounter, ValueUnits.c_str());
							break;
						default:
							strcpy(szTmp, ""0"");
							break;
						}
						root[""result""][ii][""Data""] = szTmp;
						root[""result""][ii][""ValueQuantity""] = """";
						root[""result""][ii][""ValueUnits""] = """";
						switch (metertype)
						{
						case MTYPE_ENERGY:
						case MTYPE_ENERGY_GENERATED:
							sprintf(szTmp, ""%s Watt"", splitresults[1].c_str());
							break;
						case MTYPE_GAS:
							sprintf(szTmp, ""%s m3"", splitresults[1].c_str());
							break;
						case MTYPE_WATER:
							sprintf(szTmp, ""%s m3"", splitresults[1].c_str());
							break;
						case MTYPE_COUNTER:
							sprintf(szTmp, ""%s"", splitresults[1].c_str());
							root[""result""][ii][""ValueQuantity""] = ValueQuantity;
							root[""result""][ii][""ValueUnits""] = ValueUnits;
							break;
						default:
							strcpy(szTmp, ""0"");
							break;
						}

						root[""result""][ii][""Usage""] = szTmp;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
					}
					else if (dType == pTypeP1Power)
					{
						std::vector<std::string> splitresults;
						StringSplit(sValue, "";"", splitresults);
						if (splitresults.size() != 6)
						{
							root[""result""][ii][""SwitchTypeVal""] = MTYPE_ENERGY;
							root[""result""][ii][""Counter""] = ""0"";
							root[""result""][ii][""CounterDeliv""] = ""0"";
							root[""result""][ii][""Usage""] = ""Invalid"";
							root[""result""][ii][""UsageDeliv""] = ""Invalid"";
							root[""result""][ii][""Data""] = ""Invalid!: "" + sValue;
							root[""result""][ii][""HaveTimeout""] = true;
							root[""result""][ii][""CounterToday""] = ""Invalid"";
							root[""result""][ii][""CounterDelivToday""] = ""Invalid"";
						}
						else
						{
							float EnergyDivider = 1000.0f;
							int tValue;
							if (m_sql.GetPreferencesVar(""MeterDividerEnergy"", tValue))
							{
								EnergyDivider = float(tValue);
							}

							unsigned long long powerusage1 = std::strtoull(splitresults[0].c_str(), nullptr, 10);
							unsigned long long powerusage2 = std::strtoull(splitresults[1].c_str(), nullptr, 10);
							unsigned long long powerdeliv1 = std::strtoull(splitresults[2].c_str(), nullptr, 10);
							unsigned long long powerdeliv2 = std::strtoull(splitresults[3].c_str(), nullptr, 10);
							unsigned long long usagecurrent = std::strtoull(splitresults[4].c_str(), nullptr, 10);
							unsigned long long delivcurrent = std::strtoull(splitresults[5].c_str(), nullptr, 10);

							powerdeliv1 = (powerdeliv1 < 10) ? 0 : powerdeliv1;
							powerdeliv2 = (powerdeliv2 < 10) ? 0 : powerdeliv2;

							unsigned long long powerusage = powerusage1 + powerusage2;
							unsigned long long powerdeliv = powerdeliv1 + powerdeliv2;
							if (powerdeliv < 2)
								powerdeliv = 0;

							double musage = 0;

							root[""result""][ii][""SwitchTypeVal""] = MTYPE_ENERGY;
							musage = double(powerusage) / EnergyDivider;
							sprintf(szTmp, ""%.03f"", musage);
							root[""result""][ii][""Counter""] = szTmp;
							musage = double(powerdeliv) / EnergyDivider;
							sprintf(szTmp, ""%.03f"", musage);
							root[""result""][ii][""CounterDeliv""] = szTmp;

							if (bHaveTimeout)
							{
								usagecurrent = 0;
								delivcurrent = 0;
							}
							sprintf(szTmp, ""%llu Watt"", usagecurrent);
							root[""result""][ii][""Usage""] = szTmp;
							sprintf(szTmp, ""%llu Watt"", delivcurrent);
							root[""result""][ii][""UsageDeliv""] = szTmp;
							root[""result""][ii][""Data""] = sValue;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;

							time_t now = mytime(NULL);
							struct tm ltime;
							localtime_r(&now, &ltime);
							char szDate[40];
							sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

							std::vector<std::vector<std::string> > result2;
							strcpy(szTmp, ""0"");
							result2 = m_sql.safe_query(""SELECT MIN(Value1), MIN(Value2), MIN(Value5), MIN(Value6) FROM MultiMeter WHERE (DeviceRowID='%q' AND Date>='%q')"",
								sd[0].c_str(), szDate);
							if (!result2.empty())
							{
								std::vector<std::string> sd2 = result2[0];

								unsigned long long total_min_usage_1 = std::strtoull(sd2[0].c_str(), nullptr, 10);
								unsigned long long total_min_deliv_1 = std::strtoull(sd2[1].c_str(), nullptr, 10);
								unsigned long long total_min_usage_2 = std::strtoull(sd2[2].c_str(), nullptr, 10);
								unsigned long long total_min_deliv_2 = std::strtoull(sd2[3].c_str(), nullptr, 10);
								unsigned long long total_real_usage, total_real_deliv;

								total_real_usage = powerusage - (total_min_usage_1 + total_min_usage_2);
								total_real_deliv = powerdeliv - (total_min_deliv_1 + total_min_deliv_2);

								musage = double(total_real_usage) / EnergyDivider;
								sprintf(szTmp, ""%.3f kWh"", musage);
								root[""result""][ii][""CounterToday""] = szTmp;
								musage = double(total_real_deliv) / EnergyDivider;
								sprintf(szTmp, ""%.3f kWh"", musage);
								root[""result""][ii][""CounterDelivToday""] = szTmp;
							}
							else
							{
								sprintf(szTmp, ""%.3f kWh"", 0.0f);
								root[""result""][ii][""CounterToday""] = szTmp;
								root[""result""][ii][""CounterDelivToday""] = szTmp;
							}
						}
					}
					else if (dType == pTypeP1Gas)
					{
						root[""result""][ii][""SwitchTypeVal""] = MTYPE_GAS;

						time_t now = mytime(NULL);
						struct tm ltime;
						localtime_r(&now, &ltime);
						char szDate[40];
						sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

						std::vector<std::vector<std::string> > result2;

						float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

						strcpy(szTmp, ""0"");
						result2 = m_sql.safe_query(""SELECT MIN(Value) FROM Meter WHERE (DeviceRowID='%q' AND Date>='%q')"",
							sd[0].c_str(), szDate);
						if (!result2.empty())
						{
							std::vector<std::string> sd2 = result2[0];

							uint64_t total_min_gas = std::stoull(sd2[0]);
							uint64_t gasactual = std::stoull(sValue);
							uint64_t total_real_gas = gasactual - total_min_gas;

							double musage = double(gasactual) / divider;
							sprintf(szTmp, ""%.03f"", musage);
							root[""result""][ii][""Counter""] = szTmp;
							musage = double(total_real_gas) / divider;
							sprintf(szTmp, ""%.03f m3"", musage);
							root[""result""][ii][""CounterToday""] = szTmp;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							sprintf(szTmp, ""%.03f"", atof(sValue.c_str()) / divider);
							root[""result""][ii][""Data""] = szTmp;
						}
						else
						{
							sprintf(szTmp, ""%.03f"", 0.0f);
							root[""result""][ii][""Counter""] = szTmp;
							sprintf(szTmp, ""%.03f m3"", 0.0f);
							root[""result""][ii][""CounterToday""] = szTmp;
							sprintf(szTmp, ""%.03f"", atof(sValue.c_str()) / divider);
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if (dType == pTypeCURRENT)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 3)
						{
							int displaytype = 0;
							int voltage = 230;
							m_sql.GetPreferencesVar(""CM113DisplayType"", displaytype);
							m_sql.GetPreferencesVar(""ElectricVoltage"", voltage);

							double val1 = atof(strarray[0].c_str());
							double val2 = atof(strarray[1].c_str());
							double val3 = atof(strarray[2].c_str());

							if (displaytype == 0)
							{
								if ((val2 == 0) && (val3 == 0))
									sprintf(szData, ""%.1f A"", val1);
								else
									sprintf(szData, ""%.1f A, %.1f A, %.1f A"", val1, val2, val3);
							}
							else
							{
								if ((val2 == 0) && (val3 == 0))
									sprintf(szData, ""%d Watt"", int(val1*voltage));
								else
									sprintf(szData, ""%d Watt, %d Watt, %d Watt"", int(val1*voltage), int(val2*voltage), int(val3*voltage));
							}
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""displaytype""] = displaytype;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if (dType == pTypeCURRENTENERGY)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 4)
						{
							int displaytype = 0;
							int voltage = 230;
							m_sql.GetPreferencesVar(""CM113DisplayType"", displaytype);
							m_sql.GetPreferencesVar(""ElectricVoltage"", voltage);

							double total = atof(strarray[3].c_str());
							if (displaytype == 0)
							{
								sprintf(szData, ""%.1f A, %.1f A, %.1f A"", atof(strarray[0].c_str()), atof(strarray[1].c_str()), atof(strarray[2].c_str()));
							}
							else
							{
								sprintf(szData, ""%d Watt, %d Watt, %d Watt"", int(atof(strarray[0].c_str())*voltage), int(atof(strarray[1].c_str())*voltage), int(atof(strarray[2].c_str())*voltage));
							}
							if (total > 0)
							{
								sprintf(szTmp, "", Total: %.3f kWh"", total / 1000.0f);
								strcat(szData, szTmp);
							}
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""displaytype""] = displaytype;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
					else if (
						((dType == pTypeENERGY) || (dType == pTypePOWER)) ||
						((dType == pTypeGeneral) && (dSubType == sTypeKwh))
						)
					{
						std::vector<std::string> strarray;
						StringSplit(sValue, "";"", strarray);
						if (strarray.size() == 2)
						{
							double total = atof(strarray[1].c_str()) / 1000;

							time_t now = mytime(NULL);
							struct tm ltime;
							localtime_r(&now, &ltime);
							char szDate[40];
							sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

							std::vector<std::vector<std::string> > result2;
							strcpy(szTmp, ""0"");
							result2 = m_sql.safe_query(""SELECT MIN(Value) FROM Meter WHERE (DeviceRowID='%q' AND Date>='%q')"",
								sd[0].c_str(), szDate);
							if (!result2.empty())
							{
								float divider = m_sql.GetCounterDivider(int(metertype), int(dType), float(AddjValue2));

								std::vector<std::string> sd2 = result2[0];
								double minimum = atof(sd2[0].c_str()) / divider;

								sprintf(szData, ""%.3f kWh"", total);
								root[""result""][ii][""Data""] = szData;
								if ((dType == pTypeENERGY) || (dType == pTypePOWER))
								{
									sprintf(szData, ""%ld Watt"", atol(strarray[0].c_str()));
								}
								else
								{
									sprintf(szData, ""%g Watt"", atof(strarray[0].c_str()));
								}
								root[""result""][ii][""Usage""] = szData;
								root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
								sprintf(szTmp, ""%.3f kWh"", total - minimum);
								root[""result""][ii][""CounterToday""] = szTmp;
							}
							else
							{
								sprintf(szData, ""%.3f kWh"", total);
								root[""result""][ii][""Data""] = szData;
								if ((dType == pTypeENERGY) || (dType == pTypePOWER))
								{
									sprintf(szData, ""%ld Watt"", atol(strarray[0].c_str()));
								}
								else
								{
									sprintf(szData, ""%g Watt"", atof(strarray[0].c_str()));
								}
								root[""result""][ii][""Usage""] = szData;
								root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
								sprintf(szTmp, ""%d kWh"", 0);
								root[""result""][ii][""CounterToday""] = szTmp;
							}
							root[""result""][ii][""TypeImg""] = ""current"";
							root[""result""][ii][""SwitchTypeVal""] = switchtype; //MTYPE_ENERGY
							root[""result""][ii][""EnergyMeterMode""] = options[""EnergyMeterMode""];  //for alternate Energy Reading
						}
					}
					else if (dType == pTypeAirQuality)
					{
						if (bHaveTimeout)
							nValue = 0;
						sprintf(szTmp, ""%d ppm"", nValue);
						root[""result""][ii][""Data""] = szTmp;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						int airquality = nValue;
						if (airquality < 700)
							root[""result""][ii][""Quality""] = ""Excellent"";
						else if (airquality < 900)
							root[""result""][ii][""Quality""] = ""Good"";
						else if (airquality < 1100)
							root[""result""][ii][""Quality""] = ""Fair"";
						else if (airquality < 1600)
							root[""result""][ii][""Quality""] = ""Mediocre"";
						else
							root[""result""][ii][""Quality""] = ""Bad"";
					}
					else if (dType == pTypeThermostat)
					{
						if (dSubType == sTypeThermSetpoint)
						{
							bHasTimers = m_sql.HasTimers(sd[0]);

							double tempCelcius = atof(sValue.c_str());
							double temp = ConvertTemperature(tempCelcius, tempsign);

							sprintf(szTmp, ""%.1f"", temp);
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""SetPoint""] = szTmp;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""TypeImg""] = ""override_mini"";
						}
					}
					else if (dType == pTypeRadiator1)
					{
						if (dSubType == sTypeSmartwares)
						{
							bHasTimers = m_sql.HasTimers(sd[0]);

							double tempCelcius = atof(sValue.c_str());
							double temp = ConvertTemperature(tempCelcius, tempsign);

							sprintf(szTmp, ""%.1f"", temp);
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""SetPoint""] = szTmp;
							root[""result""][ii][""HaveTimeout""] = false; //this device does not provide feedback, so no timeout!
							root[""result""][ii][""TypeImg""] = ""override_mini"";
						}
					}
					else if (dType == pTypeGeneral)
					{
						if (dSubType == sTypeVisibility)
						{
							float vis = static_cast<float>(atof(sValue.c_str()));
							if (metertype == 0)
							{
								sprintf(szTmp, ""%.1f km"", vis);
							}
							else
							{
								sprintf(szTmp, ""%.1f mi"", vis*0.6214f);
							}
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Visibility""] = atof(sValue.c_str());
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""TypeImg""] = ""visibility"";
							root[""result""][ii][""SwitchTypeVal""] = metertype;
						}
						else if (dSubType == sTypeDistance)
						{
							float vis = static_cast<float>(atof(sValue.c_str()));
							if (metertype == 0)
							{
								sprintf(szTmp, ""%.1f cm"", vis);
							}
							else
							{
								sprintf(szTmp, ""%.1f in"", vis*0.6214f);
							}
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""TypeImg""] = ""visibility"";
							root[""result""][ii][""SwitchTypeVal""] = metertype;
						}
						else if (dSubType == sTypeSolarRadiation)
						{
							float radiation = static_cast<float>(atof(sValue.c_str()));
							sprintf(szTmp, ""%.1f Watt/m2"", radiation);
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Radiation""] = atof(sValue.c_str());
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""TypeImg""] = ""radiation"";
							root[""result""][ii][""SwitchTypeVal""] = metertype;
						}
						else if (dSubType == sTypeSoilMoisture)
						{
							sprintf(szTmp, ""%d cb"", nValue);
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""Desc""] = Get_Moisture_Desc(nValue);
							root[""result""][ii][""TypeImg""] = ""moisture"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""SwitchTypeVal""] = metertype;
						}
						else if (dSubType == sTypeLeafWetness)
						{
							sprintf(szTmp, ""%d"", nValue);
							root[""result""][ii][""Data""] = szTmp;
							root[""result""][ii][""TypeImg""] = ""leaf"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""SwitchTypeVal""] = metertype;
						}
						else if (dSubType == sTypeSystemTemp)
						{
							double tvalue = ConvertTemperature(atof(sValue.c_str()), tempsign);
							root[""result""][ii][""Temp""] = tvalue;
							sprintf(szData, ""%.1f %c"", tvalue, tempsign);
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Image""] = ""Computer"";
							root[""result""][ii][""TypeImg""] = ""temperature"";
							root[""result""][ii][""Type""] = ""temperature"";
							_tTrendCalculator::_eTendencyType tstate = _tTrendCalculator::_eTendencyType::TENDENCY_UNKNOWN;
							uint64_t tID = ((uint64_t)(hardwareID & 0x7FFFFFFF) << 32) | (devIdx & 0x7FFFFFFF);
							if (m_mainworker.m_trend_calculator.find(tID) != m_mainworker.m_trend_calculator.end())
							{
								tstate = m_mainworker.m_trend_calculator[tID].m_state;
							}
							root[""result""][ii][""trend""] = (int)tstate;
						}
						else if (dSubType == sTypePercentage)
						{
							sprintf(szData, ""%g%%"", atof(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Image""] = ""Computer"";
							root[""result""][ii][""TypeImg""] = ""hardware"";
						}
						else if (dSubType == sTypeWaterflow)
						{
							sprintf(szData, ""%g l/min"", atof(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Image""] = ""Moisture"";
							root[""result""][ii][""TypeImg""] = ""moisture"";
						}
						else if (dSubType == sTypeCustom)
						{
							std::string szAxesLabel = """";
							int SensorType = 1;
							std::vector<std::string> sResults;
							StringSplit(sOptions, "";"", sResults);

							if (sResults.size() == 2)
							{
								SensorType = atoi(sResults[0].c_str());
								szAxesLabel = sResults[1];
							}
							sprintf(szData, ""%g %s"", atof(sValue.c_str()), szAxesLabel.c_str());
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""SensorType""] = SensorType;
							root[""result""][ii][""SensorUnit""] = szAxesLabel;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;

							std::string IconFile = ""Custom"";
							if (CustomImage != 0)
							{
								std::map<int, int>::const_iterator ittIcon = m_custom_light_icons_lookup.find(CustomImage);
								if (ittIcon != m_custom_light_icons_lookup.end())
								{
									IconFile = m_custom_light_icons[ittIcon->second].RootFile;
								}
							}
							root[""result""][ii][""Image""] = IconFile;
							root[""result""][ii][""TypeImg""] = IconFile;
						}
						else if (dSubType == sTypeFan)
						{
							sprintf(szData, ""%d RPM"", atoi(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Image""] = ""Fan"";
							root[""result""][ii][""TypeImg""] = ""Fan"";
						}
						else if (dSubType == sTypeSoundLevel)
						{
							sprintf(szData, ""%d dB"", atoi(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""TypeImg""] = ""Speaker"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
						else if (dSubType == sTypeVoltage)
						{
							sprintf(szData, ""%g V"", atof(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""TypeImg""] = ""current"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Voltage""] = atof(sValue.c_str());
						}
						else if (dSubType == sTypeCurrent)
						{
							sprintf(szData, ""%g A"", atof(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""TypeImg""] = ""current"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Current""] = atof(sValue.c_str());
						}
						else if (dSubType == sTypeTextStatus)
						{
							root[""result""][ii][""Data""] = sValue;
							root[""result""][ii][""TypeImg""] = ""text"";
							root[""result""][ii][""HaveTimeout""] = false;
							root[""result""][ii][""ShowNotifications""] = false;
						}
						else if (dSubType == sTypeAlert)
						{
							if (nValue > 4)
								nValue = 4;
							sprintf(szData, ""Level: %d"", nValue);
							root[""result""][ii][""Data""] = szData;
							if (!sValue.empty())
								root[""result""][ii][""Data""] = sValue;
							else
								root[""result""][ii][""Data""] = Get_Alert_Desc(nValue);
							root[""result""][ii][""TypeImg""] = ""Alert"";
							root[""result""][ii][""Level""] = nValue;
							root[""result""][ii][""HaveTimeout""] = false;
						}
						else if (dSubType == sTypePressure)
						{
							sprintf(szData, ""%.1f Bar"", atof(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""TypeImg""] = ""gauge"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""Pressure""] = atof(sValue.c_str());
						}
						else if (dSubType == sTypeBaro)
						{
							std::vector<std::string> tstrarray;
							StringSplit(sValue, "";"", tstrarray);
							if (tstrarray.empty())
								continue;
							sprintf(szData, ""%g hPa"", atof(tstrarray[0].c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""TypeImg""] = ""gauge"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							if (tstrarray.size() > 1)
							{
								root[""result""][ii][""Barometer""] = atof(tstrarray[0].c_str());
								int forecast = atoi(tstrarray[1].c_str());
								root[""result""][ii][""Forecast""] = forecast;
								root[""result""][ii][""ForecastStr""] = BMP_Forecast_Desc(forecast);
							}
						}
						else if (dSubType == sTypeZWaveClock)
						{
							std::vector<std::string> tstrarray;
							StringSplit(sValue, "";"", tstrarray);
							int day = 0;
							int hour = 0;
							int minute = 0;
							if (tstrarray.size() == 3)
							{
								day = atoi(tstrarray[0].c_str());
								hour = atoi(tstrarray[1].c_str());
								minute = atoi(tstrarray[2].c_str());
							}
							sprintf(szData, ""%s %02d:%02d"", ZWave_Clock_Days(day), hour, minute);
							root[""result""][ii][""DayTime""] = sValue;
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""TypeImg""] = ""clock"";
						}
						else if (dSubType == sTypeZWaveThermostatMode)
						{
							strcpy(szData, """");
							root[""result""][ii][""Mode""] = nValue;
							root[""result""][ii][""TypeImg""] = ""mode"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							std::string modes = """";
#ifdef WITH_OPENZWAVE
							if (pHardware)
							{
								if (pHardware->HwdType == HTYPE_OpenZWave)
								{
									COpenZWave *pZWave = reinterpret_cast<COpenZWave*>(pHardware);
									unsigned long ID;
									std::stringstream s_strid;
									s_strid << std::hex << sd[1];
									s_strid >> ID;
									std::vector<std::string> vmodes = pZWave->GetSupportedThermostatModes(ID);
									int smode = 0;
									char szTmp[200];
									for (const auto & itt : vmodes)
									{
										sprintf(szTmp, ""%d;%s;"", smode, itt.c_str());
										modes += szTmp;
										smode++;
									}

									if (!vmodes.empty())
									{
										if (nValue < (int)vmodes.size())
										{
											sprintf(szData, ""%s"", vmodes[nValue].c_str());
										}
									}
								}
							}
#endif
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""Modes""] = modes;
						}
						else if (dSubType == sTypeZWaveThermostatFanMode)
						{
							sprintf(szData, ""%s"", ZWave_Thermostat_Fan_Modes[nValue]);
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""Mode""] = nValue;
							root[""result""][ii][""TypeImg""] = ""mode"";
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							bool bAddedSupportedModes = false;
							std::string modes = """";
#ifdef WITH_OPENZWAVE
							if (pHardware)
							{
								if (pHardware->HwdType == HTYPE_OpenZWave)
								{
									COpenZWave *pZWave = reinterpret_cast<COpenZWave*>(pHardware);
									unsigned long ID;
									std::stringstream s_strid;
									s_strid << std::hex << sd[1];
									s_strid >> ID;
									modes = pZWave->GetSupportedThermostatFanModes(ID);
									bAddedSupportedModes = !modes.empty();
								}
							}
#endif
							if (!bAddedSupportedModes)
							{
								int smode = 0;
								while (ZWave_Thermostat_Fan_Modes[smode] != NULL)
								{
									sprintf(szTmp, ""%d;%s;"", smode, ZWave_Thermostat_Fan_Modes[smode]);
									modes += szTmp;
									smode++;
								}
							}
							root[""result""][ii][""Modes""] = modes;
						}
						else if (dSubType == sTypeZWaveAlarm)
						{
							sprintf(szData, ""Event: 0x%02X (%d)"", nValue, nValue);
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""TypeImg""] = ""Alert"";
							root[""result""][ii][""Level""] = nValue;
							root[""result""][ii][""HaveTimeout""] = false;
						}
					}
					else if (dType == pTypeLux)
					{
						sprintf(szTmp, ""%.0f Lux"", atof(sValue.c_str()));
						root[""result""][ii][""Data""] = szTmp;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
					}
					else if (dType == pTypeWEIGHT)
					{
						sprintf(szTmp, ""%g %s"", m_sql.m_weightscale * atof(sValue.c_str()), m_sql.m_weightsign.c_str());
						root[""result""][ii][""Data""] = szTmp;
						root[""result""][ii][""HaveTimeout""] = false;
					}
					else if (dType == pTypeUsage)
					{
						if (dSubType == sTypeElectric)
						{
							sprintf(szData, ""%g Watt"", atof(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
						}
						else
						{
							root[""result""][ii][""Data""] = sValue;
						}
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
					}
					else if (dType == pTypeRFXSensor)
					{
						switch (dSubType)
						{
						case sTypeRFXSensorAD:
							sprintf(szData, ""%d mV"", atoi(sValue.c_str()));
							root[""result""][ii][""TypeImg""] = ""current"";
							break;
						case sTypeRFXSensorVolt:
							sprintf(szData, ""%d mV"", atoi(sValue.c_str()));
							root[""result""][ii][""TypeImg""] = ""current"";
							break;
						}
						root[""result""][ii][""Data""] = szData;
						root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
					}
					else if (dType == pTypeRego6XXValue)
					{
						switch (dSubType)
						{
						case sTypeRego6XXStatus:
						{
							std::string lstatus = ""On"";

							if (atoi(sValue.c_str()) == 0)
							{
								lstatus = ""Off"";
							}
							root[""result""][ii][""Status""] = lstatus;
							root[""result""][ii][""HaveDimmer""] = false;
							root[""result""][ii][""MaxDimLevel""] = 0;
							root[""result""][ii][""HaveGroupCmd""] = false;
							root[""result""][ii][""TypeImg""] = ""utility"";
							root[""result""][ii][""SwitchTypeVal""] = STYPE_OnOff;
							root[""result""][ii][""SwitchType""] = Switch_Type_Desc(STYPE_OnOff);
							sprintf(szData, ""%d"", atoi(sValue.c_str()));
							root[""result""][ii][""Data""] = szData;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
							root[""result""][ii][""StrParam1""] = strParam1;
							root[""result""][ii][""StrParam2""] = strParam2;
							root[""result""][ii][""Protected""] = (iProtected != 0);

							if (CustomImage < static_cast<int>(m_custom_light_icons.size()))
								root[""result""][ii][""Image""] = m_custom_light_icons[CustomImage].RootFile;
							else
								root[""result""][ii][""Image""] = ""Light"";

							uint64_t camIDX = m_mainworker.m_cameras.IsDevSceneInCamera(0, sd[0]);
							root[""result""][ii][""UsedByCamera""] = (camIDX != 0) ? true : false;
							if (camIDX != 0) {
								std::stringstream scidx;
								scidx << camIDX;
								root[""result""][ii][""CameraIdx""] = scidx.str();
							}

							root[""result""][ii][""Level""] = 0;
							root[""result""][ii][""LevelInt""] = atoi(sValue.c_str());
						}
						break;
						case sTypeRego6XXCounter:
						{
							time_t now = mytime(NULL);
							struct tm ltime;
							localtime_r(&now, &ltime);
							char szDate[40];
							sprintf(szDate, ""%04d-%02d-%02d"", ltime.tm_year + 1900, ltime.tm_mon + 1, ltime.tm_mday);

							std::vector<std::vector<std::string> > result2;
							strcpy(szTmp, ""0"");
							result2 = m_sql.safe_query(""SELECT MIN(Value), MAX(Value) FROM Meter WHERE (DeviceRowID='%q' AND Date>='%q')"",
								sd[0].c_str(), szDate);
							if (!result2.empty())
							{
								std::vector<std::string> sd2 = result2[0];

								unsigned long long total_min = std::strtoull(sd2[0].c_str(), nullptr, 10);
								unsigned long long total_max = std::strtoull(sd2[1].c_str(), nullptr, 10);
								unsigned long long total_real;

								total_real = total_max - total_min;
								sprintf(szTmp, ""%llu"", total_real);
							}
							root[""result""][ii][""SwitchTypeVal""] = MTYPE_COUNTER;
							root[""result""][ii][""Counter""] = sValue;
							root[""result""][ii][""CounterToday""] = szTmp;
							root[""result""][ii][""Data""] = sValue;
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
						break;
						}
					}
#ifdef ENABLE_PYTHON
					if (pHardware != NULL)
					{
						if (pHardware->HwdType == HTYPE_PythonPlugin)
						{
							Plugins::CPlugin *pPlugin = (Plugins::CPlugin*)pHardware;
							bHaveTimeout = pPlugin->HasNodeFailed(atoi(sd[2].c_str()));
							root[""result""][ii][""HaveTimeout""] = bHaveTimeout;
						}
					}
#endif
					root[""result""][ii][""Timers""] = (bHasTimers == true) ? ""true"" : ""false"";
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,291646449500565353922258127608136321612,,
"		const WebEmStoredSession CWebServer::GetSession(const std::string & sessionId) {
			WebEmStoredSession session;

			if (sessionId.empty()) {
				_log.Log(LOG_ERROR, ""SessionStore : cannot get session without id."");
			}
			else {
				std::vector<std::vector<std::string> > result;
				result = m_sql.safe_query(""SELECT SessionID, Username, AuthToken, ExpirationDate FROM UserSessions WHERE SessionID = '%q'"",
					sessionId.c_str());
				if (!result.empty()) {
					session.id = result[0][0].c_str();
					session.username = base64_decode(result[0][1]);
					session.auth_token = result[0][2].c_str();

					std::string sExpirationDate = result[0][3];
					time_t now = mytime(NULL);
					struct tm tExpirationDate;
					ParseSQLdatetime(session.expires, tExpirationDate, sExpirationDate);
				}
			}

			return session;
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,229987776466524113641822495806056888583,,
"		void CWebServer::LoadUsers()
		{
			ClearUserPasswords();
			std::string WebUserName, WebPassword;
			int nValue = 0;
			if (m_sql.GetPreferencesVar(""WebUserName"", nValue, WebUserName))
			{
				if (m_sql.GetPreferencesVar(""WebPassword"", nValue, WebPassword))
				{
					if ((WebUserName != """") && (WebPassword != """"))
					{
						WebUserName = base64_decode(WebUserName);
						AddUser(10000, WebUserName, WebPassword, URIGHTS_ADMIN, 0xFFFF);

						std::vector<std::vector<std::string> > result;
						result = m_sql.safe_query(""SELECT ID, Active, Username, Password, Rights, TabsEnabled FROM Users"");
						if (!result.empty())
						{
							int ii = 0;
							for (const auto & itt : result)
							{
								std::vector<std::string> sd = itt;

								int bIsActive = static_cast<int>(atoi(sd[1].c_str()));
								if (bIsActive)
								{
									unsigned long ID = (unsigned long)atol(sd[0].c_str());

									std::string username = base64_decode(sd[2]);
									std::string password = sd[3];

									_eUserRights rights = (_eUserRights)atoi(sd[4].c_str());
									int activetabs = atoi(sd[5].c_str());

									AddUser(ID, username, password, rights, activetabs);
								}
							}
						}
					}
				}
			}
			m_mainworker.LoadSharedUsers();
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,90716592955201666194349127712973584045,,
"		void CWebServer::PostSettings(WebEmSession & session, const request& req, std::string & redirect_uri)
		{
			redirect_uri = ""/index.html"";

			if (session.rights != 2)
			{
				session.reply_status = reply::forbidden;
				return; //Only admin user allowed
			}

			std::string Latitude = request::findValue(&req, ""Latitude"");
			std::string Longitude = request::findValue(&req, ""Longitude"");
			if ((Latitude != """") && (Longitude != """"))
			{
				std::string LatLong = Latitude + "";"" + Longitude;
				m_sql.UpdatePreferencesVar(""Location"", LatLong.c_str());
				m_mainworker.GetSunSettings();
			}
			m_notifications.ConfigFromGetvars(req, true);
			std::string DashboardType = request::findValue(&req, ""DashboardType"");
			m_sql.UpdatePreferencesVar(""DashboardType"", atoi(DashboardType.c_str()));
			std::string MobileType = request::findValue(&req, ""MobileType"");
			m_sql.UpdatePreferencesVar(""MobileType"", atoi(MobileType.c_str()));

			int nUnit = atoi(request::findValue(&req, ""WindUnit"").c_str());
			m_sql.UpdatePreferencesVar(""WindUnit"", nUnit);
			m_sql.m_windunit = (_eWindUnit)nUnit;

			nUnit = atoi(request::findValue(&req, ""TempUnit"").c_str());
			m_sql.UpdatePreferencesVar(""TempUnit"", nUnit);
			m_sql.m_tempunit = (_eTempUnit)nUnit;

			nUnit = atoi(request::findValue(&req, ""WeightUnit"").c_str());
			m_sql.UpdatePreferencesVar(""WeightUnit"", nUnit);
			m_sql.m_weightunit = (_eWeightUnit)nUnit;


			m_sql.SetUnitsAndScale();

			std::string AuthenticationMethod = request::findValue(&req, ""AuthenticationMethod"");
			_eAuthenticationMethod amethod = (_eAuthenticationMethod)atoi(AuthenticationMethod.c_str());
			m_sql.UpdatePreferencesVar(""AuthenticationMethod"", static_cast<int>(amethod));
			m_pWebEm->SetAuthenticationMethod(amethod);

			std::string ReleaseChannel = request::findValue(&req, ""ReleaseChannel"");
			m_sql.UpdatePreferencesVar(""ReleaseChannel"", atoi(ReleaseChannel.c_str()));

			std::string LightHistoryDays = request::findValue(&req, ""LightHistoryDays"");
			m_sql.UpdatePreferencesVar(""LightHistoryDays"", atoi(LightHistoryDays.c_str()));

			std::string s5MinuteHistoryDays = request::findValue(&req, ""ShortLogDays"");
			m_sql.UpdatePreferencesVar(""5MinuteHistoryDays"", atoi(s5MinuteHistoryDays.c_str()));

			int iShortLogInterval = atoi(request::findValue(&req, ""ShortLogInterval"").c_str());
			if (iShortLogInterval < 1)
				iShortLogInterval = 5;
			m_sql.UpdatePreferencesVar(""ShortLogInterval"", iShortLogInterval);
			m_sql.m_ShortLogInterval = iShortLogInterval;

			std::string sElectricVoltage = request::findValue(&req, ""ElectricVoltage"");
			m_sql.UpdatePreferencesVar(""ElectricVoltage"", atoi(sElectricVoltage.c_str()));

			std::string sCM113DisplayType = request::findValue(&req, ""CM113DisplayType"");
			m_sql.UpdatePreferencesVar(""CM113DisplayType"", atoi(sCM113DisplayType.c_str()));

			std::string WebUserName = base64_encode(CURLEncode::URLDecode(request::findValue(&req, ""WebUserName"")));
			std::string WebPassword = CURLEncode::URLDecode(request::findValue(&req, ""WebPassword""));

			std::string sOldWebLogin;
			std::string sOldWebPassword;
			m_sql.GetPreferencesVar(""WebUserName"", sOldWebLogin);
			m_sql.GetPreferencesVar(""WebPassword"", sOldWebPassword);

			bool bHaveAdminUserPasswordChange = false;

			if ((WebUserName == sOldWebLogin) && (WebPassword.empty()))
			{
			}
			else if (WebUserName.empty() || WebPassword.empty())
			{
				if ((!sOldWebLogin.empty()) || (!sOldWebPassword.empty()))
					bHaveAdminUserPasswordChange = true;
				WebUserName = """";
				WebPassword = """";
			}
			else {
				if ((WebUserName != sOldWebLogin) || (WebPassword != sOldWebPassword))
				{
					bHaveAdminUserPasswordChange = true;
				}
			}

			if (bHaveAdminUserPasswordChange)
			{
				RemoveUsersSessions(sOldWebLogin, session);
				m_sql.UpdatePreferencesVar(""WebUserName"", WebUserName.c_str());
				m_sql.UpdatePreferencesVar(""WebPassword"", WebPassword.c_str());
			}

			std::string WebLocalNetworks = CURLEncode::URLDecode(request::findValue(&req, ""WebLocalNetworks""));
			std::string WebRemoteProxyIPs = CURLEncode::URLDecode(request::findValue(&req, ""WebRemoteProxyIPs""));
			m_sql.UpdatePreferencesVar(""WebLocalNetworks"", WebLocalNetworks.c_str());
			m_sql.UpdatePreferencesVar(""WebRemoteProxyIPs"", WebRemoteProxyIPs.c_str());

			LoadUsers();
			m_pWebEm->ClearLocalNetworks();
			std::vector<std::string> strarray;
			StringSplit(WebLocalNetworks, "";"", strarray);
			for (const auto & itt : strarray)
				m_pWebEm->AddLocalNetworks(itt);
			m_pWebEm->AddLocalNetworks("""");

			m_pWebEm->ClearRemoteProxyIPs();
			strarray.clear();
			StringSplit(WebRemoteProxyIPs, "";"", strarray);
			for (const auto & itt : strarray)
				m_pWebEm->AddRemoteProxyIPs(itt);

			if (session.username.empty())
			{
				session.rights = -1;
			}

			std::string SecPassword = request::findValue(&req, ""SecPassword"");
			SecPassword = CURLEncode::URLDecode(SecPassword);
			if (SecPassword.size() != 32)
			{
				SecPassword = GenerateMD5Hash(SecPassword);
			}
			m_sql.UpdatePreferencesVar(""SecPassword"", SecPassword.c_str());

			std::string ProtectionPassword = request::findValue(&req, ""ProtectionPassword"");
			ProtectionPassword = CURLEncode::URLDecode(ProtectionPassword);
			if (ProtectionPassword.size() != 32)
			{
				ProtectionPassword = GenerateMD5Hash(ProtectionPassword);
			}
			m_sql.UpdatePreferencesVar(""ProtectionPassword"", ProtectionPassword.c_str());

			int EnergyDivider = atoi(request::findValue(&req, ""EnergyDivider"").c_str());
			int GasDivider = atoi(request::findValue(&req, ""GasDivider"").c_str());
			int WaterDivider = atoi(request::findValue(&req, ""WaterDivider"").c_str());
			if (EnergyDivider < 1)
				EnergyDivider = 1000;
			if (GasDivider < 1)
				GasDivider = 100;
			if (WaterDivider < 1)
				WaterDivider = 100;
			m_sql.UpdatePreferencesVar(""MeterDividerEnergy"", EnergyDivider);
			m_sql.UpdatePreferencesVar(""MeterDividerGas"", GasDivider);
			m_sql.UpdatePreferencesVar(""MeterDividerWater"", WaterDivider);

			std::string scheckforupdates = request::findValue(&req, ""checkforupdates"");
			m_sql.UpdatePreferencesVar(""UseAutoUpdate"", (scheckforupdates == ""on"" ? 1 : 0));

			std::string senableautobackup = request::findValue(&req, ""enableautobackup"");
			m_sql.UpdatePreferencesVar(""UseAutoBackup"", (senableautobackup == ""on"" ? 1 : 0));

			float CostEnergy = static_cast<float>(atof(request::findValue(&req, ""CostEnergy"").c_str()));
			float CostEnergyT2 = static_cast<float>(atof(request::findValue(&req, ""CostEnergyT2"").c_str()));
			float CostEnergyR1 = static_cast<float>(atof(request::findValue(&req, ""CostEnergyR1"").c_str()));
			float CostEnergyR2 = static_cast<float>(atof(request::findValue(&req, ""CostEnergyR2"").c_str()));
			float CostGas = static_cast<float>(atof(request::findValue(&req, ""CostGas"").c_str()));
			float CostWater = static_cast<float>(atof(request::findValue(&req, ""CostWater"").c_str()));
			m_sql.UpdatePreferencesVar(""CostEnergy"", int(CostEnergy*10000.0f));
			m_sql.UpdatePreferencesVar(""CostEnergyT2"", int(CostEnergyT2*10000.0f));
			m_sql.UpdatePreferencesVar(""CostEnergyR1"", int(CostEnergyR1*10000.0f));
			m_sql.UpdatePreferencesVar(""CostEnergyR2"", int(CostEnergyR2*10000.0f));
			m_sql.UpdatePreferencesVar(""CostGas"", int(CostGas*10000.0f));
			m_sql.UpdatePreferencesVar(""CostWater"", int(CostWater*10000.0f));

			int rnOldvalue = 0;
			int rnvalue = 0;

			m_sql.GetPreferencesVar(""ActiveTimerPlan"", rnOldvalue);
			rnvalue = atoi(request::findValue(&req, ""ActiveTimerPlan"").c_str());
			if (rnOldvalue != rnvalue)
			{
				m_sql.UpdatePreferencesVar(""ActiveTimerPlan"", rnvalue);
				m_sql.m_ActiveTimerPlan = rnvalue;
				m_mainworker.m_scheduler.ReloadSchedules();
			}
			m_sql.UpdatePreferencesVar(""DoorbellCommand"", atoi(request::findValue(&req, ""DoorbellCommand"").c_str()));
			m_sql.UpdatePreferencesVar(""SmartMeterType"", atoi(request::findValue(&req, ""SmartMeterType"").c_str()));

			std::string EnableTabFloorplans = request::findValue(&req, ""EnableTabFloorplans"");
			m_sql.UpdatePreferencesVar(""EnableTabFloorplans"", (EnableTabFloorplans == ""on"" ? 1 : 0));
			std::string EnableTabLights = request::findValue(&req, ""EnableTabLights"");
			m_sql.UpdatePreferencesVar(""EnableTabLights"", (EnableTabLights == ""on"" ? 1 : 0));
			std::string EnableTabTemp = request::findValue(&req, ""EnableTabTemp"");
			m_sql.UpdatePreferencesVar(""EnableTabTemp"", (EnableTabTemp == ""on"" ? 1 : 0));
			std::string EnableTabWeather = request::findValue(&req, ""EnableTabWeather"");
			m_sql.UpdatePreferencesVar(""EnableTabWeather"", (EnableTabWeather == ""on"" ? 1 : 0));
			std::string EnableTabUtility = request::findValue(&req, ""EnableTabUtility"");
			m_sql.UpdatePreferencesVar(""EnableTabUtility"", (EnableTabUtility == ""on"" ? 1 : 0));
			std::string EnableTabScenes = request::findValue(&req, ""EnableTabScenes"");
			m_sql.UpdatePreferencesVar(""EnableTabScenes"", (EnableTabScenes == ""on"" ? 1 : 0));
			std::string EnableTabCustom = request::findValue(&req, ""EnableTabCustom"");
			m_sql.UpdatePreferencesVar(""EnableTabCustom"", (EnableTabCustom == ""on"" ? 1 : 0));

			m_sql.GetPreferencesVar(""NotificationSensorInterval"", rnOldvalue);
			rnvalue = atoi(request::findValue(&req, ""NotificationSensorInterval"").c_str());
			if (rnOldvalue != rnvalue)
			{
				m_sql.UpdatePreferencesVar(""NotificationSensorInterval"", rnvalue);
				m_notifications.ReloadNotifications();
			}
			m_sql.GetPreferencesVar(""NotificationSwitchInterval"", rnOldvalue);
			rnvalue = atoi(request::findValue(&req, ""NotificationSwitchInterval"").c_str());
			if (rnOldvalue != rnvalue)
			{
				m_sql.UpdatePreferencesVar(""NotificationSwitchInterval"", rnvalue);
				m_notifications.ReloadNotifications();
			}
			std::string RaspCamParams = request::findValue(&req, ""RaspCamParams"");
			if (RaspCamParams != """")
			{
				if (IsArgumentSecure(RaspCamParams))
					m_sql.UpdatePreferencesVar(""RaspCamParams"", RaspCamParams.c_str());
			}

			std::string UVCParams = request::findValue(&req, ""UVCParams"");
			if (UVCParams != """")
			{
				if (IsArgumentSecure(UVCParams))
					m_sql.UpdatePreferencesVar(""UVCParams"", UVCParams.c_str());
			}

			std::string EnableNewHardware = request::findValue(&req, ""AcceptNewHardware"");
			int iEnableNewHardware = (EnableNewHardware == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""AcceptNewHardware"", iEnableNewHardware);
			m_sql.m_bAcceptNewHardware = (iEnableNewHardware == 1);

			std::string HideDisabledHardwareSensors = request::findValue(&req, ""HideDisabledHardwareSensors"");
			int iHideDisabledHardwareSensors = (HideDisabledHardwareSensors == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""HideDisabledHardwareSensors"", iHideDisabledHardwareSensors);

			std::string ShowUpdateEffect = request::findValue(&req, ""ShowUpdateEffect"");
			int iShowUpdateEffect = (ShowUpdateEffect == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""ShowUpdateEffect"", iShowUpdateEffect);

			std::string SendErrorsAsNotification = request::findValue(&req, ""SendErrorsAsNotification"");
			int iSendErrorsAsNotification = (SendErrorsAsNotification == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""SendErrorsAsNotification"", iSendErrorsAsNotification);
			_log.ForwardErrorsToNotificationSystem(iSendErrorsAsNotification != 0);

			std::string DegreeDaysBaseTemperature = request::findValue(&req, ""DegreeDaysBaseTemperature"");
			m_sql.UpdatePreferencesVar(""DegreeDaysBaseTemperature"", DegreeDaysBaseTemperature);

			rnOldvalue = 0;
			m_sql.GetPreferencesVar(""EnableEventScriptSystem"", rnOldvalue);
			std::string EnableEventScriptSystem = request::findValue(&req, ""EnableEventScriptSystem"");
			int iEnableEventScriptSystem = (EnableEventScriptSystem == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""EnableEventScriptSystem"", iEnableEventScriptSystem);
			m_sql.m_bEnableEventSystem = (iEnableEventScriptSystem == 1);
			if (iEnableEventScriptSystem != rnOldvalue)
			{
				m_mainworker.m_eventsystem.SetEnabled(m_sql.m_bEnableEventSystem);
				m_mainworker.m_eventsystem.StartEventSystem();
			}

			rnOldvalue = 0;
			m_sql.GetPreferencesVar(""DisableDzVentsSystem"", rnOldvalue);
			std::string DisableDzVentsSystem = request::findValue(&req, ""DisableDzVentsSystem"");
			int iDisableDzVentsSystem = (DisableDzVentsSystem == ""on"" ? 0 : 1);
			m_sql.UpdatePreferencesVar(""DisableDzVentsSystem"", iDisableDzVentsSystem);
			m_sql.m_bDisableDzVentsSystem = (iDisableDzVentsSystem == 1);
			if (m_sql.m_bEnableEventSystem && !iDisableDzVentsSystem && iDisableDzVentsSystem != rnOldvalue)
			{
				m_mainworker.m_eventsystem.LoadEvents();
				m_mainworker.m_eventsystem.GetCurrentStates();
			}
			m_sql.UpdatePreferencesVar(""DzVentsLogLevel"", atoi(request::findValue(&req, ""DzVentsLogLevel"").c_str()));

			std::string LogEventScriptTrigger = request::findValue(&req, ""LogEventScriptTrigger"");
			m_sql.m_bLogEventScriptTrigger = (LogEventScriptTrigger == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""LogEventScriptTrigger"", m_sql.m_bLogEventScriptTrigger);

			std::string EnableWidgetOrdering = request::findValue(&req, ""AllowWidgetOrdering"");
			int iEnableAllowWidgetOrdering = (EnableWidgetOrdering == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""AllowWidgetOrdering"", iEnableAllowWidgetOrdering);
			m_sql.m_bAllowWidgetOrdering = (iEnableAllowWidgetOrdering == 1);

			rnOldvalue = 0;
			m_sql.GetPreferencesVar(""RemoteSharedPort"", rnOldvalue);

			m_sql.UpdatePreferencesVar(""RemoteSharedPort"", atoi(request::findValue(&req, ""RemoteSharedPort"").c_str()));

			rnvalue = 0;
			m_sql.GetPreferencesVar(""RemoteSharedPort"", rnvalue);

			if (rnvalue != rnOldvalue)
			{
				m_mainworker.m_sharedserver.StopServer();
				if (rnvalue != 0)
				{
					char szPort[100];
					sprintf(szPort, ""%d"", rnvalue);
					m_mainworker.m_sharedserver.StartServer(""::"", szPort);
					m_mainworker.LoadSharedUsers();
				}
			}

			m_sql.UpdatePreferencesVar(""Language"", request::findValue(&req, ""Language"").c_str());
			std::string SelectedTheme = request::findValue(&req, ""Themes"");
			m_sql.UpdatePreferencesVar(""WebTheme"", SelectedTheme.c_str());
			m_pWebEm->SetWebTheme(SelectedTheme);
			std::string Title = request::findValue(&req, ""Title"").c_str();
			m_sql.UpdatePreferencesVar(""Title"", (Title.empty()) ? ""Domoticz"" : Title);

			m_sql.GetPreferencesVar(""RandomTimerFrame"", rnOldvalue);
			rnvalue = atoi(request::findValue(&req, ""RandomSpread"").c_str());
			if (rnOldvalue != rnvalue)
			{
				m_sql.UpdatePreferencesVar(""RandomTimerFrame"", rnvalue);
				m_mainworker.m_scheduler.ReloadSchedules();
			}

			m_sql.UpdatePreferencesVar(""SecOnDelay"", atoi(request::findValue(&req, ""SecOnDelay"").c_str()));

			int sensortimeout = atoi(request::findValue(&req, ""SensorTimeout"").c_str());
			if (sensortimeout < 10)
				sensortimeout = 10;
			m_sql.UpdatePreferencesVar(""SensorTimeout"", sensortimeout);

			int batterylowlevel = atoi(request::findValue(&req, ""BatterLowLevel"").c_str());
			if (batterylowlevel > 100)
				batterylowlevel = 100;
			m_sql.GetPreferencesVar(""BatteryLowNotification"", rnOldvalue);
			m_sql.UpdatePreferencesVar(""BatteryLowNotification"", batterylowlevel);
			if ((rnOldvalue != batterylowlevel) && (batterylowlevel != 0))
				m_sql.CheckBatteryLow();

			int nValue = 0;
			nValue = atoi(request::findValue(&req, ""FloorplanPopupDelay"").c_str());
			m_sql.UpdatePreferencesVar(""FloorplanPopupDelay"", nValue);
			std::string FloorplanFullscreenMode = request::findValue(&req, ""FloorplanFullscreenMode"");
			m_sql.UpdatePreferencesVar(""FloorplanFullscreenMode"", (FloorplanFullscreenMode == ""on"" ? 1 : 0));
			std::string FloorplanAnimateZoom = request::findValue(&req, ""FloorplanAnimateZoom"");
			m_sql.UpdatePreferencesVar(""FloorplanAnimateZoom"", (FloorplanAnimateZoom == ""on"" ? 1 : 0));
			std::string FloorplanShowSensorValues = request::findValue(&req, ""FloorplanShowSensorValues"");
			m_sql.UpdatePreferencesVar(""FloorplanShowSensorValues"", (FloorplanShowSensorValues == ""on"" ? 1 : 0));
			std::string FloorplanShowSwitchValues = request::findValue(&req, ""FloorplanShowSwitchValues"");
			m_sql.UpdatePreferencesVar(""FloorplanShowSwitchValues"", (FloorplanShowSwitchValues == ""on"" ? 1 : 0));
			std::string FloorplanShowSceneNames = request::findValue(&req, ""FloorplanShowSceneNames"");
			m_sql.UpdatePreferencesVar(""FloorplanShowSceneNames"", (FloorplanShowSceneNames == ""on"" ? 1 : 0));
			m_sql.UpdatePreferencesVar(""FloorplanRoomColour"", CURLEncode::URLDecode(request::findValue(&req, ""FloorplanRoomColour"").c_str()).c_str());
			m_sql.UpdatePreferencesVar(""FloorplanActiveOpacity"", atoi(request::findValue(&req, ""FloorplanActiveOpacity"").c_str()));
			m_sql.UpdatePreferencesVar(""FloorplanInactiveOpacity"", atoi(request::findValue(&req, ""FloorplanInactiveOpacity"").c_str()));

#ifndef NOCLOUD
			std::string md_userid, md_password, pf_userid, pf_password;
			int md_subsystems, pf_subsystems;
			m_sql.GetPreferencesVar(""MyDomoticzUserId"", pf_userid);
			m_sql.GetPreferencesVar(""MyDomoticzPassword"", pf_password);
			m_sql.GetPreferencesVar(""MyDomoticzSubsystems"", pf_subsystems);
			md_userid = CURLEncode::URLDecode(request::findValue(&req, ""MyDomoticzUserId""));
			md_password = CURLEncode::URLDecode(request::findValue(&req, ""MyDomoticzPassword""));
			md_subsystems = (request::findValue(&req, ""SubsystemHttp"").empty() ? 0 : 1) + (request::findValue(&req, ""SubsystemShared"").empty() ? 0 : 2) + (request::findValue(&req, ""SubsystemApps"").empty() ? 0 : 4);
			if (md_userid != pf_userid || md_password != pf_password || md_subsystems != pf_subsystems) {
				m_sql.UpdatePreferencesVar(""MyDomoticzUserId"", md_userid);
				if (md_password != pf_password) {
					md_password = base64_encode(md_password);
					m_sql.UpdatePreferencesVar(""MyDomoticzPassword"", md_password);
				}
				m_sql.UpdatePreferencesVar(""MyDomoticzSubsystems"", md_subsystems);
				m_webservers.RestartProxy();
			}
#endif

			m_sql.UpdatePreferencesVar(""OneWireSensorPollPeriod"", atoi(request::findValue(&req, ""OneWireSensorPollPeriod"").c_str()));
			m_sql.UpdatePreferencesVar(""OneWireSwitchPollPeriod"", atoi(request::findValue(&req, ""OneWireSwitchPollPeriod"").c_str()));

			std::string IFTTTEnabled = request::findValue(&req, ""IFTTTEnabled"");
			int iIFTTTEnabled = (IFTTTEnabled == ""on"" ? 1 : 0);
			m_sql.UpdatePreferencesVar(""IFTTTEnabled"", iIFTTTEnabled);
			std::string szKey = request::findValue(&req, ""IFTTTAPI"");
			m_sql.UpdatePreferencesVar(""IFTTTAPI"", base64_encode(szKey));

			m_notifications.LoadConfig();
#ifdef ENABLE_PYTHON
			PluginLoadConfig();
#endif
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,152192360640078674945218097405594070109,,
"		void CWebServer::RType_Hardware(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""Hardware"";

#ifdef WITH_OPENZWAVE
			m_ZW_Hwidx = -1;
#endif

			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_query(""SELECT ID, Name, Enabled, Type, Address, Port, SerialPort, Username, Password, Extra, Mode1, Mode2, Mode3, Mode4, Mode5, Mode6, DataTimeout FROM Hardware ORDER BY ID ASC"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					_eHardwareTypes hType = (_eHardwareTypes)atoi(sd[3].c_str());
					if (hType == HTYPE_DomoticzInternal)
						continue;
					if (hType == HTYPE_RESERVED_FOR_YOU_1)
						continue;
					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Name""] = sd[1];
					root[""result""][ii][""Enabled""] = (sd[2] == ""1"") ? ""true"" : ""false"";
					root[""result""][ii][""Type""] = hType;
					root[""result""][ii][""Address""] = sd[4];
					root[""result""][ii][""Port""] = atoi(sd[5].c_str());
					root[""result""][ii][""SerialPort""] = sd[6];
					root[""result""][ii][""Username""] = sd[7];
					root[""result""][ii][""Password""] = sd[8];
					root[""result""][ii][""Extra""] = sd[9];

					if (hType == HTYPE_PythonPlugin) {
						root[""result""][ii][""Mode1""] = sd[10];  // Plugins can have non-numeric values in the Mode fields
						root[""result""][ii][""Mode2""] = sd[11];
						root[""result""][ii][""Mode3""] = sd[12];
						root[""result""][ii][""Mode4""] = sd[13];
						root[""result""][ii][""Mode5""] = sd[14];
						root[""result""][ii][""Mode6""] = sd[15];
					}
					else {
						root[""result""][ii][""Mode1""] = atoi(sd[10].c_str());
						root[""result""][ii][""Mode2""] = atoi(sd[11].c_str());
						root[""result""][ii][""Mode3""] = atoi(sd[12].c_str());
						root[""result""][ii][""Mode4""] = atoi(sd[13].c_str());
						root[""result""][ii][""Mode5""] = atoi(sd[14].c_str());
						root[""result""][ii][""Mode6""] = atoi(sd[15].c_str());
					}
					root[""result""][ii][""DataTimeout""] = atoi(sd[16].c_str());

					CDomoticzHardwareBase *pHardware = m_mainworker.GetHardware(atoi(sd[0].c_str()));
					if (pHardware != NULL)
					{
						if (
							(pHardware->HwdType == HTYPE_RFXtrx315) ||
							(pHardware->HwdType == HTYPE_RFXtrx433) ||
							(pHardware->HwdType == HTYPE_RFXtrx868) ||
							(pHardware->HwdType == HTYPE_RFXLAN)
							)
						{
							CRFXBase *pMyHardware = reinterpret_cast<CRFXBase*>(pHardware);
							if (!pMyHardware->m_Version.empty())
								root[""result""][ii][""version""] = pMyHardware->m_Version;
							else
								root[""result""][ii][""version""] = sd[11];
							root[""result""][ii][""noiselvl""] = pMyHardware->m_NoiseLevel;
						}
						else if ((pHardware->HwdType == HTYPE_MySensorsUSB) || (pHardware->HwdType == HTYPE_MySensorsTCP) || (pHardware->HwdType == HTYPE_MySensorsMQTT))
						{
							MySensorsBase *pMyHardware = reinterpret_cast<MySensorsBase*>(pHardware);
							root[""result""][ii][""version""] = pMyHardware->GetGatewayVersion();
						}
						else if ((pHardware->HwdType == HTYPE_OpenThermGateway) || (pHardware->HwdType == HTYPE_OpenThermGatewayTCP))
						{
							OTGWBase *pMyHardware = reinterpret_cast<OTGWBase*>(pHardware);
							root[""result""][ii][""version""] = pMyHardware->m_Version;
						}
						else if ((pHardware->HwdType == HTYPE_RFLINKUSB) || (pHardware->HwdType == HTYPE_RFLINKTCP))
						{
							CRFLinkBase *pMyHardware = reinterpret_cast<CRFLinkBase*>(pHardware);
							root[""result""][ii][""version""] = pMyHardware->m_Version;
						}
						else
						{
#ifdef WITH_OPENZWAVE
							if (pHardware->HwdType == HTYPE_OpenZWave)
							{
								COpenZWave *pOZWHardware = reinterpret_cast<COpenZWave*>(pHardware);
								root[""result""][ii][""version""] = pOZWHardware->GetVersionLong();
								root[""result""][ii][""NodesQueried""] = (pOZWHardware->m_awakeNodesQueried || pOZWHardware->m_allNodesQueried);
							}
#endif
						}
					}
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,267999454331972679473401572103309610774,,
"		void CWebServer::RType_Notifications(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""Notifications"";

			int ii = 0;

			for (const auto & ittNotifiers : m_notifications.m_notifiers)
			{
				root[""notifiers""][ii][""name""] = ittNotifiers.first;
				root[""notifiers""][ii][""description""] = ittNotifiers.first;
				ii++;
			}

			uint64_t idx = 0;
			if (request::findValue(&req, ""idx"") != """")
			{
				idx = std::strtoull(request::findValue(&req, ""idx"").c_str(), nullptr, 10);
			}
			std::vector<_tNotification> notifications = m_notifications.GetNotifications(idx);
			if (notifications.size() > 0)
			{
				ii = 0;
				for (const auto & itt : notifications)
				{
					root[""result""][ii][""idx""] = itt.ID;
					std::string sParams = itt.Params;
					if (sParams.empty()) {
						sParams = ""S"";
					}
					root[""result""][ii][""Params""] = sParams;
					root[""result""][ii][""Priority""] = itt.Priority;
					root[""result""][ii][""SendAlways""] = itt.SendAlways;
					root[""result""][ii][""CustomMessage""] = itt.CustomMessage;
					root[""result""][ii][""ActiveSystems""] = itt.ActiveSystems;
					ii++;
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,15205120087777537030461044195712164782,,
"		void CWebServer::RType_Plans(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""Plans"";

			std::string sDisplayHidden = request::findValue(&req, ""displayhidden"");
			bool bDisplayHidden = (sDisplayHidden == ""1"");

			std::vector<std::vector<std::string> > result, result2;
			result = m_sql.safe_query(""SELECT ID, Name, [Order] FROM Plans ORDER BY [Order]"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					std::string Name = sd[1];
					bool bIsHidden = (Name[0] == '$');

					if ((bDisplayHidden) || (!bIsHidden))
					{
						root[""result""][ii][""idx""] = sd[0];
						root[""result""][ii][""Name""] = Name;
						root[""result""][ii][""Order""] = sd[2];

						unsigned int totDevices = 0;

						result2 = m_sql.safe_query(""SELECT COUNT(*) FROM DeviceToPlansMap WHERE (PlanID=='%q')"",
							sd[0].c_str());
						if (!result2.empty())
						{
							totDevices = (unsigned int)atoi(result2[0][0].c_str());
						}
						root[""result""][ii][""Devices""] = totDevices;

						ii++;
					}
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,312153079768316113450074414740795706928,,
"		void CWebServer::RType_Scenes(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""Scenes"";
			root[""AllowWidgetOrdering""] = m_sql.m_bAllowWidgetOrdering;

			std::string sDisplayHidden = request::findValue(&req, ""displayhidden"");
			bool bDisplayHidden = (sDisplayHidden == ""1"");

			std::string sLastUpdate = request::findValue(&req, ""lastupdate"");

			time_t LastUpdate = 0;
			if (sLastUpdate != """")
			{
				std::stringstream sstr;
				sstr << sLastUpdate;
				sstr >> LastUpdate;
			}

			time_t now = mytime(NULL);
			struct tm tm1;
			localtime_r(&now, &tm1);
			struct tm tLastUpdate;
			localtime_r(&now, &tLastUpdate);

			root[""ActTime""] = static_cast<int>(now);

			std::vector<std::vector<std::string> > result, result2;
			result = m_sql.safe_query(""SELECT ID, Name, Activators, Favorite, nValue, SceneType, LastUpdate, Protected, OnAction, OffAction, Description FROM Scenes ORDER BY [Order]"");
			if (!result.empty())
			{
				int ii = 0;
				for (const auto & itt : result)
				{
					std::vector<std::string> sd = itt;

					std::string sName = sd[1];
					if ((bDisplayHidden == false) && (sName[0] == '$'))
						continue;

					std::string sLastUpdate = sd[6].c_str();
					if (LastUpdate != 0)
					{
						time_t cLastUpdate;
						ParseSQLdatetime(cLastUpdate, tLastUpdate, sLastUpdate, tm1.tm_isdst);
						if (cLastUpdate <= LastUpdate)
							continue;
					}

					unsigned char nValue = atoi(sd[4].c_str());
					unsigned char scenetype = atoi(sd[5].c_str());
					int iProtected = atoi(sd[7].c_str());

					std::string onaction = base64_encode(sd[8]);
					std::string offaction = base64_encode(sd[9]);

					root[""result""][ii][""idx""] = sd[0];
					root[""result""][ii][""Name""] = sName;
					root[""result""][ii][""Description""] = sd[10];
					root[""result""][ii][""Favorite""] = atoi(sd[3].c_str());
					root[""result""][ii][""Protected""] = (iProtected != 0);
					root[""result""][ii][""OnAction""] = onaction;
					root[""result""][ii][""OffAction""] = offaction;

					if (scenetype == 0)
					{
						root[""result""][ii][""Type""] = ""Scene"";
					}
					else
					{
						root[""result""][ii][""Type""] = ""Group"";
					}

					root[""result""][ii][""LastUpdate""] = sLastUpdate;

					if (nValue == 0)
						root[""result""][ii][""Status""] = ""Off"";
					else if (nValue == 1)
						root[""result""][ii][""Status""] = ""On"";
					else
						root[""result""][ii][""Status""] = ""Mixed"";
					root[""result""][ii][""Timers""] = (m_sql.HasSceneTimers(sd[0]) == true) ? ""true"" : ""false"";
					uint64_t camIDX = m_mainworker.m_cameras.IsDevSceneInCamera(1, sd[0]);
					root[""result""][ii][""UsedByCamera""] = (camIDX != 0) ? true : false;
					if (camIDX != 0) {
						std::stringstream scidx;
						scidx << camIDX;
						root[""result""][ii][""CameraIdx""] = scidx.str();
					}
					ii++;
				}
			}
			if (!m_mainworker.m_LastSunriseSet.empty())
			{
				std::vector<std::string> strarray;
				StringSplit(m_mainworker.m_LastSunriseSet, "";"", strarray);
				if (strarray.size() == 10)
				{
					char szTmp[100];
					strftime(szTmp, 80, ""%Y-%m-%d %X"", &tm1);
					root[""ServerTime""] = szTmp;
					root[""Sunrise""] = strarray[0];
					root[""Sunset""] = strarray[1];
					root[""SunAtSouth""] = strarray[2];
					root[""CivTwilightStart""] = strarray[3];
					root[""CivTwilightEnd""] = strarray[4];
					root[""NautTwilightStart""] = strarray[5];
					root[""NautTwilightEnd""] = strarray[6];
					root[""AstrTwilightStart""] = strarray[7];
					root[""AstrTwilightEnd""] = strarray[8];
					root[""DayLength""] = strarray[9];
				}
			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,27841075936989103002971342905732085304,,
"		void CWebServer::StopServer()
		{
			m_bDoStop = true;
			try
			{
				if (m_pWebEm == NULL)
					return;
				m_pWebEm->Stop();
				if (m_thread) {
					m_thread->join();
					m_thread.reset();
				}
				delete m_pWebEm;
				m_pWebEm = NULL;
			}
			catch (...)
			{

			}
		}
",0,CWE-89,domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,104431231060092433435455664588883989500,,
  Field *get_tmp_table_field() { return 0; },1,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,193399504203498428165810028952707815788,1,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"bool Item_singlerow_subselect::fix_length_and_dec()
{
  if ((max_columns= engine->cols()) == 1)
  {
    if (engine->fix_length_and_dec(row= &value))
      return TRUE;
  }
  else
  {
    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *
                                                 max_columns)) ||
        engine->fix_length_and_dec(row))
      return TRUE;
    value= *row;
  }
  unsigned_flag= value->unsigned_flag;
  /*
    If there are not tables in subquery then ability to have NULL value
    depends on SELECT list (if single row subquery have tables then it
    always can be NULL if there are not records fetched).
  */
  if (engine->no_tables())
    maybe_null= engine->may_be_null();
  else
  {
    for (uint i= 0; i < max_columns; i++)
      row[i]->maybe_null= TRUE;
  }
  return FALSE;
}",1,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,21922196527056853976744837751349924622,30,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
  bool is_json_type() { return (*ref)->is_json_type(); },0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,280864983997911838315373480962134099530,1,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"  Item_default_value(THD *thd, Name_resolution_context *context_arg)
    :Item_field(thd, context_arg, (const char *)NULL, (const char *)NULL,
               (const char *)NULL),
    arg(NULL) {}",0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,18394943626666611162270722263031496096,4,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"  bool check_table_name_processor(void *arg)
  {
    Check_table_name_prm &p= *(Check_table_name_prm *) arg;
    if (!field && p.table_name.length && table_name)
    {
      DBUG_ASSERT(p.db.length);
      if ((db_name &&
          my_strcasecmp(table_alias_charset, p.db.str, db_name)) ||
          my_strcasecmp(table_alias_charset, p.table_name.str, table_name))
      {
        print(&p.field, (enum_query_type) (QT_ITEM_ORIGINAL_FUNC_NULLIF |
                                          QT_NO_DATA_EXPANSION |
                                          QT_TO_SYSTEM_CHARSET));
        return true;
      }
    }
    return false;
  }",0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,96107571154885961273896648697327429968,18,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
  virtual bool enchant_default_with_arg_processor(void *arg) { return 0; },0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,336259480482828443859348414392104085431,1,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"  Item_default_value(THD *thd, Name_resolution_context *context_arg, Item *a)
          :Item_field(thd, context_arg, (const char *)NULL, (const char *)NULL,
                      (const char *)NULL),
           arg(a) {}",0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,257423301809288479200161154687560380365,4,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"  Item_default_value(THD *thd, Name_resolution_context *context_arg, Field *a)
    :Item_field(thd, context_arg, (const char *)NULL, (const char *)NULL,
                (const char *)NULL),
    arg(NULL) {}",0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,150507486082367527201566196451655863764,4,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"  Item_default_value_arg(THD *thd, Name_resolution_context *context, Item *a)
    :Item_default_value(thd, context, a) {}",0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,321817710247184618124680758899526997067,2,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"  void update_used_tables()
  {
    if (field && field->default_value)
      field->default_value->expr->update_used_tables();
  }",0,['CWE-89'],server,e4e25d2bacc067417c35750f5f6c44cad10c81de,127277295725889898843451489290078800094,5,"MDEV-26423 MariaDB server crash in Create_tmp_table::finalize

Removed prohibition of creating temporary field of Item_default_value
(added by mistake by 1d9b043a1f5db7ff229d5200652cff7a78ea6266 fix of
MDEV-10780 and MDEV-11265)."
"bool Item_in_subselect::val_bool()
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
    return value;
  DBUG_ASSERT((engine->uncacheable() & ~UNCACHEABLE_EXPLAIN) ||
              ! engine->is_executed() || with_recursive_reference);
  null_value= was_null= FALSE;
  if (exec())
  {
    reset();
    return 0;
  }
  if (was_null && !value)
    null_value= TRUE;
  return value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,269497735569326140689839269769034675923,17,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::set_fake_select_as_master_processor(void *arg)
{
  SELECT_LEX *fake_select= (SELECT_LEX*) arg;
  /*
    Move the st_select_lex_unit of a subquery from a global ORDER BY clause to
    become a direct child of the fake_select of a UNION. In this way the
    ORDER BY that is applied to the temporary table that contains the result of
    the whole UNION, and all columns in the subquery are resolved against this
    table. The transformation is applied only for immediate child subqueries of
    a UNION query.
  */
  if (unit->outer_select()->master_unit()->fake_select_lex == fake_select)
  {
    /*
      Set the master of the subquery to be the fake select (i.e. the whole
      UNION), instead of the last query in the UNION.
    */
    fake_select->add_slave(unit);
    DBUG_ASSERT(unit->outer_select() == fake_select);
    /* Adjust the name resolution context hierarchy accordingly. */
    for (SELECT_LEX *sl= unit->first_select(); sl; sl= sl->next_select())
      sl->context.outer_context= &(fake_select->context);
    /*
      Undo Item_subselect::eliminate_subselect_processor because at that phase
      we don't know yet that the ORDER clause will be moved to the fake select.
    */
    unit->item= this;
    eliminated= FALSE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,269656638156109926500628551386315388744,31,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_hash_sj_engine::print(String *str, enum_query_type query_type)
{
  str->append(STRING_WITH_LEN("" <materialize> (""));
  materialize_engine->print(str, query_type);
  str->append(STRING_WITH_LEN("" ), ""));

  if (lookup_engine)
    lookup_engine->print(str, query_type);
  else
    str->append(STRING_WITH_LEN(
           ""<engine selected at execution time>""
         ));
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,260272075076798944648959484767852212736,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item::Type Item_subselect::type() const
{
  return SUBSELECT_ITEM;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,251089274095200767198195259570686325832,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_partial_match_engine::print(String *str,
                                           enum_query_type query_type)
{
  /*
    Should never be called as the actual engine cannot be known at query
    optimization time.
    DBUG_ASSERT(FALSE);
  */
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,31431325099911233631191420771857968579,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_singlerow_subselect::fix_length_and_dec()
{
  if ((max_columns= engine->cols()) == 1)
  {
    if (engine->fix_length_and_dec(row= &value))
      return TRUE;
  }
  else
  {
    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *
                                                 max_columns)) ||
        engine->fix_length_and_dec(row))
      return TRUE;
    value= *row;
  }
  unsigned_flag= value->unsigned_flag;
  /*
    If the subquery has no tables (1) and is not a UNION (2), like:

      (SELECT subq_value)

    then its NULLability is the same as subq_value's NULLability.

    (1): A subquery that uses a table will return NULL when the table is empty.
    (2): A UNION subquery will return NULL if it produces a ""Subquery returns
         more than one row"" error.
  */
  if (engine->no_tables() &&
      engine->engine_type() != subselect_engine::UNION_ENGINE)
    maybe_null= engine->may_be_null();
  else
  {
    for (uint i= 0; i < max_columns; i++)
      row[i]->maybe_null= TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,190851839197055886744718866625460288710,37,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"table_map Item_subselect::used_tables() const
{
  return (table_map) ((engine->uncacheable() & ~UNCACHEABLE_EXPLAIN)? 
                      used_tables_cache : 0L);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,336067314354261817617523362697675894687,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_singlerow_subselect::select_transformer(JOIN *join)
{
  DBUG_ENTER(""Item_singlerow_subselect::select_transformer"");
  if (changed)
    DBUG_RETURN(false);
  DBUG_ASSERT(join->thd == thd);

  SELECT_LEX *select_lex= join->select_lex;
  Query_arena *arena= thd->stmt_arena;

  if (!select_lex->master_unit()->is_union() &&
      !select_lex->table_list.elements &&
      select_lex->item_list.elements == 1 &&
      !select_lex->item_list.head()->with_sum_func &&
      /*
	We can't change name of Item_field or Item_ref, because it will
	prevent its correct resolving, but we should save name of
	removed item => we do not make optimization if top item of
	list is field or reference.
	TODO: solve above problem
      */
      !(select_lex->item_list.head()->type() == FIELD_ITEM ||
	select_lex->item_list.head()->type() == REF_ITEM) &&
      !join->conds && !join->having &&
      /*
        switch off this optimization for prepare statement,
        because we do not rollback this changes
        TODO: make rollback for it, or special name resolving mode in 5.0.
      */
      !arena->is_stmt_prepare_or_first_sp_execute()
      )
  {
    have_to_be_excluded= 1;
    if (thd->lex->describe)
    {
      char warn_buff[MYSQL_ERRMSG_SIZE];
      sprintf(warn_buff, ER_THD(thd, ER_SELECT_REDUCED),
              select_lex->select_number);
      push_warning(thd, Sql_condition::WARN_LEVEL_NOTE,
		   ER_SELECT_REDUCED, warn_buff);
    }
    substitution= select_lex->item_list.head();
    /*
      as far as we moved content to upper level we have to fix dependences & Co
    */
    substitution->fix_after_pullout(select_lex->outer_select(),
                                    &substitution, TRUE);
  }
  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,229823312047238231543988376982728062165,50,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::row_value_transformer(JOIN *join)
{
  SELECT_LEX *select_lex= join->select_lex;
  uint cols_num= left_expr->cols();

  DBUG_ENTER(""Item_in_subselect::row_value_transformer"");
  DBUG_ASSERT(thd == join->thd);

  // psergey: duplicated_subselect_card_check
  if (select_lex->item_list.elements != cols_num)
  {
    my_error(ER_OPERAND_COLUMNS, MYF(0), cols_num);
    DBUG_RETURN(true);
  }

  /*
    Wrap the current IN predicate in an Item_in_optimizer. The actual
    substitution in the Item tree takes place in Item_subselect::fix_fields.
  */
  if (!substitution)
  {
    //first call for this unit
    SELECT_LEX_UNIT *master_unit= select_lex->master_unit();
    substitution= optimizer;

    SELECT_LEX *current= thd->lex->current_select;
    thd->lex->current_select= current->return_after_parsing();
    if (!optimizer || optimizer->fix_left(thd))
    {
      thd->lex->current_select= current;
      DBUG_RETURN(true);
    }

    // we will refer to upper level cache array => we have to save it in PS
    optimizer->keep_top_level_cache();

    thd->lex->current_select= current;
    /*
      The uncacheable property controls a number of actions, e.g. whether to
      save/restore (via init_save_join_tab/restore_tmp) the original JOIN for
      plans with a temp table where the original JOIN was overridden by
      make_simple_join. The UNCACHEABLE_EXPLAIN is ignored by EXPLAIN, thus
      non-correlated subqueries will not appear as such to EXPLAIN.
    */
    master_unit->uncacheable|= UNCACHEABLE_EXPLAIN;
    select_lex->uncacheable|= UNCACHEABLE_EXPLAIN;
  }

  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,232567519107465069656965960594252218466,50,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::const_item() const
{
  DBUG_ASSERT(thd);
  return (thd->lex->context_analysis_only || with_recursive_reference ?
          FALSE :
          forced_const || const_item_cache);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,253128188241879118536401385021766588010,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::inject_in_to_exists_cond(JOIN *join_arg)
{
  SELECT_LEX *select_lex= join_arg->select_lex;
  Item *where_item= join_arg->in_to_exists_where;
  Item *having_item= join_arg->in_to_exists_having;

  DBUG_ENTER(""Item_in_subselect::inject_in_to_exists_cond"");
  DBUG_ASSERT(thd == join_arg->thd);

  if (select_lex->min_max_opt_list.elements)
  {
    /*
      MIN/MAX optimizations have been applied to Item_sum objects
      of the subquery this subquery predicate in opt_sum_query().
      Injection of new condition invalidates this optimizations.
      Thus those optimizations must be rolled back.
    */
    List_iterator_fast<Item_sum> it(select_lex->min_max_opt_list);
    Item_sum *item;
    while ((item= it++))
    {
      item->clear();
      item->reset_forced_const();
    }
    if (where_item)
      where_item->update_used_tables();
    if (having_item)
      having_item->update_used_tables();
  }

  if (where_item)
  {
    List<Item> *and_args= NULL;
    /*
      If the top-level Item of the WHERE clause is an AND, detach the multiple
      equality list that was attached to the end of the AND argument list by
      build_equal_items_for_cond(). The multiple equalities must be detached
      because fix_fields merges lower level AND arguments into the upper AND.
      As a result, the arguments from lower-level ANDs are concatenated after
      the multiple equalities. When the multiple equality list is treated as
      such, it turns out that it contains non-Item_equal object which is wrong.
    */
    if (join_arg->conds && join_arg->conds->type() == Item::COND_ITEM &&
        ((Item_cond*) join_arg->conds)->functype() == Item_func::COND_AND_FUNC)
    {
      and_args= ((Item_cond*) join_arg->conds)->argument_list();
      if (join_arg->cond_equal)
        and_args->disjoin((List<Item> *) &join_arg->cond_equal->current_level);
    }

    where_item= and_items(thd, join_arg->conds, where_item);

    /* This is the fix_fields() call mentioned in the comment above */
    if (!where_item->fixed && where_item->fix_fields(thd, 0))
      DBUG_RETURN(true);
    // TIMOUR TODO: call optimize_cond() for the new where clause
    thd->change_item_tree(&select_lex->where, where_item);
    select_lex->where->top_level_item();
    join_arg->conds= select_lex->where;

    /* Attach back the list of multiple equalities to the new top-level AND. */
    if (and_args && join_arg->cond_equal)
    {
      /*
        The fix_fields() call above may have changed the argument list, so
        fetch it again:
      */
      and_args= ((Item_cond*) join_arg->conds)->argument_list();
      ((Item_cond_and *) (join_arg->conds))->m_cond_equal=
                                             *join_arg->cond_equal;
      and_args->append((List<Item> *)&join_arg->cond_equal->current_level);
    }
  }

  if (having_item)
  {
    Item* join_having= join_arg->having ? join_arg->having:join_arg->tmp_having;
    having_item= and_items(thd, join_having, having_item);
    if (fix_having(having_item, select_lex))
      DBUG_RETURN(true);
    // TIMOUR TODO: call optimize_cond() for the new having clause
    thd->change_item_tree(&select_lex->having, having_item);
    select_lex->having->top_level_item();
    join_arg->having= select_lex->having;
  }
  join_arg->thd->change_item_tree(&unit->global_parameters()->select_limit,
                                  new (thd->mem_root)
                                  Item_int(thd, (int32) 1));
  unit->select_limit_cnt= 1;

  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,10263367025656705070609270478346313323,92,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"enum Item_result Item_singlerow_subselect::cmp_type() const
{
  return engine->cmptype();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,4364304555449722325140495371416876974,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_hash_sj_engine::choose_partial_match_strategy(
  bool has_non_null_key, bool has_covering_null_row,
  MY_BITMAP *partial_match_key_parts_arg)
{
  ulonglong pm_buff_size;

  DBUG_ASSERT(strategy == PARTIAL_MATCH);
  /*
    Choose according to global optimizer switch. If only one of the switches is
    'ON', then the remaining strategy is the only possible one. The only cases
    when this will be overridden is when the total size of all buffers for the
    merge strategy is bigger than the 'rowid_merge_buff_size' system variable,
    or if there isn't enough physical memory to allocate the buffers.
  */
  if (!optimizer_flag(thd, OPTIMIZER_SWITCH_PARTIAL_MATCH_ROWID_MERGE) &&
       optimizer_flag(thd, OPTIMIZER_SWITCH_PARTIAL_MATCH_TABLE_SCAN))
    strategy= PARTIAL_MATCH_SCAN;
  else if
     ( optimizer_flag(thd, OPTIMIZER_SWITCH_PARTIAL_MATCH_ROWID_MERGE) &&
      !optimizer_flag(thd, OPTIMIZER_SWITCH_PARTIAL_MATCH_TABLE_SCAN))
    strategy= PARTIAL_MATCH_MERGE;

  /*
    If both switches are ON, or both are OFF, we interpret that as ""let the
    optimizer decide"". Perform a cost based choice between the two partial
    matching strategies.
  */
  /*
    TIMOUR: the above interpretation of the switch values could be changed to:
    - if both are ON - let the optimizer decide,
    - if both are OFF - do not use partial matching, therefore do not use
      materialization in non-top-level predicates.
    The problem with this is that we know for sure if we need partial matching
    only after the subquery is materialized, and this is too late to revert to
    the IN=>EXISTS strategy.
  */
  if (strategy == PARTIAL_MATCH)
  {
    /*
      TIMOUR: Currently we use a super simplistic measure. This will be
      addressed in a separate task.
    */
    if (tmp_table->file->stats.records < 100)
      strategy= PARTIAL_MATCH_SCAN;
    else
      strategy= PARTIAL_MATCH_MERGE;
  }

  /* Check if there is enough memory for the rowid merge strategy. */
  if (strategy == PARTIAL_MATCH_MERGE)
  {
    pm_buff_size= rowid_merge_buff_size(has_non_null_key,
                                        has_covering_null_row,
                                        partial_match_key_parts_arg);
    if (pm_buff_size > thd->variables.rowid_merge_buff_size)
      strategy= PARTIAL_MATCH_SCAN;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,68870422072300704326839706313622945082,58,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_subselect::select_transformer(JOIN *join)
{
  DBUG_ENTER(""Item_subselect::select_transformer"");
  DBUG_ASSERT(thd == join->thd);
  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,251968279943107955002747996955147170836,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::single_value_transformer(JOIN *join)
{
  SELECT_LEX *select_lex= join->select_lex;
  DBUG_ENTER(""Item_in_subselect::single_value_transformer"");
  DBUG_ASSERT(thd == join->thd);

  /*
    Check that the right part of the subselect contains no more than one
    column. E.g. in SELECT 1 IN (SELECT * ..) the right part is (SELECT * ...)
  */
  // psergey: duplicated_subselect_card_check
  if (select_lex->item_list.elements > 1)
  {
    my_error(ER_OPERAND_COLUMNS, MYF(0), 1);
    DBUG_RETURN(true);
  }

  Item* join_having= join->having ? join->having : join->tmp_having;
  if (!(join_having || select_lex->with_sum_func ||
        select_lex->group_list.elements) &&
      select_lex->table_list.elements == 0 && !join->conds &&
      !select_lex->master_unit()->is_union())
  {
    Item *where_item= (Item*) select_lex->item_list.head();
    /*
      it is single select without tables => possible optimization
      remove the dependence mark since the item is moved to upper
      select and is not outer anymore.
    */
    where_item->walk(&Item::remove_dependence_processor, 0,
                     select_lex->outer_select());
    /*
      fix_field of substitution item will be done in time of
      substituting.
      Note that real_item() should be used instead of
      original left expression because left_expr can be
      runtime created Ref item which is deleted at the end
      of the statement. Thus one of 'substitution' arguments
      can be broken in case of PS.
    */ 
    substitution= func->create(thd, left_expr, where_item);
    have_to_be_excluded= 1;
    if (thd->lex->describe)
    {
      char warn_buff[MYSQL_ERRMSG_SIZE];
      sprintf(warn_buff, ER_THD(thd, ER_SELECT_REDUCED),
              select_lex->select_number);
      push_warning(thd, Sql_condition::WARN_LEVEL_NOTE,
                   ER_SELECT_REDUCED, warn_buff);
    }
    DBUG_RETURN(false);
  }

  /*
    Wrap the current IN predicate in an Item_in_optimizer. The actual
    substitution in the Item tree takes place in Item_subselect::fix_fields.
  */
  if (!substitution)
  {
    /* We're invoked for the 1st (or the only) SELECT in the subquery UNION */
    substitution= optimizer;

    SELECT_LEX *current= thd->lex->current_select;

    thd->lex->current_select= current->return_after_parsing();
    if (!optimizer || optimizer->fix_left(thd))
    {
      thd->lex->current_select= current;
      DBUG_RETURN(true);
    }
    thd->lex->current_select= current;

    /* We will refer to upper level cache array => we have to save it for SP */
    optimizer->keep_top_level_cache();

    /*
      As far as  Item_in_optimizer does not substitute itself on fix_fields
      we can use same item for all selects.
    */
    expr= new (thd->mem_root) Item_direct_ref(thd, &select_lex->context,
                              (Item**)optimizer->get_cache(),
			      (char *)""<no matter>"",
			      (char *)in_left_expr_name);
  }

  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,5017039632218122482160305518564548464,87,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"  virtual void visit_field(Item_field *item)
  {
    //for (TABLE_LIST *tbl= new_parent->leaf_tables; tbl; tbl= tbl->next_local)
    //{
    //  if (tbl->table == field->table)
    //  {
        used_tables|= item->field->table->map;
    //    return;
    //  }
    //}
    //used_tables |= OUTER_REF_TABLE_BIT;
  }",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,92880268925868261955609765719308584172,12,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_engine::set_thd(THD *thd_arg)
{
  thd= thd_arg;
  if (result)
    result->set_thd(thd_arg);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,325422230314094040324578757002371458157,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_single_select_engine::cleanup()
{
  DBUG_ENTER(""subselect_single_select_engine::cleanup"");
  prepared= executed= 0;
  join= 0;
  result->cleanup();
  select_lex->uncacheable&= ~UNCACHEABLE_DEPENDENT_INJECTED;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,334822432913806872988168950492946857018,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"table_map subselect_engine::calc_const_tables(List<TABLE_LIST> &list)
{
  table_map map= 0;
  List_iterator<TABLE_LIST> ti(list);
  TABLE_LIST *table;
  //for (; table; table= table->next_leaf)
  while ((table= ti++))
  {
    TABLE *tbl= table->table;
    if (tbl && tbl->const_table)
      map|= tbl->map;
  }
  return map;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,112211474962263573692744346578678356367,14,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::select_transformer(JOIN *join)
{
  return select_in_like_transformer(join);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,101405570100657084843416580426087100820,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::expr_cache_is_needed(THD *thd)
{
  return (optimizer_flag(thd, OPTIMIZER_SWITCH_SUBQUERY_CACHE) &&
          !(engine->uncacheable() & (UNCACHEABLE_RAND |
                                     UNCACHEABLE_SIDEEFFECT)) &&
          !with_recursive_reference);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,154453809224842078759126279584043652616,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_single_select_engine::get_identifier()
{
  return select_lex->select_number; 
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,116255952131792646568056355422001325047,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_single_select_engine::print(String *str,
                                           enum_query_type query_type)
{
  With_clause* with_clause= select_lex->get_with_clause();
  if (with_clause)
    with_clause->print(str, query_type);
  select_lex->print(get_thd(), str, query_type);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,42182694759232703696957918983253942134,8,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_rowid_merge_engine::partial_match()
{
  Ordered_key *min_key; /* Key that contains the current minimum position. */
  rownum_t min_row_num; /* Current row number of min_key. */
  Ordered_key *cur_key;
  rownum_t cur_row_num;
  uint count_nulls_in_search_key= 0;
  uint max_null_in_any_row=
    ((select_materialize_with_stats *) result)->get_max_nulls_in_row();
  bool res= FALSE;

  /* If there is a non-NULL key, it must be the first key in the keys array. */
  DBUG_ASSERT(!non_null_key || (non_null_key && merge_keys[0] == non_null_key));
  /* The prioryty queue for keys must be empty. */
  DBUG_ASSERT(!pq.elements);

  /* All data accesses during execution are via handler::ha_rnd_pos() */
  if (tmp_table->file->ha_rnd_init_with_error(0))
  {
    res= FALSE;
    goto end;
  }

  /* Check if there is a match for the columns of the only non-NULL key. */
  if (non_null_key && !non_null_key->lookup())
  {
    res= FALSE;
    goto end;
  }

  /*
    If all nullable columns contain only NULLs, then there is a guaranteed
    partial match, and we don't need to search for a matching row.
  */
  if (has_covering_null_columns)
  {
    res= TRUE;
    goto end;
  }

  if (non_null_key)
    queue_insert(&pq, (uchar *) non_null_key);
  /*
    Do not add the non_null_key, since it was already processed above.
  */
  bitmap_clear_all(&matching_outer_cols);
  for (uint i= MY_TEST(non_null_key); i < merge_keys_count; i++)
  {
    DBUG_ASSERT(merge_keys[i]->get_column_count() == 1);
    if (merge_keys[i]->get_search_key(0)->null_value)
    {
      ++count_nulls_in_search_key;
      bitmap_set_bit(&matching_outer_cols, merge_keys[i]->get_keyid());
    }
    else if (merge_keys[i]->lookup())
      queue_insert(&pq, (uchar *) merge_keys[i]);
  }

  /*
    If the outer reference consists of only NULLs, or if it has NULLs in all
    nullable columns (above we guarantee there is a match for the non-null
    coumns), the result is UNKNOWN.
  */
  if (count_nulls_in_search_key == merge_keys_count - MY_TEST(non_null_key))
  {
    res= TRUE;
    goto end;
  }

  /*
    If the outer row has NULLs in some columns, and
    there is no match for any of the remaining columns, and
    there is a subquery row with NULLs in all unmatched columns,
    then there is a partial match, otherwise the result is FALSE.
  */
  if (count_nulls_in_search_key && !pq.elements)
  {
    DBUG_ASSERT(!non_null_key);
    /*
      Check if the intersection of all NULL bitmaps of all keys that
      are not in matching_outer_cols is non-empty.
    */
    res= exists_complementing_null_row(&matching_outer_cols);
    goto end;
  }

  /*
    If there is no NULL (sub)row that covers all NULL columns, and there is no
    match for any of the NULL columns, the result is FALSE. Notice that if there
    is a non-null key, and there is only one matching key, the non-null key is
    the matching key. This is so, because this method returns FALSE if the
    non-null key doesn't have a match.
  */
  if (!count_nulls_in_search_key &&
      (!pq.elements ||
       (pq.elements == 1 && non_null_key &&
        max_null_in_any_row < merge_keys_count-1)))
  {
    if (!pq.elements)
    {
      DBUG_ASSERT(!non_null_key);
      /*
        The case of a covering null row is handled by
        subselect_partial_match_engine::exec()
      */
      DBUG_ASSERT(max_null_in_any_row != tmp_table->s->fields);
    }
    res= FALSE;
    goto end;
  }

  DBUG_ASSERT(pq.elements);

  min_key= (Ordered_key*) queue_remove_top(&pq);
  min_row_num= min_key->current();
  bitmap_set_bit(&matching_keys, min_key->get_keyid());
  bitmap_union(&matching_keys, &matching_outer_cols);
  if (min_key->next_same())
    queue_insert(&pq, (uchar *) min_key);

  if (pq.elements == 0)
  {
    /*
      Check the only matching row of the only key min_key for NULL matches
      in the other columns.
    */
    res= test_null_row(min_row_num);
    goto end;
  }

  while (TRUE)
  {
    cur_key= (Ordered_key*) queue_remove_top(&pq);
    cur_row_num= cur_key->current();

    if (cur_row_num == min_row_num)
      bitmap_set_bit(&matching_keys, cur_key->get_keyid());
    else
    {
      /* Follows from the correct use of priority queue. */
      DBUG_ASSERT(cur_row_num > min_row_num);
      if (test_null_row(min_row_num))
      {
        res= TRUE;
        goto end;
      }
      else
      {
        min_key= cur_key;
        min_row_num= cur_row_num;
        bitmap_clear_all(&matching_keys);
        bitmap_set_bit(&matching_keys, min_key->get_keyid());
        bitmap_union(&matching_keys, &matching_outer_cols);
      }
    }

    if (cur_key->next_same())
      queue_insert(&pq, (uchar *) cur_key);

    if (pq.elements == 0)
    {
      /* Check the last row of the last column in PQ for NULL matches. */
      res= test_null_row(min_row_num);
      goto end;
    }
  }

  /* We should never get here - all branches must be handled explicitly above. */
  DBUG_ASSERT(FALSE);

end:
  if (!has_covering_null_columns)
    bitmap_clear_all(&matching_keys);
  queue_remove_all(&pq);
  tmp_table->file->ha_rnd_end();
  return res;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,310938160304615187974487371379061649197,177,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::walk(Item_processor processor, bool walk_subquery,
                          void *argument)
{
  if (!(unit->uncacheable & ~UNCACHEABLE_DEPENDENT) && engine->is_executed() &&
      !unit->describe)
  {
    /*
      The subquery has already been executed (for real, it wasn't EXPLAIN's
      fake execution) so it should not matter what it has inside.
      
      The actual reason for not walking inside is that parts of the subquery
      (e.g. JTBM join nests and their IN-equality conditions may have been 
       invalidated by irreversible cleanups (those happen after an uncorrelated 
       subquery has been executed).
    */
    return (this->*processor)(argument);
  }

  if (walk_subquery)
  {
    for (SELECT_LEX *lex= unit->first_select(); lex; lex= lex->next_select())
    {
      List_iterator<Item> li(lex->item_list);
      Item *item;
      ORDER *order;

      if (lex->where && (lex->where)->walk(processor, walk_subquery, argument))
        return 1;
      if (lex->having && (lex->having)->walk(processor, walk_subquery,
                                             argument))
        return 1;

     if (walk_items_for_table_list(processor, walk_subquery, argument,
                                       *lex->join_list))
        return 1;

      while ((item=li++))
      {
        if (item->walk(processor, walk_subquery, argument))
          return 1;
      }
      for (order= lex->order_list.first ; order; order= order->next)
      {
        if ((*order->item)->walk(processor, walk_subquery, argument))
          return 1;
      }
      for (order= lex->group_list.first ; order; order= order->next)
      {
        if ((*order->item)->walk(processor, walk_subquery, argument))
          return 1;
      }
    }
  }
  return (this->*processor)(argument);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,332126220119840497971299578409207935809,55,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::fix_fields(THD *thd_arg, Item **ref)
{
  uint outer_cols_num;
  List<Item> *inner_cols;
  char const *save_where= thd_arg->where;
  DBUG_ENTER(""Item_in_subselect::fix_fields"");

  thd= thd_arg;
  DBUG_ASSERT(unit->thd == thd);

  if (test_strategy(SUBS_SEMI_JOIN))
    DBUG_RETURN( !( (*ref)= new (thd->mem_root) Item_int(thd, 1)) );

  thd->where= ""IN/ALL/ANY subquery"";
  /*
    Check if the outer and inner IN operands match in those cases when we
    will not perform IN=>EXISTS transformation. Currently this is when we
    use subquery materialization.

    The condition below is true when this method was called recursively from
    inside JOIN::prepare for the JOIN object created by the call chain
    Item_subselect::fix_fields -> subselect_single_select_engine::prepare,
    which creates a JOIN object for the subquery and calls JOIN::prepare for
    the JOIN of the subquery.
    Notice that in some cases, this doesn't happen, and the check_cols()
    test for each Item happens later in
    Item_in_subselect::row_value_in_to_exists_transformer.
    The reason for this mess is that our JOIN::prepare phase works top-down
    instead of bottom-up, so we first do name resoluton and semantic checks
    for the outer selects, then for the inner.
  */
  if (engine &&
      engine->engine_type() == subselect_engine::SINGLE_SELECT_ENGINE &&
      ((subselect_single_select_engine*)engine)->join)
  {
    outer_cols_num= left_expr->cols();

    if (unit->is_union())
      inner_cols= &(unit->types);
    else
      inner_cols= &(unit->first_select()->item_list);
    if (outer_cols_num != inner_cols->elements)
    {
      my_error(ER_OPERAND_COLUMNS, MYF(0), outer_cols_num);
      goto err;
    }
    if (outer_cols_num > 1)
    {
      List_iterator<Item> inner_col_it(*inner_cols);
      Item *inner_col;
      for (uint i= 0; i < outer_cols_num; i++)
      {
        inner_col= inner_col_it++;
        if (inner_col->check_cols(left_expr->element_index(i)->cols()))
          goto err;
      }
    }
  }

  if (left_expr && !left_expr->fixed &&
      left_expr->fix_fields(thd_arg, &left_expr))
    goto err;
  else
  if (Item_subselect::fix_fields(thd_arg, ref))
    goto err;
  fixed= TRUE;
  thd->where= save_where;
  DBUG_RETURN(FALSE);

err:
  thd->where= save_where;
  DBUG_RETURN(TRUE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,266540593328102020273045786646424896035,73,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_single_select_engine::
subselect_single_select_engine(st_select_lex *select,
			       select_result_interceptor *result_arg,
			       Item_subselect *item_arg)
  :subselect_engine(item_arg, result_arg),
   prepared(0), executed(0),
   select_lex(select), join(0)
{
  select_lex->master_unit()->item= item_arg;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,209309931034139431474816693799514346903,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::update_used_tables()
{
  if (!forced_const)
  {
    recalc_used_tables(parent_select, FALSE);
    if (!(engine->uncacheable() & ~UNCACHEABLE_EXPLAIN))
    {
      // did all used tables become static?
      if (!(used_tables_cache & ~engine->upper_select_const_tables()) &&
          ! with_recursive_reference)
        const_item_cache= 1;
    }
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,165381571431540744645780469774164831301,14,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"String *Item_singlerow_subselect::val_str(String *str)
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
  {
    String *res= value->val_str(str);
    null_value= value->null_value;
    return res;
  }
  if (!exec() && !value->null_value)
  {
    null_value= FALSE;
    return value->val_str(str);
  }
  else
  {
    reset();
    DBUG_ASSERT(null_value);
    return 0;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,300378100292225308029301929793093821285,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"my_decimal *Item_singlerow_subselect::val_decimal(my_decimal *decimal_value)
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
  {
    my_decimal *val= value->val_decimal(decimal_value);
    null_value= value->null_value;
    return val;
  }
  if (!exec() && !value->null_value)
  {
    null_value= FALSE;
    return value->val_decimal(decimal_value);
  }
  else
  {
    reset();
    DBUG_ASSERT(null_value);
    return 0;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,155247514688367983676384731861799204471,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_single_select_engine::fix_length_and_dec(Item_cache **row)
{
  DBUG_ASSERT(row || select_lex->item_list.elements==1);
  if (set_row(select_lex->item_list, row))
    return TRUE;
  item->collation.set(row[0]->collation);
  if (cols() != 1)
    maybe_null= 0;
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,209549539481819979215696801847973074384,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_allany_subselect::is_maxmin_applicable(JOIN *join)
{
  /*
    Check if max/min optimization applicable: It is top item of
    WHERE condition.
  */
  return (abort_on_null || (upper_item && upper_item->is_top_level_item())) &&
      !(join->select_lex->master_unit()->uncacheable & ~UNCACHEABLE_EXPLAIN) && !func->eqne_op();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,67067721099385184523436597047641467918,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_rowid_merge_engine::~subselect_rowid_merge_engine()
{
  /* None of the resources below is allocated if there are no ordered keys. */
  if (merge_keys_count)
  {
    my_free(row_num_to_rowid);
    for (uint i= 0; i < merge_keys_count; i++)
      delete merge_keys[i];
    delete_queue(&pq);
    if (tmp_table->file->inited == handler::RND)
      tmp_table->file->ha_rnd_end();
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,188850776891865419289545438007271168440,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_exists_subselect::print(String *str, enum_query_type query_type)
{
  str->append(STRING_WITH_LEN(""exists""));
  Item_subselect::print(str, query_type);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,261576785658709886607765675298195205440,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_singlerow_subselect::invalidate_and_restore_select_lex()
{
  DBUG_ENTER(""Item_singlerow_subselect::invalidate_and_restore_select_lex"");
  st_select_lex *result= get_select_lex();

  DBUG_ASSERT(result);

  /*
    This code restore the parse tree in it's state before the execution of
    Item_singlerow_subselect::Item_singlerow_subselect(),
    and in particular decouples this object from the SELECT_LEX,
    so that the SELECT_LEX can be used with a different flavor
    or Item_subselect instead, as part of query rewriting.
  */
  unit->item= NULL;

  DBUG_RETURN(result);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,143567032210579406595310125523292021886,18,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"uint Item_singlerow_subselect::cols()
{
  return engine->cols();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,291885723094612537645979148486941765626,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_exists_subselect::fix_fields(THD *thd, Item **ref)
{
  DBUG_ENTER(""Item_exists_subselect::fix_fields"");
  if (exists_transformed)
    DBUG_RETURN( !( (*ref)= new (thd->mem_root) Item_int(thd, 1)));
  DBUG_RETURN(Item_subselect::fix_fields(thd, ref));
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,194829205267966501017629937088802296563,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_allany_subselect::no_rows_in_result()
{
  /*
    Subquery predicates outside of the SELECT list must be evaluated in order
    to possibly filter the special result row generated for implicit grouping
    if the subquery is in the HAVING clause.
    If the predicate is constant, we need its actual value in the only result
    row for queries with implicit grouping.
  */
  if (parsing_place != SELECT_LIST || const_item())
    return;
  value= 0;
  null_value= 0;
  was_null= 0;
  make_const();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,60181994959936810300036059416462001886,16,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_hash_sj_engine::make_semi_join_conds()
{
  /*
    Table reference for tmp_table that is used to resolve column references
    (Item_fields) to columns in tmp_table.
  */
  TABLE_LIST *tmp_table_ref;
  /* Name resolution context for all tmp_table columns created below. */
  Name_resolution_context *context;
  Item_in_subselect *item_in= (Item_in_subselect *) item;

  DBUG_ENTER(""subselect_hash_sj_engine::make_semi_join_conds"");
  DBUG_ASSERT(semi_join_conds == NULL);

  if (!(semi_join_conds= new (thd->mem_root) Item_cond_and(thd)))
    DBUG_RETURN(TRUE);

  if (!(tmp_table_ref= (TABLE_LIST*) thd->alloc(sizeof(TABLE_LIST))))
    DBUG_RETURN(TRUE);

  tmp_table_ref->init_one_table(STRING_WITH_LEN(""""),
                                tmp_table->alias.c_ptr(),
                                tmp_table->alias.length(),
                                NULL, TL_READ);
  tmp_table_ref->table= tmp_table;

  context= new Name_resolution_context;
  context->init();
  context->first_name_resolution_table=
    context->last_name_resolution_table= tmp_table_ref;
  semi_join_conds_context= context;
  
  for (uint i= 0; i < item_in->left_expr->cols(); i++)
  {
    /* New equi-join condition for the current column. */
    Item_func_eq *eq_cond;
    /* Item for the corresponding field from the materialized temp table. */
    Item_field *right_col_item;

    if (!(right_col_item= new (thd->mem_root)
          Item_temptable_field(thd, context, tmp_table->field[i])) ||
        !(eq_cond= new (thd->mem_root)
          Item_func_eq(thd, item_in->left_expr->element_index(i),
                       right_col_item)) ||
        (((Item_cond_and*)semi_join_conds)->add(eq_cond, thd->mem_root)))
    {
      delete semi_join_conds;
      semi_join_conds= NULL;
      DBUG_RETURN(TRUE);
    }
  }
  if (semi_join_conds->fix_fields(thd, (Item**)&semi_join_conds))
    DBUG_RETURN(TRUE);

  DBUG_RETURN(FALSE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,291851124624510321475490818165041977538,56,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int Item_in_subselect::optimize(double *out_rows, double *cost)
{
  int res;
  DBUG_ENTER(""Item_in_subselect::optimize"");
  DBUG_ASSERT(fixed);
  SELECT_LEX *save_select= thd->lex->current_select;
  JOIN *join= unit->first_select()->join;

  thd->lex->current_select= join->select_lex;
  if ((res= join->optimize()))
    DBUG_RETURN(res);

  /* Calculate #rows and cost of join execution */
  join->get_partial_cost_and_fanout(join->table_count - join->const_tables, 
                                    table_map(-1),
                                    cost, out_rows);

  /*
    Adjust join output cardinality. There can be these cases:
    - Have no GROUP BY and no aggregate funcs: we won't get into this 
      function because such join will be processed as a merged semi-join 
      (TODO: does it really mean we don't need to handle such cases here at 
       all? put ASSERT)
    - Have no GROUP BY but have aggregate funcs: output is 1 record.
    - Have GROUP BY and have (or not) aggregate funcs:  need to adjust output 
      cardinality.
  */
  thd->lex->current_select= save_select;
  if (!join->group_list && !join->group_optimized_away &&
      join->tmp_table_param.sum_func_count)
  {
    DBUG_PRINT(""info"",(""Materialized join will have only 1 row (it has ""
                       ""aggregates but no GROUP BY""));
    *out_rows= 1;
  }
  
  /* Now with grouping */
  if (join->group_list_for_estimates)
  {
    DBUG_PRINT(""info"",(""Materialized join has grouping, trying to estimate it""));
    double output_rows= get_post_group_estimate(join, *out_rows);
    DBUG_PRINT(""info"",(""Got value of %g"", output_rows));
    *out_rows= output_rows;
  }

  DBUG_RETURN(res);

}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,125377147612290762549865105394374886554,48,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_rowid_merge_engine::cmp_keys_by_cur_rownum(void *arg,
                                                     uchar *k1, uchar *k2)
{
  rownum_t r1= ((Ordered_key*) k1)->current();
  rownum_t r2= ((Ordered_key*) k2)->current();

  return (r1 < r2) ? -1 : (r1 > r2) ? 1 : 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,256613376221702965597963298369275571779,8,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::select_in_like_transformer(JOIN *join)
{
  Query_arena *arena= 0, backup;
  SELECT_LEX *current= thd->lex->current_select;
  const char *save_where= thd->where;
  bool trans_res= true;
  bool result;

  DBUG_ENTER(""Item_in_subselect::select_in_like_transformer"");
  DBUG_ASSERT(thd == join->thd);

  /*
    IN/SOME/ALL/ANY subqueries aren't support LIMIT clause. Without it
    ORDER BY clause becomes meaningless thus we drop it here.
  */
  for (SELECT_LEX *sl= current->master_unit()->first_select();
       sl; sl= sl->next_select())
  {
    if (sl->join)
    {
      sl->join->order= 0;
      sl->join->skip_sort_order= 1;
    }
  }

  thd->where= ""IN/ALL/ANY subquery"";

  /*
    In some optimisation cases we will not need this Item_in_optimizer
    object, but we can't know it here, but here we need address correct
    reference on left expression.

    note: we won't need Item_in_optimizer when handling degenerate cases
    like ""... IN (SELECT 1)""
  */
  arena= thd->activate_stmt_arena_if_needed(&backup);
  if (!optimizer)
  {
    optimizer= new (thd->mem_root) Item_in_optimizer(thd, left_expr_orig, this);
    if ((result= !optimizer))
      goto out;
  }

  thd->lex->current_select= current->return_after_parsing();
  result= optimizer->fix_left(thd);
  thd->lex->current_select= current;

  if (changed)
  {
    trans_res= false;
    goto out;
  }


  if (result)
    goto out;

  /*
    Both transformers call fix_fields() only for Items created inside them,
    and all that items do not make permanent changes in current item arena
    which allow to us call them with changed arena (if we do not know nature
    of Item, we have to call fix_fields() for it only with original arena to
    avoid memory leak)
  */
  if (left_expr->cols() == 1)
    trans_res= single_value_transformer(join);
  else
  {
    /* we do not support row operation for ALL/ANY/SOME */
    if (func != &eq_creator)
    {
      if (arena)
        thd->restore_active_arena(arena, &backup);
      my_error(ER_OPERAND_COLUMNS, MYF(0), 1);
      DBUG_RETURN(true);
    }
    trans_res= row_value_transformer(join);
  }
out:
  if (arena)
    thd->restore_active_arena(arena, &backup);
  thd->where= save_where;
  DBUG_RETURN(trans_res);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,65331715122790938480945939775284443862,84,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::init_expr_cache_tracker(THD *thd)
{
  if(!expr_cache)
    return;

  Explain_query *qw= thd->lex->explain;
  DBUG_ASSERT(qw);
  Explain_node *node= qw->get_node(unit->first_select()->select_number);
  if (!node)
    return;
  DBUG_ASSERT(expr_cache->type() == Item::EXPR_CACHE_ITEM);
  node->cache_tracker= ((Item_cache_wrapper *)expr_cache)->init_tracker(qw->mem_root);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,114177647856778403209980330739996639913,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::print(String *str, enum_query_type query_type)
{
  if (query_type & QT_ITEM_SUBSELECT_ID_ONLY)
  {
    str->append(""(subquery#"");
    if (unit && unit->first_select())
    {
      char buf[64];
      ll2str(unit->first_select()->select_number, buf, 10, 0); 
      str->append(buf);
    }
    else
      str->append(""NULL""); // TODO: what exactly does this mean?

    str->append("")"");
    return;
  }
  if (engine)
  {
    str->append('(');
    engine->print(str, query_type);
    str->append(')');
  }
  else
    str->append(""(...)"");
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,328949747709019730991062348878057172552,26,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::eliminate_subselect_processor(void *arg)
{
  unit->item= NULL;
  unit->exclude();
  eliminated= TRUE;
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,259401781270132944209837312460138237407,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Ordered_key::sort_keys()
{
  if (tbl->file->ha_rnd_init_with_error(0))
    return TRUE;
  my_qsort2(key_buff, (size_t) key_buff_elements, sizeof(rownum_t),
            (qsort2_cmp) &cmp_keys_by_row_data_and_rownum, (void*) this);
  /* Invalidate the current row position. */
  cur_key_idx= HA_POS_ERROR;
  tbl->file->ha_rnd_end();
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,206290104004538056909483664654175323008,11,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_singlerow_subselect::bring_value()
{
  if (!exec() && assigned())
  {
    null_value= true;
    for (uint i= 0; i < max_columns ; i++)
    {
      if (!row[i]->null_value)
      {
        null_value= false;
        return;
      }
    }
  }
  else
    reset();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,95954075631129386071987028442324326887,17,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_in_subselect::cleanup()
{
  DBUG_ENTER(""Item_in_subselect::cleanup"");
  if (left_expr_cache)
  {
    left_expr_cache->delete_elements();
    delete left_expr_cache;
    left_expr_cache= NULL;
  }
  /*
    TODO: This breaks the commented assert in add_strategy().
    in_strategy&= ~SUBS_STRATEGY_CHOSEN;
  */
  first_execution= TRUE;
  pushed_cond_guards= NULL;
  Item_subselect::cleanup();
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,90876402017853630545732134931745217089,18,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"static bool find_inner_outer_equalities(Item **conds,
                                        Dynamic_array<EQ_FIELD_OUTER> &result)
{
  bool found=  FALSE;
  EQ_FIELD_OUTER element;
  if (is_cond_and(*conds))
  {
    List_iterator<Item> li(*((Item_cond*)*conds)->argument_list());
    Item *item;
    bool allow_subselect= true;
    while ((item= li++))
    {
      if (item->type() == Item::FUNC_ITEM &&
          check_equality_for_exist2in((Item_func *)item,
                                      allow_subselect,
                                      &element.local_field,
                                      &element.outer_exp))
      {
        found= TRUE;
        allow_subselect= false;
        element.eq_ref= li.ref();
        if (result.append(element))
          goto alloc_err;
      }
    }
  }
  else if ((*conds)->type() == Item::FUNC_ITEM &&
           check_equality_for_exist2in((Item_func *)*conds,
                                       true,
                                       &element.local_field,
                                       &element.outer_exp))
  {
    found= TRUE;
    element.eq_ref= conds;
    if (result.append(element))
      goto alloc_err;
  }

  return !found;
alloc_err:
  return TRUE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,219860273656803079775410414577462894082,42,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_uniquesubquery_engine::exclude()
{
  //this never should be called
  DBUG_ASSERT(0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,231124397662515002126816452193116218381,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Ordered_key::init(MY_BITMAP *columns_to_index)
{
  THD *thd= tbl->in_use;
  uint cur_key_col= 0;
  Item_field *cur_tmp_field;
  Item_func_lt *fn_less_than;

  key_column_count= bitmap_bits_set(columns_to_index);
  key_columns= (Item_field**) thd->alloc(key_column_count *
                                         sizeof(Item_field*));
  compare_pred= (Item_func_lt**) thd->alloc(key_column_count *
                                            sizeof(Item_func_lt*));

  if (!key_columns || !compare_pred)
    return TRUE; /* Revert to table scan partial match. */

  for (uint i= 0; i < columns_to_index->n_bits; i++)
  {
    if (!bitmap_is_set(columns_to_index, i))
      continue;
    cur_tmp_field= new (thd->mem_root) Item_field(thd, tbl->field[i]);
    /* Create the predicate (tmp_column[i] < outer_ref[i]). */
    fn_less_than= new (thd->mem_root) Item_func_lt(thd, cur_tmp_field,
                                   search_key->element_index(i));
    fn_less_than->fix_fields(thd, (Item**) &fn_less_than);
    key_columns[cur_key_col]= cur_tmp_field;
    compare_pred[cur_key_col]= fn_less_than;
    ++cur_key_col;
  }

  if (alloc_keys_buffers())
  {
    /* TIMOUR revert to partial match via table scan. */
    return TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,242962493770675869807112382423947997440,37,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::fix_fields(THD *thd_param, Item **ref)
{
  char const *save_where= thd_param->where;
  uint8 uncacheable;
  bool res;

  thd= thd_param;

  DBUG_ASSERT(unit->thd == thd);

  status_var_increment(thd_param->status_var.feature_subquery);

  DBUG_ASSERT(fixed == 0);
  engine->set_thd((thd= thd_param));
  if (!done_first_fix_fields)
  {
    done_first_fix_fields= TRUE;
    inside_first_fix_fields= TRUE;
    upper_refs.empty();
    /*
      psergey-todo: remove _first_fix_fields calls, we need changes on every
      execution
    */
  }

  eliminated= FALSE;
  parent_select= thd_param->lex->current_select;

  if (check_stack_overrun(thd, STACK_MIN_SIZE, (uchar*)&res))
    return TRUE;
  
  
  if (!(res= engine->prepare(thd)))
  {
    // all transformation is done (used by prepared statements)
    changed= 1;
    inside_first_fix_fields= FALSE;

    /*
      Substitute the current item with an Item_in_optimizer that was
      created by Item_in_subselect::select_in_like_transformer and
      call fix_fields for the substituted item which in turn calls
      engine->prepare for the subquery predicate.
    */
    if (substitution)
    {
      /*
        If the top item of the WHERE/HAVING condition changed,
        set correct WHERE/HAVING for PS.
      */
      if (unit->outer_select()->where == (*ref))
        unit->outer_select()->where= substitution;
      else if (unit->outer_select()->having == (*ref))
        unit->outer_select()->having= substitution;

      (*ref)= substitution;
      substitution->name= name;
      substitution->name_length= name_length;
      if (have_to_be_excluded)
	engine->exclude();
      substitution= 0;
      thd->where= ""checking transformed subquery"";
      if (!(*ref)->fixed)
	res= (*ref)->fix_fields(thd, ref);
      goto end;

    }
    // Is it one field subselect?
    if (engine->cols() > max_columns)
    {
      my_error(ER_OPERAND_COLUMNS, MYF(0), 1);
      res= TRUE;
      goto end;
    }
    if (fix_length_and_dec())
    {
      res= TRUE;
      goto end;
    }
  }
  else
    goto end;
  
  if ((uncacheable= engine->uncacheable() & ~UNCACHEABLE_EXPLAIN) ||
      with_recursive_reference)
  {
    const_item_cache= 0;
    if (uncacheable & UNCACHEABLE_RAND)
      used_tables_cache|= RAND_TABLE_BIT;
  }
  fixed= 1;

end:
  done_first_fix_fields= FALSE;
  inside_first_fix_fields= FALSE;
  thd->where= save_where;
  return res;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,193748442790990470770163529753081682689,98,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::is_expensive()
{
  double examined_rows= 0;
  bool all_are_simple= true;

  /* check extremely simple select */
  if (!unit->first_select()->next_select()) // no union
  {
    /*
      such single selects works even without optimization because
      can not makes loops
    */
    SELECT_LEX *sl= unit->first_select();
    JOIN *join = sl->join;
    if (join && !join->tables_list && !sl->first_inner_unit())
      return false;
  }


  for (SELECT_LEX *sl= unit->first_select(); sl; sl= sl->next_select())
  {
    JOIN *cur_join= sl->join;

    /* not optimized subquery */
    if (!cur_join)
      return true;

    /*
      If the subquery is not optimised or in the process of optimization
      it supposed to be expensive
    */
    if (cur_join->optimization_state != JOIN::OPTIMIZATION_DONE)
      return true;

    if (!cur_join->tables_list && !sl->first_inner_unit())
      continue;

    /*
      Subqueries whose result is known after optimization are not expensive.
      Such subqueries have all tables optimized away, thus have no join plan.
    */
    if ((cur_join->zero_result_cause || !cur_join->tables_list))
      continue;

    /*
      This is not simple SELECT in union so we can not go by simple condition
    */
    all_are_simple= false;

    /*
      If a subquery is not optimized we cannot estimate its cost. A subquery is
      considered optimized if it has a join plan.
    */
    if (!cur_join->join_tab)
      return true;

    if (sl->first_inner_unit())
    {
      /*
        Subqueries that contain subqueries are considered expensive.
        @todo: accumulate the cost of subqueries.
      */
      return true;
    }

    examined_rows+= cur_join->get_examined_rows();
  }

  // here we are sure that subquery is optimized so thd is set
  return !all_are_simple &&
    (examined_rows > thd->variables.expensive_subquery_limit);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,178994525327387477493661479215156502520,72,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"my_decimal *Item_in_subselect::val_decimal(my_decimal *decimal_value)
{
  /*
    As far as Item_in_subselect called only from Item_in_optimizer this
    method should not be used
  */
  DBUG_ASSERT(0);
  if (forced_const)
    goto value_is_ready;
  DBUG_ASSERT((engine->uncacheable() & ~UNCACHEABLE_EXPLAIN) ||
              ! engine->is_executed());
  null_value= was_null= FALSE;
  DBUG_ASSERT(fixed == 1);
  if (exec())
  {
    reset();
    return 0;
  }
  if (was_null && !value)
    null_value= TRUE;
value_is_ready:
  int2my_decimal(E_DEC_FATAL_ERROR, value, 0, decimal_value);
  return decimal_value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,180600606890706401737718845712454340873,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_allany_subselect::select_transformer(JOIN *join)
{
  DBUG_ENTER(""Item_allany_subselect::select_transformer"");
  DBUG_ASSERT((in_strategy & ~(SUBS_MAXMIN_INJECTED | SUBS_MAXMIN_ENGINE |
                               SUBS_IN_TO_EXISTS | SUBS_STRATEGY_CHOSEN)) == 0);
  if (upper_item)
    upper_item->show= 1;
  DBUG_RETURN(select_in_like_transformer(join));
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,18538679723178126465722290280227059897,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::register_as_with_rec_ref(With_element *with_elem)
{
  with_elem->sq_with_rec_ref.link_in_list(this, &this->next_with_rec_ref);
  with_recursive_reference= true;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,6626875286598539058704615749239320107,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_singlerow_subselect::val_bool()
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
  {
    bool val= value->val_bool();
    null_value= value->null_value;
    return val;
  }
  if (!exec() && !value->null_value)
  {
    null_value= FALSE;
    return value->val_bool();
  }
  else
  {
    reset();
    DBUG_ASSERT(null_value);
    return 0;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,70149055548194002705444080814307423536,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_single_select_engine::change_result(Item_subselect *si,
                                              select_result_interceptor *res,
                                              bool temp)
{
  DBUG_ENTER(""subselect_single_select_engine::change_result"");
  item= si;
  if (temp)
  {
    /*
      Here we reuse change_item_tree to roll back assignment.  It has
      nothing special about Item* pointer so it is safe conversion. We do
      not change the interface to be compatible with MySQL.
    */
    thd->change_item_tree((Item**) &result, (Item*)res);
  }
  else
    result= res;

  /*
    We can't use 'result' below as gcc 4.2.4's alias optimization
    assumes that result was not changed by thd->change_item_tree().
    I tried to find a solution to make gcc happy, but could not find anything
    that would not require a lot of extra code that would be harder to manage
    than the current code.
  */
  DBUG_RETURN(select_lex->join->change_result(res, NULL));
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,337006924875457430563903255603346130315,27,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_union_engine::fix_length_and_dec(Item_cache **row)
{
  DBUG_ASSERT(row || unit->first_select()->item_list.elements==1);

  if (unit->first_select()->item_list.elements == 1)
  {
    if (set_row(unit->types, row))
      return TRUE;
    item->collation.set(row[0]->collation);
  }
  else
  {
    bool maybe_null_saved= maybe_null;
    if (set_row(unit->types, row))
      return TRUE;
    maybe_null= maybe_null_saved;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,86304584169661471816903709526833385446,19,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_hash_sj_engine::make_unique_engine()
{
  Item_in_subselect *item_in= (Item_in_subselect *) item;
  Item_iterator_row it(item_in->left_expr);
  /* The only index on the temporary table. */
  KEY *tmp_key= tmp_table->key_info;
  JOIN_TAB *tab;

  DBUG_ENTER(""subselect_hash_sj_engine::make_unique_engine"");

  /*
    Create and initialize the JOIN_TAB that represents an index lookup
    plan operator into the materialized subquery result. Notice that:
    - this JOIN_TAB has no corresponding JOIN (and doesn't need one), and
    - here we initialize only those members that are used by
      subselect_uniquesubquery_engine, so these objects are incomplete.
  */
  if (!(tab= (JOIN_TAB*) thd->alloc(sizeof(JOIN_TAB))))
    DBUG_RETURN(NULL);

  tab->table= tmp_table;
  tab->preread_init_done= FALSE;
  tab->ref.tmp_table_index_lookup_init(thd, tmp_key, it, FALSE);

  DBUG_RETURN(new subselect_uniquesubquery_engine(thd, tab, item,
                                                  semi_join_conds));
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,45662601747744550377174818098772158711,27,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_table_scan_engine::cleanup()
{
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,218677400514654849627729152005245930821,3,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Ordered_key::~Ordered_key()
{
  my_free(key_buff);
  my_bitmap_free(&null_key);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,106657603469695937243584909958748754330,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"double Item_singlerow_subselect::val_real()
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
    return value->val_real();
  if (!exec() && !value->null_value)
  {
    null_value= FALSE;
    return value->val_real();
  }
  else
  {
    reset();
    return 0;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,308111277219184545745474335282768780934,16,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_union_engine::exclude()
{
  unit->exclude_level();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,246455366774503425266696369394647687101,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item* Item_exists_subselect::expr_cache_insert_transformer(THD *tmp_thd,
                                                           uchar *unused)
{
  DBUG_ENTER(""Item_exists_subselect::expr_cache_insert_transformer"");
  DBUG_ASSERT(thd == tmp_thd);

  if (expr_cache)
    DBUG_RETURN(expr_cache);

  if (substype() == EXISTS_SUBS && expr_cache_is_needed(tmp_thd) &&
      (expr_cache= set_expr_cache(tmp_thd)))
  {
    init_expr_cache_tracker(tmp_thd);
    DBUG_RETURN(expr_cache);
  }
  DBUG_RETURN(this);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,113174078576109964054734459781930086474,17,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_singlerow_subselect::check_cols(uint c)
{
  if (c != engine->cols())
  {
    my_error(ER_OPERAND_COLUMNS, MYF(0), c);
    return 1;
  }
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,321400492557685328382420345703377782697,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_union_engine::force_reexecution()
{ 
  unit->executed= false;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,246272994607112288977606048966763047421,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_single_select_engine::no_rows()
{ 
  return !item->assigned();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,290800494512129404209467529943790790439,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_rowid_merge_engine::init(MY_BITMAP *non_null_key_parts,
                                   MY_BITMAP *partial_match_key_parts)
{
  THD *thd= get_thd();
  /* The length in bytes of the rowids (positions) of tmp_table. */
  uint rowid_length= tmp_table->file->ref_length;
  ha_rows row_count= tmp_table->file->stats.records;
  rownum_t cur_rownum= 0;
  select_materialize_with_stats *result_sink=
    (select_materialize_with_stats *) result;
  uint cur_keyid= 0;
  Item_in_subselect *item_in= (Item_in_subselect*) item;
  int error;

  if (merge_keys_count == 0)
  {
    DBUG_ASSERT(bitmap_bits_set(partial_match_key_parts) == 0 ||
                has_covering_null_row);
    /* There is nothing to initialize, we will only do regular lookups. */
    return FALSE;
  }

  /*
    If all nullable columns contain only NULLs, there must be one index
    over all non-null columns.
  */
  DBUG_ASSERT(!has_covering_null_columns ||
              (has_covering_null_columns &&
               merge_keys_count == 1 && non_null_key_parts));
  /*
    Allocate buffers to hold the merged keys and the mapping between rowids and
    row numbers. All small buffers are allocated in the runtime memroot. Big
    buffers are allocated from the OS via malloc.
  */
  if (!(merge_keys= (Ordered_key**) thd->alloc(merge_keys_count *
                                               sizeof(Ordered_key*))) ||
      !(null_bitmaps= (MY_BITMAP**) thd->alloc(merge_keys_count *
                                               sizeof(MY_BITMAP*))) ||
      !(row_num_to_rowid= (uchar*) my_malloc((size_t)(row_count * rowid_length),
        MYF(MY_WME | MY_THREAD_SPECIFIC))))
    return TRUE;

  /* Create the only non-NULL key if there is any. */
  if (non_null_key_parts)
  {
    non_null_key= new Ordered_key(cur_keyid, tmp_table, item_in->left_expr,
                                  0, 0, 0, row_num_to_rowid);
    if (non_null_key->init(non_null_key_parts))
      return TRUE;
    merge_keys[cur_keyid]= non_null_key;
    merge_keys[cur_keyid]->first();
    ++cur_keyid;
  }

  /*
    If all nullable columns contain NULLs, the only key that is needed is the
    only non-NULL key that is already created above.
  */
  if (!has_covering_null_columns)
  {
    if (my_bitmap_init_memroot(&matching_keys, merge_keys_count, thd->mem_root) ||
        my_bitmap_init_memroot(&matching_outer_cols, merge_keys_count, thd->mem_root))
      return TRUE;

    /*
      Create one single-column NULL-key for each column in
      partial_match_key_parts.
    */
    for (uint i= 0; i < partial_match_key_parts->n_bits; i++)
    {
      /* Skip columns that have no NULLs, or contain only NULLs. */
      if (!bitmap_is_set(partial_match_key_parts, i) ||
          result_sink->get_null_count_of_col(i) == row_count)
        continue;

      merge_keys[cur_keyid]= new Ordered_key(
                                     cur_keyid, tmp_table,
                                     item_in->left_expr->element_index(i),
                                     result_sink->get_null_count_of_col(i),
                                     result_sink->get_min_null_of_col(i),
                                     result_sink->get_max_null_of_col(i),
                                     row_num_to_rowid);
      if (merge_keys[cur_keyid]->init(i))
        return TRUE;
      merge_keys[cur_keyid]->first();
      ++cur_keyid;
    }
  }
  DBUG_ASSERT(cur_keyid == merge_keys_count);

  /* Populate the indexes with data from the temporary table. */
  if (tmp_table->file->ha_rnd_init_with_error(1))
    return TRUE;
  tmp_table->file->extra_opt(HA_EXTRA_CACHE,
                             current_thd->variables.read_buff_size);
  tmp_table->null_row= 0;
  while (TRUE)
  {
    error= tmp_table->file->ha_rnd_next(tmp_table->record[0]);
    if (error == HA_ERR_RECORD_DELETED)
    {
      /* We get this for duplicate records that should not be in tmp_table. */
      continue;
    }
    /*
      This is a temp table that we fully own, there should be no other
      cause to stop the iteration than EOF.
    */
    DBUG_ASSERT(!error || error == HA_ERR_END_OF_FILE);
    if (error == HA_ERR_END_OF_FILE)
    {
      DBUG_ASSERT(cur_rownum == tmp_table->file->stats.records);
      break;
    }

    /*
      Save the position of this record in the row_num -> rowid mapping.
    */
    tmp_table->file->position(tmp_table->record[0]);
    memcpy(row_num_to_rowid + cur_rownum * rowid_length,
           tmp_table->file->ref, rowid_length);

    /* Add the current row number to the corresponding keys. */
    if (non_null_key)
    {
      /* By definition there are no NULLs in the non-NULL key. */
      non_null_key->add_key(cur_rownum);
    }

    for (uint i= (non_null_key ? 1 : 0); i < merge_keys_count; i++)
    {
      /*
        Check if the first and only indexed column contains NULL in the current
        row, and add the row number to the corresponding key.
      */
      if (merge_keys[i]->get_field(0)->is_null())
        merge_keys[i]->set_null(cur_rownum);
      else
        merge_keys[i]->add_key(cur_rownum);
    }
    ++cur_rownum;
  }

  tmp_table->file->ha_rnd_end();

  /* Sort all the keys by their NULL selectivity. */
  my_qsort(merge_keys, merge_keys_count, sizeof(Ordered_key*),
           (qsort_cmp) cmp_keys_by_null_selectivity);

  /* Sort the keys in each of the indexes. */
  for (uint i= 0; i < merge_keys_count; i++)
    if (merge_keys[i]->sort_keys())
      return TRUE;

  if (init_queue(&pq, merge_keys_count, 0, FALSE,
                 subselect_rowid_merge_engine::cmp_keys_by_cur_rownum, NULL,
                 0, 0))
    return TRUE;

  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,268028267929135430869608549042177307209,161,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"double get_post_group_estimate(JOIN* join, double join_op_rows)
{
  table_map tables_in_group_list= table_map(0);

  /* Find out which tables are used in GROUP BY list */
  for (ORDER *order= join->group_list_for_estimates; order; order= order->next)
  {
    Item *item= order->item[0];
    table_map item_used_tables= item->used_tables();
    if (item_used_tables & RAND_TABLE_BIT)
    {
      /* Each join output record will be in its own group */
      return join_op_rows;
    }
    tables_in_group_list|= item_used_tables;
  }
  tables_in_group_list &= ~PSEUDO_TABLE_BITS;

  /*
    Use join fanouts to calculate the max. number of records in the group-list
  */
  double fanout_rows[MAX_KEY];
  bzero(&fanout_rows, sizeof(fanout_rows));
  double out_rows;
  
  out_rows= get_fanout_with_deps(join, tables_in_group_list);

#if 0
  /* The following will be needed when making use of index stats: */
  /* 
    Also generate max. number of records for each of the tables mentioned 
    in the group-list. We'll use that a baseline number that we'll try to 
    reduce by using
     - #table-records 
     - index statistics.
  */
  Table_map_iterator tm_it(tables_in_group_list);
  int tableno;
  while ((tableno = tm_it.next_bit()) != Table_map_iterator::BITMAP_END)
  {
    fanout_rows[tableno]= get_fanout_with_deps(join, table_map(1) << tableno);
  }
  
  /*
    Try to bring down estimates using index statistics.
  */
  //check_out_index_stats(join);
#endif

  return out_rows;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,33425618849537536366007715560175462328,51,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_maxmin_subselect::no_rows_in_result()
{
  /*
    Subquery predicates outside of the SELECT list must be evaluated in order
    to possibly filter the special result row generated for implicit grouping
    if the subquery is in the HAVING clause.
    If the predicate is constant, we need its actual value in the only result
    row for queries with implicit grouping.
  */
  if (parsing_place != SELECT_LIST || const_item())
    return;
  value= Item_cache::get_cache(thd, new (thd->mem_root) Item_null(thd));
  null_value= 0;
  was_values= 0;
  make_const();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,178050245135283959870901905083455641167,16,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"uint8 subselect_union_engine::uncacheable()
{
  return unit->uncacheable;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,171305599027039101624013342814889465017,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Ordered_key::Ordered_key(uint keyid_arg, TABLE *tbl_arg, Item *search_key_arg,
                         ha_rows null_count_arg, ha_rows min_null_row_arg,
                         ha_rows max_null_row_arg, uchar *row_num_to_rowid_arg)
  : keyid(keyid_arg), tbl(tbl_arg), search_key(search_key_arg),
    row_num_to_rowid(row_num_to_rowid_arg), null_count(null_count_arg)
{
  DBUG_ASSERT(tbl->file->stats.records > null_count);
  key_buff_elements= tbl->file->stats.records - null_count;
  cur_key_idx= HA_POS_ERROR;

  DBUG_ASSERT((null_count && min_null_row_arg && max_null_row_arg) ||
              (!null_count && !min_null_row_arg && !max_null_row_arg));
  if (null_count)
  {
    /* The counters are 1-based, for key access we need 0-based indexes. */
    min_null_row= min_null_row_arg - 1;
    max_null_row= max_null_row_arg - 1;
  }
  else
    min_null_row= max_null_row= 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,340075176183297325975588703428886937885,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_singlerow_subselect::null_inside()
{
  for (uint i= 0; i < max_columns ; i++)
  {
    if (row[i]->null_value)
      return 1;
  }
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,169739555493292786554299467296669417468,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Ordered_key::next_same()
{
  DBUG_ASSERT(key_buff_elements);

  if (cur_key_idx < key_buff_elements - 1)
  {
    /*
      TIMOUR:
      The below is quite inefficient, since as a result we will fetch every
      row (except the last one) twice. There must be a more efficient way,
      e.g. swapping record[0] and record[1], and reading only the new record.
    */
    if (!cmp_keys_by_row_data(key_buff[cur_key_idx], key_buff[cur_key_idx + 1]))
    {
      ++cur_key_idx;
      return TRUE;
    }
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,325564597419058886600328715769218474370,20,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_singlerow_subselect::no_rows_in_result()
{
  /*
    Subquery predicates outside of the SELECT list must be evaluated in order
    to possibly filter the special result row generated for implicit grouping
    if the subquery is in the HAVING clause.
    If the predicate is constant, we need its actual value in the only result
    row for queries with implicit grouping.
  */
  if (parsing_place != SELECT_LIST || const_item())
    return;
  value= Item_cache::get_cache(thd, new (thd->mem_root) Item_null(thd));
  reset();
  make_const();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,139154213673196062363408010251832529999,15,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"double get_fanout_with_deps(JOIN *join, table_map tset)
{
  /* Handle the case of ""Impossible WHERE"" */
  if (join->table_count == 0)
    return 0.0;

  /* First, recursively get all tables we depend on */
  table_map deps_to_check= tset;
  table_map checked_deps= 0;
  table_map further_deps;
  do
  {
    further_deps= 0;
    Table_map_iterator tm_it(deps_to_check);
    int tableno;
    while ((tableno = tm_it.next_bit()) != Table_map_iterator::BITMAP_END)
    {
      /* get tableno's dependency tables that are not in needed_set */
      further_deps |= join->map2table[tableno]->ref.depend_map & ~checked_deps;
    }

    checked_deps |= deps_to_check;
    deps_to_check= further_deps;
  } while (further_deps != 0);

  
  /* Now, walk the join order and calculate the fanout */
  double fanout= 1;
  for (JOIN_TAB *tab= first_top_level_tab(join, WITHOUT_CONST_TABLES); tab;
       tab= next_top_level_tab(join, tab))
  {
    /* 
      Ignore SJM nests. They have tab->table==NULL. There is no point to walk
      inside them, because GROUP BY clause cannot refer to tables from within
      subquery.
    */
    if (!tab->is_sjm_nest() && (tab->table->map & checked_deps) && 
        !tab->emb_sj_nest && 
        tab->records_read != 0)
    {
      fanout *= tab->records_read;
    }
  } 
  return fanout;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,263238576410121731807393402117706570074,45,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::Item_in_subselect(THD *thd, Item * left_exp,
				     st_select_lex *select_lex):
  Item_exists_subselect(thd), left_expr_cache(0), first_execution(TRUE),
  in_strategy(SUBS_NOT_TRANSFORMED),
  pushed_cond_guards(NULL), do_not_convert_to_sj(FALSE), is_jtbm_merged(FALSE),
  is_jtbm_const_tab(FALSE), is_flattenable_semijoin(FALSE),
  is_registered_semijoin(FALSE),
  upper_item(0)
{
  DBUG_ENTER(""Item_in_subselect::Item_in_subselect"");
  DBUG_PRINT(""info"", (""in_strategy: %u"", (uint)in_strategy));
  left_expr_orig= left_expr= left_exp;
  /* prepare to possible disassembling the item in convert_subq_to_sj() */
  if (left_exp->type() == Item::ROW_ITEM)
    left_expr_orig= new (thd->mem_root)
      Item_row(thd, static_cast<Item_row*>(left_exp));
  func= &eq_creator;
  init(select_lex, new (thd->mem_root) select_exists_subselect(thd, this));
  max_columns= UINT_MAX;
  maybe_null= 1;
  reset();
  //if test_limit will fail then error will be reported to client
  test_limit(select_lex->master_unit());
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,239725006358723109768801436221758203934,25,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"inline bool Item_in_subselect::left_expr_has_null()
{
  return (*(optimizer->get_cache()))->null_value_inside;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,303033595216896862798853667345788608637,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_subselect::get_select_lex()
{
  return unit->first_select();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,95272022009235660750177909590925226811,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::fix_after_pullout(st_select_lex *new_parent,
                                       Item **ref, bool merge)
{
  recalc_used_tables(new_parent, TRUE);
  parent_select= new_parent;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,289942936149613565103435229989582134040,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_uniquesubquery_engine::change_result(Item_subselect *si,
                                               select_result_interceptor *res,
                                               bool temp
                                               __attribute__((unused)))
{
  DBUG_ASSERT(0);
  return TRUE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,147372119892921354718898108644141421845,8,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_indexsubquery_engine::exec()
{
  DBUG_ENTER(""subselect_indexsubquery_engine"");
  int error;
  bool null_finding= 0;
  TABLE *table= tab->table;
  Item_in_subselect *in_subs= (Item_in_subselect *) item;

  ((Item_in_subselect *) item)->value= 0;
  empty_result_set= TRUE;
  table->status= 0;

  if (check_null)
  {
    /* We need to check for NULL if there wasn't a matching value */
    *tab->ref.null_ref_key= 0;			// Search first for not null
    ((Item_in_subselect *) item)->was_null= 0;
  }

  if (!tab->preread_init_done && tab->preread_init())
    DBUG_RETURN(1);

  if (in_subs->left_expr_has_null())
  {
    /*
      The case when all values in left_expr are NULL is handled by
      Item_in_optimizer::val_int().
    */
    if (in_subs->is_top_level_item())
      DBUG_RETURN(1); /* notify caller to call reset() and set NULL value. */
    else
      DBUG_RETURN(scan_table());
  }

  if (copy_ref_key(true))
  {
    /* We know that there will be no rows even if we scan. */
    in_subs->value= 0;
    DBUG_RETURN(0);
  }

  if (!table->file->inited &&
      (error= table->file->ha_index_init(tab->ref.key, 1)))
  {
    (void) report_error(table, error);
    DBUG_RETURN(true);
  }

  error= table->file->ha_index_read_map(table->record[0],
                                        tab->ref.key_buff,
                                        make_prev_keypart_map(tab->
                                                              ref.key_parts),
                                        HA_READ_KEY_EXACT);
  if (error &&
      error != HA_ERR_KEY_NOT_FOUND && error != HA_ERR_END_OF_FILE)
    error= report_error(table, error);
  else
  {
    for (;;)
    {
      error= 0;
      table->null_row= 0;
      if (!table->status)
      {
        if ((!cond || cond->val_int()) && (!having || having->val_int()))
        {
          empty_result_set= FALSE;
          if (null_finding)
            ((Item_in_subselect *) item)->was_null= 1;
          else
            ((Item_in_subselect *) item)->value= 1;
          break;
        }
        error= table->file->ha_index_next_same(table->record[0],
                                               tab->ref.key_buff,
                                               tab->ref.key_length);
        if (error && error != HA_ERR_END_OF_FILE)
        {
          error= report_error(table, error);
          break;
        }
      }
      else
      {
        if (!check_null || null_finding)
          break;			/* We don't need to check nulls */
        *tab->ref.null_ref_key= 1;
        null_finding= 1;
        /* Check if there exists a row with a null value in the index */
        if ((error= (safe_index_read(tab) == 1)))
          break;
      }
    }
  }
  DBUG_RETURN(error != 0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,163687913474214559612363890436658621483,96,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_union_engine::no_tables()
{
  for (SELECT_LEX *sl= unit->first_select(); sl; sl= sl->next_select())
  {
    if (sl->table_list.elements)
      return FALSE;
  }
  return TRUE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,332371065322920254027750936800733766087,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_uniquesubquery_engine::no_tables()
{
  /* returning value is correct, but this method should never be called */
  DBUG_ASSERT(FALSE);
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,333758908782156670259444470510443759019,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_hash_sj_engine::change_result(Item_subselect *si,
                                             select_result_interceptor *res,
                                             bool temp __attribute__((unused)))
{
  DBUG_ASSERT(FALSE);
  return TRUE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,243435411506567056923124236632181807966,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int Ordered_key::cmp_key_with_search_key(rownum_t row_num)
{
  /* The length in bytes of the rowids (positions) of tmp_table. */
  uint rowid_length= tbl->file->ref_length;
  uchar *cur_rowid= row_num_to_rowid + row_num * rowid_length;
  int __attribute__((unused)) error;
  int cmp_res;

  if ((error= tbl->file->ha_rnd_pos(tbl->record[0], cur_rowid)))
  {
    /* purecov: begin inspected */
    tbl->file->print_error(error, MYF(ME_FATALERROR));  // Sets fatal_error
    return 0;
    /* purecov: end */
  }

  for (uint i= 0; i < key_column_count; i++)
  {
    cmp_res= compare_pred[i]->get_comparator()->compare();
    /* Unlike Arg_comparator::compare_row() here there should be no NULLs. */
    DBUG_ASSERT(!compare_pred[i]->null_value);
    if (cmp_res)
      return (cmp_res > 0 ? 1 : -1);
  }
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,170247914563959146673783456825025865186,26,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_singlerow_subselect::cleanup()
{
  DBUG_ENTER(""Item_singlerow_subselect::cleanup"");
  value= 0; row= 0;
  Item_subselect::cleanup();
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,200831993779188262349545630652287324145,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_exists_subselect::no_rows_in_result()
{
  /*
    Subquery predicates outside of the SELECT list must be evaluated in order
    to possibly filter the special result row generated for implicit grouping
    if the subquery is in the HAVING clause.
    If the predicate is constant, we need its actual value in the only result
    row for queries with implicit grouping.
  */
  if (parsing_place != SELECT_LIST || const_item())
    return;
  value= 0;
  null_value= 0;
  make_const();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,291774214872963052486911397299654704088,15,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::fix_having(Item *having, SELECT_LEX *select_lex)
{
  bool fix_res= 0;
  DBUG_ASSERT(thd);
  if (!having->fixed)
  {
    select_lex->having_fix_field= 1;
    fix_res= having->fix_fields(thd, 0);
    select_lex->having_fix_field= 0;
  }
  return fix_res;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,48642453581824535403154265816612505330,12,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::update_table_bitmaps_processor(void *arg)
{
  List_iterator<Ref_to_outside> it(upper_refs);
  Ref_to_outside *upper;

  while ((upper= it++))
  {
    if (upper->item &&
        upper->item->walk(&Item::update_table_bitmaps_processor, FALSE, arg))
      return TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,65429309058901803890267151145239679546,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_rowid_merge_engine::cleanup()
{
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,13330844251846462360001122527724691304,3,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_exists_subselect::select_transformer(JOIN *join)
{
  return select_prepare_to_be_in();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,72686531976492948762654466238636908342,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"longlong Item_singlerow_subselect::val_int()
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
  {
    longlong val= value->val_int();
    null_value= value->null_value;
    return val;
  }
  if (!exec() && !value->null_value)
  {
    null_value= FALSE;
    return value->val_int();
  }
  else
  {
    reset();
    DBUG_ASSERT(null_value);
    return 0;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,200290048366412772393106191551133764433,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"my_bitmap_init_memroot(MY_BITMAP *map, uint n_bits, MEM_ROOT *mem_root)
{
  my_bitmap_map *bitmap_buf;

  if (!(bitmap_buf= (my_bitmap_map*) alloc_root(mem_root,
                                                bitmap_buffer_size(n_bits))) ||
      my_bitmap_init(map, bitmap_buf, n_bits, FALSE))
    return TRUE;
  bitmap_clear_all(map);
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,209584432889255615010616991905050987643,11,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"double Item_exists_subselect::val_real()
{
  DBUG_ASSERT(fixed == 1);
  if (!forced_const && exec())
  {
    reset();
    return 0;
  }
  return (double) value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,307598334304839237347318535387719020061,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_in_subselect::update_used_tables()
{
  Item_subselect::update_used_tables();
  left_expr->update_used_tables();
  //used_tables_cache |= left_expr->used_tables();
  used_tables_cache= Item_subselect::used_tables() | left_expr->used_tables();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,76352531792954920114481758131042174605,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_uniquesubquery_engine::prepare(THD *)
{
  /* Should never be called. */
  DBUG_ASSERT(FALSE);
  return 1;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,273484651220635632724557256865508599413,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_partial_match_engine::subselect_partial_match_engine(
  subselect_uniquesubquery_engine *engine_arg,
  TABLE *tmp_table_arg, Item_subselect *item_arg,
  select_result_interceptor *result_arg,
  List<Item> *equi_join_conds_arg,
  bool has_covering_null_row_arg,
  bool has_covering_null_columns_arg,
  uint count_columns_with_nulls_arg)
  :subselect_engine(item_arg, result_arg),
   tmp_table(tmp_table_arg), lookup_engine(engine_arg),
   equi_join_conds(equi_join_conds_arg),
   has_covering_null_row(has_covering_null_row_arg),
   has_covering_null_columns(has_covering_null_columns_arg),
   count_columns_with_nulls(count_columns_with_nulls_arg)
{}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,243566459037525830845407769384061390016,15,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int walk_items_for_table_list(Item_processor processor,
                              bool walk_subquery, void *argument,
                              List<TABLE_LIST>& join_list)
{
  List_iterator<TABLE_LIST> li(join_list);
  int res;
  while (TABLE_LIST *table= li++)
  {
    if (table->on_expr)
    {
      if ((res= table->on_expr->walk(processor, walk_subquery, argument)))
        return res;
    }
    if (table->nested_join)
    {
      if ((res= walk_items_for_table_list(processor, walk_subquery, argument,
                                          table->nested_join->join_list)))
        return res;
    }
  }
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,59988884002863578607579625206190535032,22,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::mark_as_dependent(THD *thd, st_select_lex *select, 
                                       Item *item)
{
  if (inside_first_fix_fields)
  {
    is_correlated= TRUE;
    Ref_to_outside *upper;
    if (!(upper= new (thd->stmt_arena->mem_root) Ref_to_outside()))
      return TRUE;
    upper->select= select;
    upper->item= item;
    if (upper_refs.push_back(upper, thd->stmt_arena->mem_root))
      return TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,301475463517349830514901069077759013480,16,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Ordered_key::print(String *str)
{
  uint i;
  str->append(""{idx="");
  str->qs_append(keyid);
  str->append("", ("");
  for (i= 0; i < key_column_count - 1; i++)
  {
    str->append(key_columns[i]->field->field_name);
    str->append("", "");
  }
  str->append(key_columns[i]->field->field_name);
  str->append(""), "");

  str->append(""null_bitmap: (bits="");
  str->qs_append(null_key.n_bits);
  str->append("", nulls= "");
  str->qs_append((double)null_count);
  str->append("", min_null= "");
  str->qs_append((double)min_null_row);
  str->append("", max_null= "");
  str->qs_append((double)max_null_row);
  str->append(""), "");

  str->append('}');
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,139236679657896524468871099307394160453,26,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_table_scan_engine::partial_match()
{
  List_iterator_fast<Item> equality_it(*equi_join_conds);
  Item *cur_eq;
  uint count_matches;
  int error;
  bool res;

  if (tmp_table->file->ha_rnd_init_with_error(1))
  {
    res= FALSE;
    goto end;
  }

  tmp_table->file->extra_opt(HA_EXTRA_CACHE,
                             get_thd()->variables.read_buff_size);
  for (;;)
  {
    error= tmp_table->file->ha_rnd_next(tmp_table->record[0]);
    if (error) {
      if (error == HA_ERR_RECORD_DELETED)
      {
        error= 0;
        continue;
      }
      if (error == HA_ERR_END_OF_FILE)
      {
        error= 0;
        break;
      }
      else
      {
        error= report_error(tmp_table, error);
        break;
      }
    }

    equality_it.rewind();
    count_matches= 0;
    while ((cur_eq= equality_it++))
    {
      DBUG_ASSERT(cur_eq->type() == Item::FUNC_ITEM &&
                  ((Item_func*)cur_eq)->functype() == Item_func::EQ_FUNC);
      if (!cur_eq->val_int() && !cur_eq->null_value)
        break;
      ++count_matches;
    }
    if (count_matches == tmp_table->s->fields)
    {
      res= TRUE; /* Found a matching row. */
      goto end;
    }
  }

  res= FALSE;
end:
  tmp_table->file->ha_rnd_end();
  return res;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,329447916927229094264626441553863727051,59,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"uint8 subselect_single_select_engine::uncacheable()
{
  return select_lex->uncacheable;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,173032464561170269472131284053587794853,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"uint subselect_single_select_engine::cols()
{
  //psergey-sj-backport: the following assert was gone in 6.0:
  //DBUG_ASSERT(select_lex->join != 0); // should be called after fix_fields()
  //return select_lex->join->fields_list.elements;
  return select_lex->item_list.elements;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,6095458234124387158891599727257152657,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"double Ordered_key::null_selectivity()
{
  /* We should not be processing empty tables. */
  DBUG_ASSERT(tbl->file->stats.records);
  return (1 - (double) null_count / (double) tbl->file->stats.records);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,211834797162253847078668107668077020304,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_exists_subselect::fix_length_and_dec()
{
  DBUG_ENTER(""Item_exists_subselect::fix_length_and_dec"");
  init_length_and_dec();
  // If limit is not set or it is constant more than 1
  if (!unit->global_parameters()->select_limit ||
      (unit->global_parameters()->select_limit->basic_const_item() &&
       unit->global_parameters()->select_limit->val_int() > 1))
  {
    /*
       We need only 1 row to determine existence (i.e. any EXISTS that is not
       an IN always requires LIMIT 1)
     */
    Item *item= new (thd->mem_root) Item_int(thd, (int32) 1);
    if (!item)
      DBUG_RETURN(TRUE);
    thd->change_item_tree(&unit->global_parameters()->select_limit,
                          item);
    unit->global_parameters()->explicit_limit= 1; // we set the limit
    DBUG_PRINT(""info"", (""Set limit to 1""));
  }
  DBUG_RETURN(FALSE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,209794353442105115114184416382813599790,23,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_exists_subselect::exists2in_processor(void *opt_arg)
{
  THD *thd= (THD *)opt_arg;
  SELECT_LEX *first_select=unit->first_select(), *save_select;
  JOIN *join= first_select->join;
  Item **eq_ref= NULL;
  Item_ident *local_field= NULL;
  Item *outer_exp= NULL;
  Item *left_exp= NULL; Item_in_subselect *in_subs;
  Query_arena *arena= NULL, backup;
  int res= FALSE;
  List<Item> outer;
  Dynamic_array<EQ_FIELD_OUTER> eqs(5, 5);
  bool will_be_correlated;
  DBUG_ENTER(""Item_exists_subselect::exists2in_processor"");

  if (!optimizer ||
      !optimizer_flag(thd, OPTIMIZER_SWITCH_EXISTS_TO_IN) ||
      (!is_top_level_item() && (!upper_not ||
                                !upper_not->is_top_level_item())) ||
      first_select->is_part_of_union() ||
      first_select->group_list.elements ||
      first_select->order_list.elements ||
      join->having ||
      first_select->with_sum_func ||
      !first_select->leaf_tables.elements||
      !join->conds ||
      with_recursive_reference)
    DBUG_RETURN(FALSE);

  DBUG_ASSERT(first_select->order_list.elements == 0 &&
              first_select->group_list.elements == 0 &&
              first_select->having == NULL);

  if (find_inner_outer_equalities(&join->conds, eqs))
    DBUG_RETURN(FALSE);

  DBUG_ASSERT(eqs.elements() != 0);

  save_select= thd->lex->current_select;
  thd->lex->current_select= first_select;

  /* check that the subquery has only dependencies we are going pull out */
  {
    List<Item> unused;
    Collect_deps_prm prm= {&unused,          // parameters
      unit->first_select()->nest_level_base, // nest_level_base
      0,                                     // count
      unit->first_select()->nest_level,      // nest_level
      FALSE                                  // collect
    };
    walk(&Item::collect_outer_ref_processor, TRUE, &prm);
    DBUG_ASSERT(prm.count > 0);
    DBUG_ASSERT(prm.count >= (uint)eqs.elements());
    will_be_correlated= prm.count > (uint)eqs.elements();
    if (upper_not && will_be_correlated)
      goto out;
  }

  if ((uint)eqs.elements() > (first_select->item_list.elements +
                              first_select->select_n_reserved))
    goto out;
  /* It is simple query */
  DBUG_ASSERT(first_select->join->all_fields.elements ==
              first_select->item_list.elements);

  arena= thd->activate_stmt_arena_if_needed(&backup);

  while (first_select->item_list.elements > (uint)eqs.elements())
  {
    first_select->item_list.pop();
    first_select->join->all_fields.elements--;
  }
  {
    List_iterator<Item> it(first_select->item_list);

    for (uint i= 0; i < (uint)eqs.elements(); i++)
    {
      Item *item= it++;
      eq_ref= eqs.at(i).eq_ref;
      local_field= eqs.at(i).local_field;
      outer_exp= eqs.at(i).outer_exp;
      /* Add the field to the SELECT_LIST */
      if (item)
        it.replace(local_field);
      else
      {
        first_select->item_list.push_back(local_field, thd->mem_root);
        first_select->join->all_fields.elements++;
      }
      first_select->ref_pointer_array[i]= (Item *)local_field;

      /* remove the parts from condition */
      if (!upper_not || !local_field->maybe_null)
        *eq_ref= new (thd->mem_root) Item_int(thd, 1);
      else
      {
        *eq_ref= new (thd->mem_root)
          Item_func_isnotnull(thd,
                              new (thd->mem_root)
                              Item_field(thd,
                                         ((Item_field*)(local_field->
                                                        real_item()))->context,
                                         ((Item_field*)(local_field->
                                                        real_item()))->field));
        if((*eq_ref)->fix_fields(thd, (Item **)eq_ref))
        {
          res= TRUE;
          goto out;
        }
      }
      outer_exp->fix_after_pullout(unit->outer_select(), &outer_exp, FALSE);
      outer_exp->update_used_tables();
      outer.push_back(outer_exp, thd->mem_root);
    }
  }

  join->conds->update_used_tables();

  /* make IN SUBQUERY and put outer_exp as left part */
  if (eqs.elements() == 1)
    left_exp= outer_exp;
  else
  {
    if (!(left_exp= new (thd->mem_root) Item_row(thd, outer)))
    {
      res= TRUE;
      goto out;
    }
  }

  /* make EXISTS->IN permanet (see Item_subselect::init()) */
  set_exists_transformed();

  first_select->select_limit= NULL;
  if (!(in_subs= new (thd->mem_root) Item_in_subselect(thd, left_exp,
                                                         first_select)))
  {
    res= TRUE;
    goto out;
  }
  in_subs->set_exists_transformed();
  optimizer->arguments()[0]= left_exp;
  optimizer->arguments()[1]= in_subs;
  in_subs->optimizer= optimizer;
  DBUG_ASSERT(is_top_level_item() ||
              (upper_not && upper_not->is_top_level_item()));
  in_subs->top_level_item();
  {
    SELECT_LEX *current= thd->lex->current_select;
    optimizer->reset_cache(); // renew cache, and we will not keep it
    thd->lex->current_select= unit->outer_select();
    DBUG_ASSERT(optimizer);
    if (optimizer->fix_left(thd))
    {
      res= TRUE;
      /*
        We should not restore thd->lex->current_select because it will be
        reset on exit from this procedure
      */
      goto out;
    }
    /*
      As far as  Item_ref_in_optimizer do not substitute itself on fix_fields
      we can use same item for all selects.
    */
    in_subs->expr= new (thd->mem_root)
      Item_direct_ref(thd, &first_select->context,
                      (Item**)optimizer->get_cache(),
                      (char *)""<no matter>"",
                      (char *)in_left_expr_name);
    if (in_subs->fix_fields(thd, optimizer->arguments() + 1))
    {
      res= TRUE;
      /*
        We should not restore thd->lex->current_select because it will be
        reset on exit from this procedure
      */
      goto out;
    }
    {
      /* Move dependence list */
      List_iterator_fast<Ref_to_outside> it(upper_refs);
      Ref_to_outside *upper;
      while ((upper= it++))
      {
        uint i;
        for (i= 0; i < (uint)eqs.elements(); i++)
          if (eqs.at(i).outer_exp->
              walk(&Item::find_item_processor, TRUE, upper->item))
            break;
        if (i == (uint)eqs.elements() &&
            (in_subs->upper_refs.push_back(upper, thd->stmt_arena->mem_root)))
          goto out;
      }
    }
    in_subs->update_used_tables();
    /*
      The engine of the subquery is fixed so above fix_fields() is not
      complete and should be fixed
    */
    in_subs->upper_refs= upper_refs;
    upper_refs.empty();
    thd->lex->current_select= current;
  }

  DBUG_ASSERT(unit->item == in_subs);
  DBUG_ASSERT(join == first_select->join);
  /*
    Fix dependency info
  */
  in_subs->is_correlated= will_be_correlated;
  if (!will_be_correlated)
  {
    first_select->uncacheable&= ~UNCACHEABLE_DEPENDENT_GENERATED;
    unit->uncacheable&= ~UNCACHEABLE_DEPENDENT_GENERATED;
  }
  /*
    set possible optimization strategies
  */
  in_subs->emb_on_expr_nest= emb_on_expr_nest;
  res= check_and_do_in_subquery_rewrites(join);
  first_select->join->prepare_stage2();

  first_select->fix_prepare_information(thd, &join->conds, &join->having);

  if (upper_not)
  {
    Item *exp;
    if (eqs.elements() == 1)
    {
      exp= (optimizer->arguments()[0]->maybe_null ?
            (Item*) new (thd->mem_root)
            Item_cond_and(thd,
                          new (thd->mem_root)
                          Item_func_isnotnull(thd,
                                              new (thd->mem_root)
                                              Item_direct_ref(thd,
                                                              &unit->outer_select()->context,
                                                              optimizer->arguments(),
                                                              (char *)""<no matter>"",
                                                              (char *)exists_outer_expr_name)),
                          optimizer) :
            (Item *)optimizer);
    }
    else
    {
      List<Item> *and_list= new List<Item>;
      if (!and_list)
      {
        res= TRUE;
        goto out;
      }
      for (size_t i= 0; i < eqs.elements(); i++)
      {
        if (optimizer->arguments()[0]->maybe_null)
        {
          and_list->
            push_front(new (thd->mem_root)
                       Item_func_isnotnull(thd,
                                           new (thd->mem_root)
                                           Item_direct_ref(thd,
                                                           &unit->outer_select()->context,
                                                           optimizer->arguments()[0]->addr(i),
                                                           (char *)""<no matter>"",
                                                           (char *)exists_outer_expr_name)),
                       thd->mem_root);
        }
      }
      if (and_list->elements > 0)
      {
        and_list->push_front(optimizer, thd->mem_root);
        exp= new (thd->mem_root) Item_cond_and(thd, *and_list);
      }
      else
        exp= optimizer;
    }
    upper_not->arguments()[0]= exp;
    if (!exp->fixed && exp->fix_fields(thd, upper_not->arguments()))
    {
      res= TRUE;
      goto out;
    }
  }

out:
  thd->lex->current_select= save_select;
  if (arena)
    thd->restore_active_arena(arena, &backup);
  DBUG_RETURN(res);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,100745487697887904376695558059983573377,291,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Ordered_key::cmp_keys_by_row_data(ha_rows a, ha_rows b)
{
  uchar *rowid_a, *rowid_b;
  int __attribute__((unused)) error;
  int cmp_res;
  /* The length in bytes of the rowids (positions) of tmp_table. */
  uint rowid_length= tbl->file->ref_length;

  if (a == b)
    return 0;
  /* Get the corresponding rowids. */
  rowid_a= row_num_to_rowid + a * rowid_length;
  rowid_b= row_num_to_rowid + b * rowid_length;
  /* Fetch the rows for comparison. */
  if ((error= tbl->file->ha_rnd_pos(tbl->record[0], rowid_a)))
  {
    /* purecov: begin inspected */
    tbl->file->print_error(error, MYF(ME_FATALERROR));  // Sets fatal_error
    return 0;
    /* purecov: end */
  }
  if ((error= tbl->file->ha_rnd_pos(tbl->record[1], rowid_b)))
  {
    /* purecov: begin inspected */
    tbl->file->print_error(error, MYF(ME_FATALERROR));  // Sets fatal_error
    return 0;
    /* purecov: end */
  }    
  /*
    Compare the two rows by the corresponding values of the indexed
    columns.
  */
  for (uint i= 0; i < key_column_count; i++)
  {
    Field *cur_field= key_columns[i]->field;
    if ((cmp_res= cur_field->cmp_offset(tbl->s->rec_buff_length)))
      return (cmp_res > 0 ? 1 : -1);
  }
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,21633811174572395019042337290941898904,40,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_uniquesubquery_engine::index_lookup()
{
  DBUG_ENTER(""subselect_uniquesubquery_engine::index_lookup"");
  int error;
  TABLE *table= tab->table;
 
  if (!table->file->inited)
    table->file->ha_index_init(tab->ref.key, 0);
  error= table->file->ha_index_read_map(table->record[0],
                                        tab->ref.key_buff,
                                        make_prev_keypart_map(tab->
                                                              ref.key_parts),
                                        HA_READ_KEY_EXACT);
  DBUG_PRINT(""info"", (""lookup result: %i"", error));

  if (error && error != HA_ERR_KEY_NOT_FOUND && error != HA_ERR_END_OF_FILE)
  {
    /*
      TIMOUR: I don't understand at all when do we need to call report_error.
      In most places where we access an index, we don't do this. Why here?
    */
    error= report_error(table, error);
    DBUG_RETURN(error);
  }

  table->null_row= 0;
  if (!error && (!cond || cond->val_int()))
    ((Item_in_subselect *) item)->value= 1;
  else
    ((Item_in_subselect *) item)->value= 0;

  DBUG_RETURN(0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,209183160042314501010365315762074709127,33,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_exists_subselect::init_length_and_dec()
{
  decimals= 0;
  max_length= 1;
  max_columns= engine->cols();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,161020478267802846688935454326206095995,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"table_map subselect_union_engine::upper_select_const_tables()
{
  return calc_const_tables(unit->outer_select()->leaf_tables);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,12164275322417906530605401682293456491,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_uniquesubquery_engine::fix_length_and_dec(Item_cache **row)
{
  //this never should be called
  DBUG_ASSERT(0);
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,227062981034483993014176370224748018011,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::enumerate_field_refs_processor(void *arg)
{
  List_iterator<Ref_to_outside> it(upper_refs);
  Ref_to_outside *upper;
  
  while ((upper= it++))
  {
    if (upper->item &&
        upper->item->walk(&Item::enumerate_field_refs_processor, FALSE, arg))
      return TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,259347428851039551485293731887508949489,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_exists_subselect::Item_exists_subselect(THD *thd,
                                             st_select_lex *select_lex):
  Item_subselect(thd), upper_not(NULL), abort_on_null(0),
  emb_on_expr_nest(NULL), optimizer(0), exists_transformed(0)
{
  DBUG_ENTER(""Item_exists_subselect::Item_exists_subselect"");
  init(select_lex, new (thd->mem_root) select_exists_subselect(thd, this));
  max_columns= UINT_MAX;
  null_value= FALSE; //can't be NULL
  maybe_null= 0; //can't be NULL
  value= 0;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,5465225004620863212941776949970703287,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_allany_subselect::Item_allany_subselect(THD *thd, Item * left_exp,
                                             chooser_compare_func_creator fc,
					     st_select_lex *select_lex,
					     bool all_arg):
  Item_in_subselect(thd), func_creator(fc), all(all_arg)
{
  DBUG_ENTER(""Item_allany_subselect::Item_allany_subselect"");
  left_expr_orig= left_expr= left_exp;
  /* prepare to possible disassembling the item in convert_subq_to_sj() */
  if (left_exp->type() == Item::ROW_ITEM)
    left_expr_orig= new (thd->mem_root)
      Item_row(thd, static_cast<Item_row*>(left_exp));
  func= func_creator(all_arg);
  init(select_lex, new (thd->mem_root) select_exists_subselect(thd, this));
  max_columns= 1;
  abort_on_null= 0;
  reset();
  //if test_limit will fail then error will be reported to client
  test_limit(select_lex->master_unit());
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,19382311021943845011059965358124080901,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_uniquesubquery_engine::cleanup()
{
  DBUG_ENTER(""subselect_uniquesubquery_engine::cleanup"");
  /* 
    Note for mergers: we don't have to, and actually must not de-initialize
    tab->table->file here.
    - We don't have to, because free_tmp_table() will call ha_index_or_rnd_end
    - We must not do it, because tab->table may be a derived table which 
      has been already dropped by close_thread_tables(), while we here are
      called from cleanup_items()
  */
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,20938659874400259219678594873893827858,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_maxmin_subselect::print(String *str, enum_query_type query_type)
{
  str->append(max?""<max>"":""<min>"", 5);
  Item_singlerow_subselect::print(str, query_type);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,93747289166750650811233958641117951962,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_in_subselect::print(String *str, enum_query_type query_type)
{
  if (test_strategy(SUBS_IN_TO_EXISTS))
    str->append(STRING_WITH_LEN(""<exists>""));
  else
  {
    left_expr->print_parenthesised(str, query_type, precedence());
    str->append(STRING_WITH_LEN("" in ""));
  }
  Item_subselect::print(str, query_type);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,272402565869955221158011307250242804973,11,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_hash_sj_engine::no_tables()
{
  DBUG_ASSERT(FALSE);
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,191483070490094361550594652662724811913,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::get_cache_parameters(List<Item> &parameters)
{
  Collect_deps_prm prm= {&parameters,      // parameters
    unit->first_select()->nest_level_base, // nest_level_base
    0,                                     // count
    unit->first_select()->nest_level,      // nest_level
    TRUE                                   // collect
  };
  walk(&Item::collect_outer_ref_processor, TRUE, &prm);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,141692558835170147668932433475315145669,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"uint subselect_union_engine::cols()
{
  DBUG_ASSERT(unit->is_prepared());  // should be called after fix_fields()
  return unit->types.elements;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,2925694776851368479023969343667887334,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::create_in_to_exists_cond(JOIN *join_arg)
{
  bool res;

  DBUG_ASSERT(engine->engine_type() == subselect_engine::SINGLE_SELECT_ENGINE ||
              engine->engine_type() == subselect_engine::UNION_ENGINE);
  /*
    TODO: the call to init_cond_guards allocates and initializes an
    array of booleans that may not be used later because we may choose
    materialization.
    The two calls below to create_XYZ_cond depend on this boolean array.
    If the dependency is removed, the call can be moved to a later phase.
  */
  init_cond_guards();
  if (left_expr->cols() == 1)
    res= create_single_in_to_exists_cond(join_arg,
                                         &(join_arg->in_to_exists_where),
                                         &(join_arg->in_to_exists_having));
  else
    res= create_row_in_to_exists_cond(join_arg,
                                      &(join_arg->in_to_exists_where),
                                      &(join_arg->in_to_exists_having));

  /*
    The IN=>EXISTS transformation makes non-correlated subqueries correlated.
  */
  if (!left_expr->const_item() || left_expr->is_expensive())
  {
    join_arg->select_lex->uncacheable|= UNCACHEABLE_DEPENDENT_INJECTED;
    join_arg->select_lex->master_unit()->uncacheable|= 
                                         UNCACHEABLE_DEPENDENT_INJECTED;
  }
  /*
    The uncacheable property controls a number of actions, e.g. whether to
    save/restore (via init_save_join_tab/restore_tmp) the original JOIN for
    plans with a temp table where the original JOIN was overridden by
    make_simple_join. The UNCACHEABLE_EXPLAIN is ignored by EXPLAIN, thus
    non-correlated subqueries will not appear as such to EXPLAIN.
  */
  join_arg->select_lex->master_unit()->uncacheable|= UNCACHEABLE_EXPLAIN;
  join_arg->select_lex->uncacheable|= UNCACHEABLE_EXPLAIN;
  return (res);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,225509350036520768497348590476565979395,43,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_exists_subselect::select_prepare_to_be_in()
{
  bool trans_res= FALSE;
  DBUG_ENTER(""Item_exists_subselect::select_prepare_to_be_in"");
  if (!optimizer &&
      thd->lex->sql_command == SQLCOM_SELECT &&
      !unit->first_select()->is_part_of_union() &&
      optimizer_flag(thd, OPTIMIZER_SWITCH_EXISTS_TO_IN) &&
      (is_top_level_item() ||
       (upper_not && upper_not->is_top_level_item())))
  {
    Query_arena *arena, backup;
    bool result;
    arena= thd->activate_stmt_arena_if_needed(&backup);
    result= (!(optimizer= new (thd->mem_root) Item_in_optimizer(thd, new (thd->mem_root) Item_int(thd, 1), this)));
    if (arena)
      thd->restore_active_arena(arena, &backup);
    if (result)
      trans_res= TRUE;
    else
      substitution= optimizer;
  }
  DBUG_RETURN(trans_res);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,29492605747545531931650029023284089271,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_singlerow_subselect::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)
{
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
  {
    bool val= value->get_date(ltime, fuzzydate);
    null_value= value->null_value;
    return val;
  }
  if (!exec() && !value->null_value)
  {
    null_value= FALSE;
    return value->get_date(ltime, fuzzydate);
  }
  else
  {
    reset();
    DBUG_ASSERT(null_value);
    return 1;
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,296567272436246977037001068829156412321,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_uniquesubquery_engine::copy_ref_key(bool skip_constants)
{
  DBUG_ENTER(""subselect_uniquesubquery_engine::copy_ref_key"");

  for (store_key **copy= tab->ref.key_copy ; *copy ; copy++)
  {
    enum store_key::store_key_result store_res;
    if (skip_constants && (*copy)->store_key_is_const())
      continue;
    store_res= (*copy)->copy();
    tab->ref.key_err= store_res;

    if (store_res == store_key::STORE_KEY_FATAL)
    {
      /*
       Error converting the left IN operand to the column type of the right
       IN operand. 
      */
      DBUG_RETURN(true);
    }
  }
  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,289989098854389318173954462256950934024,23,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_union_engine::no_rows()
{
  /* Check if we got any rows when reading UNION result from temp. table: */
  if (unit->fake_select_lex)
  {
    JOIN *join= unit->fake_select_lex->join;
    if (join)
      return MY_TEST(!join->send_records);
    return false;
  }
  return MY_TEST(!(((select_union_direct *)(unit->get_union_result()))
                                                            ->send_records));
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,110802133892585735473058336011524663387,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::test_limit(st_select_lex_unit *unit_arg)
{
  if (unit_arg->fake_select_lex &&
      unit_arg->fake_select_lex->test_limit())
    return(1);

  SELECT_LEX *sl= unit_arg->first_select();
  for (; sl; sl= sl->next_select())
  {
    if (sl->test_limit())
      return(1);
  }
  return(0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,146367907676467436724982215574896547716,14,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::recalc_used_tables(st_select_lex *new_parent, 
                                        bool after_pullout)
{
  List_iterator_fast<Ref_to_outside> it(upper_refs);
  Ref_to_outside *upper;
  DBUG_ENTER(""recalc_used_tables"");
  
  used_tables_cache= 0;
  while ((upper= it++))
  {
    bool found= FALSE;
    /*
      Check if
        1. the upper reference refers to the new immediate parent select, or
        2. one of the further ancestors.

      We rely on the fact that the tree of selects is modified by some kind of
      'flattening', i.e. a process where child selects are merged into their
      parents.
      The merged selects are removed from the select tree but keep pointers to
      their parents.
    */
    for (st_select_lex *sel= upper->select; sel; sel= sel->outer_select())
    {
      /* 
        If we've reached the new parent select by walking upwards from
        reference's original select, this means that the reference is now 
        referring to the direct parent:
      */
      if (sel == new_parent)
      {
        found= TRUE;
        /* 
          upper->item may be NULL when we've referred to a grouping function,
          in which case we don't care about what it's table_map really is,
          because item->with_sum_func==1 will ensure correct placement of the
          item.
        */
        if (upper->item)
        {
          // Now, iterate over fields and collect used_tables() attribute:
          Field_fixer fixer;
          fixer.used_tables= 0;
          fixer.new_parent= new_parent;
          upper->item->walk(&Item::enumerate_field_refs_processor, 0, &fixer);
          used_tables_cache |= fixer.used_tables;
          upper->item->walk(&Item::update_table_bitmaps_processor, FALSE, NULL);
/*
          if (after_pullout)
            upper->item->fix_after_pullout(new_parent, &(upper->item));
          upper->item->update_used_tables();
*/          
        }
      }
    }
    if (!found)
      used_tables_cache|= OUTER_REF_TABLE_BIT;
  }
  /* 
    Don't update const_tables_cache yet as we don't yet know which of the
    parent's tables are constant. Parent will call update_used_tables() after
    he has done const table detection, and that will be our chance to update
    const_tables_cache.
  */
  DBUG_PRINT(""exit"", (""used_tables_cache: %llx"", used_tables_cache));
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,188326115303674048717655802506805720340,67,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_in_subselect::fix_after_pullout(st_select_lex *new_parent,
                                          Item **ref, bool merge)
{
  left_expr->fix_after_pullout(new_parent, &left_expr, merge);
  Item_subselect::fix_after_pullout(new_parent, ref, merge);
  used_tables_cache |= left_expr->used_tables();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,304465782831379744565802181098976208181,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_union_engine::is_executed() const
{
  return unit->executed;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,195828778940736944006921906769222620794,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::init_left_expr_cache()
{
  JOIN *outer_join;
  DBUG_ASSERT(thd);

  outer_join= unit->outer_select()->join;
  /*
    An IN predicate might be evaluated in a query for which all tables have
    been optimzied away.
  */ 
  if (!outer_join || !outer_join->table_count || !outer_join->tables_list)
    return TRUE;

  if (!(left_expr_cache= new List<Cached_item>))
    return TRUE;

  for (uint i= 0; i < left_expr->cols(); i++)
  {
    Cached_item *cur_item_cache= new_Cached_item(thd,
                                                 left_expr->element_index(i),
                                                 FALSE);
    if (!cur_item_cache || left_expr_cache->push_front(cur_item_cache,
                                                       thd->mem_root))
      return TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,150623557351329860731925526423611043619,27,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_maxmin_subselect::Item_maxmin_subselect(THD *thd,
                                             Item_subselect *parent,
					     st_select_lex *select_lex,
					     bool max_arg):
  Item_singlerow_subselect(thd), was_values(TRUE)
{
  DBUG_ENTER(""Item_maxmin_subselect::Item_maxmin_subselect"");
  max= max_arg;
  init(select_lex,
       new (thd->mem_root) select_max_min_finder_subselect(thd,
             this, max_arg, parent->substype() == Item_subselect::ALL_SUBS));
  max_columns= 1;
  maybe_null= 1;
  max_columns= 1;

  /*
    Following information was collected during performing fix_fields()
    of Items belonged to subquery, which will be not repeated
  */
  used_tables_cache= parent->get_used_tables_cache();
  const_item_cache= parent->const_item();

  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,121028995299807647597128039969606233136,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_maxmin_subselect::cleanup()
{
  DBUG_ENTER(""Item_maxmin_subselect::cleanup"");
  Item_singlerow_subselect::cleanup();

  /*
    By default it is TRUE to avoid TRUE reporting by
    Item_func_not_all/Item_func_nop_all if this item was never called.

    Engine exec() set it to FALSE by reset_value_registration() call.
    select_max_min_finder_subselect::send_data() set it back to TRUE if some
    value will be found.
  */
  was_values= TRUE;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,150226377378358952447837749926754548115,16,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_table_scan_engine::subselect_table_scan_engine(
  subselect_uniquesubquery_engine *engine_arg,
  TABLE *tmp_table_arg,
  Item_subselect *item_arg,
  select_result_interceptor *result_arg,
  List<Item> *equi_join_conds_arg,
  bool has_covering_null_row_arg,
  bool has_covering_null_columns_arg,
  uint count_columns_with_nulls_arg)
  :subselect_partial_match_engine(engine_arg, tmp_table_arg, item_arg,
                                  result_arg, equi_join_conds_arg,
                                  has_covering_null_row_arg,
                                  has_covering_null_columns_arg,
                                  count_columns_with_nulls_arg)
{}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,75689717151150024020184268437961269399,15,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"enum Item_result Item_singlerow_subselect::result_type() const
{
  return engine->type();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,205125533389414346464705829921898348487,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_singlerow_subselect::reset()
{
  Item_subselect::reset();
  if (value)
  {
    for(uint i= 0; i < engine->cols(); i++)
      row[i]->set_null();
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,270599540168321967797571643638444500491,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"longlong Item_exists_subselect::val_int()
{
  DBUG_ASSERT(fixed == 1);
  if (!forced_const && exec())
  {
    reset();
    return 0;
  }
  return value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,282631791728903183005023765670193477863,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_rowid_merge_engine::cmp_keys_by_null_selectivity(Ordered_key **k1,
                                                           Ordered_key **k2)
{
  double k1_sel= (*k1)->null_selectivity();
  double k2_sel= (*k2)->null_selectivity();
  if (k1_sel < k2_sel)
    return 1;
  if (k1_sel > k2_sel)
    return -1;
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,195904975012172960683448423934518324458,11,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_union_engine::cleanup()
{
  DBUG_ENTER(""subselect_union_engine::cleanup"");
  unit->reinit_exec_mechanism();
  result->cleanup();
  unit->uncacheable&= ~UNCACHEABLE_DEPENDENT_INJECTED;
  for (SELECT_LEX *sl= unit->first_select(); sl; sl= sl->next_select())
    sl->uncacheable&= ~UNCACHEABLE_DEPENDENT_INJECTED;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,167589639238747058706468361036196775886,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_hash_sj_engine::~subselect_hash_sj_engine()
{
  delete lookup_engine;
  delete result;
  if (tmp_table)
    free_tmp_table(thd, tmp_table);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,176961810202080535122330842102609439227,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::create_row_in_to_exists_cond(JOIN * join,
                                                Item **where_item,
                                                Item **having_item)
{
  SELECT_LEX *select_lex= join->select_lex;
  uint cols_num= left_expr->cols();
  /*
    The non-transformed HAVING clause of 'join' may be stored in two ways
    during JOIN::optimize: this->tmp_having= this->having; this->having= 0;
  */
  Item* join_having= join->having ? join->having : join->tmp_having;
  bool is_having_used= (join_having || select_lex->with_sum_func ||
                        select_lex->group_list.first ||
                        !select_lex->table_list.elements);

  DBUG_ENTER(""Item_in_subselect::create_row_in_to_exists_cond"");
  DBUG_ASSERT(thd == join->thd);

  *where_item= NULL;
  *having_item= NULL;

  if (is_having_used)
  {
    /* TODO: say here explicitly if the order of AND parts matters or not. */
    Item *item_having_part2= 0;
    for (uint i= 0; i < cols_num; i++)
    {
      DBUG_ASSERT((left_expr->fixed &&

                  select_lex->ref_pointer_array[i]->fixed) ||
                  (select_lex->ref_pointer_array[i]->type() == REF_ITEM &&
                   ((Item_ref*)(select_lex->ref_pointer_array[i]))->ref_type() ==
                    Item_ref::OUTER_REF));
      if (select_lex->ref_pointer_array[i]->
          check_cols(left_expr->element_index(i)->cols()))
        DBUG_RETURN(true);
      Item *item_eq=
        new (thd->mem_root)
        Item_func_eq(thd, new (thd->mem_root)
                     Item_direct_ref(thd, &select_lex->context,
                                     (*optimizer->get_cache())->
                                     addr(i),
                                     (char *)""<no matter>"",
                                     (char *)in_left_expr_name),
                     new (thd->mem_root)
                     Item_ref(thd, &select_lex->context,
                              &select_lex->ref_pointer_array[i],
                              (char *)""<no matter>"",
                              (char *)""<list ref>""));
      Item *item_isnull=
        new (thd->mem_root)
        Item_func_isnull(thd,
                         new (thd->mem_root)
                         Item_ref(thd, &select_lex->context,
                                  &select_lex->ref_pointer_array[i],
                                  (char *)""<no matter>"",
                                  (char *)""<list ref>""));
      Item *col_item= new (thd->mem_root)
        Item_cond_or(thd, item_eq, item_isnull);
      if (!abort_on_null && left_expr->element_index(i)->maybe_null &&
          get_cond_guard(i))
      {
        disable_cond_guard_for_const_null_left_expr(i);
        if (!(col_item= new (thd->mem_root)
              Item_func_trig_cond(thd, col_item, get_cond_guard(i))))
          DBUG_RETURN(true);
      }
      *having_item= and_items(thd, *having_item, col_item);

      Item *item_nnull_test= 
         new (thd->mem_root)
        Item_is_not_null_test(thd, this,
                              new (thd->mem_root)
                              Item_ref(thd, &select_lex->context,
                                       &select_lex->
                                       ref_pointer_array[i],
                                       (char *)""<no matter>"",
                                       (char *)""<list ref>""));
      if (!abort_on_null && left_expr->element_index(i)->maybe_null &&
          get_cond_guard(i) )
      {
        disable_cond_guard_for_const_null_left_expr(i);
        if (!(item_nnull_test= 
              new (thd->mem_root)
              Item_func_trig_cond(thd, item_nnull_test, get_cond_guard(i))))
          DBUG_RETURN(true);
      }
      item_having_part2= and_items(thd, item_having_part2, item_nnull_test);
      item_having_part2->top_level_item();
    }
    *having_item= and_items(thd, *having_item, item_having_part2);
  }
  else
  {
    for (uint i= 0; i < cols_num; i++)
    {
      Item *item, *item_isnull;
      DBUG_ASSERT((left_expr->fixed &&
                  select_lex->ref_pointer_array[i]->fixed) ||
                  (select_lex->ref_pointer_array[i]->type() == REF_ITEM &&
                   ((Item_ref*)(select_lex->ref_pointer_array[i]))->ref_type() ==
                    Item_ref::OUTER_REF));
      if (select_lex->ref_pointer_array[i]->
          check_cols(left_expr->element_index(i)->cols()))
        DBUG_RETURN(true);
      item= new (thd->mem_root)
        Item_func_eq(thd,
                     new (thd->mem_root)
                     Item_direct_ref(thd, &select_lex->context,
                                     (*optimizer->get_cache())->
                                     addr(i),
                                     (char *)""<no matter>"",
                                     (char *)in_left_expr_name),
                     new (thd->mem_root)
                     Item_direct_ref(thd, &select_lex->context,
                                     &select_lex->
                                     ref_pointer_array[i],
                                     (char *)""<no matter>"",
                                     (char *)""<list ref>""));
      if (!abort_on_null && select_lex->ref_pointer_array[i]->maybe_null)
      {
        Item *having_col_item=
          new (thd->mem_root)
          Item_is_not_null_test(thd, this,
                                new (thd->mem_root)
                                Item_ref(thd, &select_lex->context, 
                                         &select_lex->ref_pointer_array[i],
                                         (char *)""<no matter>"",
                                         (char *)""<list ref>""));
        
        
        item_isnull= new (thd->mem_root)
          Item_func_isnull(thd,
                           new (thd->mem_root)
                           Item_direct_ref(thd, &select_lex->context,
                                           &select_lex->
                                           ref_pointer_array[i],
                                           (char *)""<no matter>"",
                                           (char *)""<list ref>""));
        item= new (thd->mem_root) Item_cond_or(thd, item, item_isnull);
        if (left_expr->element_index(i)->maybe_null && get_cond_guard(i))
        {
          disable_cond_guard_for_const_null_left_expr(i);
          if (!(item= new (thd->mem_root)
                Item_func_trig_cond(thd, item, get_cond_guard(i))))
            DBUG_RETURN(true);
          if (!(having_col_item= new (thd->mem_root)
                Item_func_trig_cond(thd, having_col_item, get_cond_guard(i))))
            DBUG_RETURN(true);
        }
        *having_item= and_items(thd, *having_item, having_col_item);
      }
      if (!abort_on_null && left_expr->element_index(i)->maybe_null &&
          get_cond_guard(i))
      {
        if (!(item= new (thd->mem_root)
              Item_func_trig_cond(thd, item, get_cond_guard(i))))
          DBUG_RETURN(true);
      }
      *where_item= and_items(thd, *where_item, item);
    }
  }

  if (*where_item)
  {
    if (!(*where_item)->fixed && (*where_item)->fix_fields(thd, 0))
      DBUG_RETURN(true);
    (*where_item)->top_level_item();
  }

  if (*having_item)
  {
    if (!join_having)
      (*having_item)->name= (char*) in_having_cond;
    if (fix_having(*having_item, select_lex))
      DBUG_RETURN(true);
    (*having_item)->top_level_item();
  }

  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,9049669821144551808703883996333616442,181,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_exists_subselect::val_bool()
{
  DBUG_ASSERT(fixed == 1);
  if (!forced_const && exec())
  {
    reset();
    return 0;
  }
  return value != 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,223002093390344215431247968380560216930,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"longlong Item_in_subselect::val_int()
{
  /*
    As far as Item_in_subselect called only from Item_in_optimizer this
    method should not be used
  */
  DBUG_ASSERT(0);
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
    return value;
  DBUG_ASSERT((engine->uncacheable() & ~UNCACHEABLE_EXPLAIN) ||
              ! engine->is_executed());
  null_value= was_null= FALSE;
  if (exec())
  {
    reset();
    return 0;
  }
  if (was_null && !value)
    null_value= TRUE;
  return value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,33737584695020673965944773834988153881,22,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_uniquesubquery_engine::print(String *str,
                                            enum_query_type query_type)
{
  char *table_name= tab->table->s->table_name.str;
  str->append(STRING_WITH_LEN(""<primary_index_lookup>(""));
  tab->ref.items[0]->print(str, query_type);
  str->append(STRING_WITH_LEN("" in ""));
  if (tab->table->s->table_category == TABLE_CATEGORY_TEMPORARY)
  {
    /*
      Temporary tables' names change across runs, so they can't be used for
      EXPLAIN EXTENDED.
    */
    str->append(STRING_WITH_LEN(""<temporary table>""));
  }
  else
    str->append(table_name, tab->table->s->table_name.length);
  KEY *key_info= tab->table->key_info+ tab->ref.key;
  str->append(STRING_WITH_LEN("" on ""));
  str->append(key_info->name);
  if (cond)
  {
    str->append(STRING_WITH_LEN("" where ""));
    cond->print(str, query_type);
  }
  str->append(')');
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,2696583649759568463986240174020659626,27,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_uniquesubquery_engine::exec()
{
  DBUG_ENTER(""subselect_uniquesubquery_engine::exec"");
  int error;
  TABLE *table= tab->table;
  empty_result_set= TRUE;
  table->status= 0;
  Item_in_subselect *in_subs= (Item_in_subselect *) item;

  if (!tab->preread_init_done && tab->preread_init())
    DBUG_RETURN(1);
 
  if (in_subs->left_expr_has_null())
  {
    /*
      The case when all values in left_expr are NULL is handled by
      Item_in_optimizer::val_int().
    */
    if (in_subs->is_top_level_item())
      DBUG_RETURN(1); /* notify caller to call reset() and set NULL value. */
    else
      DBUG_RETURN(scan_table());
  }

  if (copy_ref_key(true))
  {
    /* We know that there will be no rows even if we scan. */
    in_subs->value= 0;
    DBUG_RETURN(0);
  }

  if (!table->file->inited &&
      (error= table->file->ha_index_init(tab->ref.key, 0)))
  {
    (void) report_error(table, error);
    DBUG_RETURN(true);
  }

  error= table->file->ha_index_read_map(table->record[0],
                                        tab->ref.key_buff,
                                        make_prev_keypart_map(tab->
                                                              ref.key_parts),
                                        HA_READ_KEY_EXACT);
  if (error &&
      error != HA_ERR_KEY_NOT_FOUND && error != HA_ERR_END_OF_FILE)
    error= report_error(table, error);
  else
  {
    error= 0;
    table->null_row= 0;
    if (!table->status && (!cond || cond->val_int()))
    {
      ((Item_in_subselect *) item)->value= 1;
      empty_result_set= FALSE;
    }
    else
      ((Item_in_subselect *) item)->value= 0;
  }

  DBUG_RETURN(error != 0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,54379988402431178631393928115667441214,61,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::exec()
{
  DBUG_ENTER(""Item_in_subselect::exec"");
  DBUG_ASSERT(fixed);
  /*
    Initialize the cache of the left predicate operand. This has to be done as
    late as now, because Cached_item directly contains a resolved field (not
    an item, and in some cases (when temp tables are created), these fields
    end up pointing to the wrong field. One solution is to change Cached_item
    to not resolve its field upon creation, but to resolve it dynamically
    from a given Item_ref object.
    TODO: the cache should be applied conditionally based on:
    - rules - e.g. only if the left operand is known to be ordered, and/or
    - on a cost-based basis, that takes into account the cost of a cache
      lookup, the cache hit rate, and the savings per cache hit.
  */
  if (!left_expr_cache && (test_strategy(SUBS_MATERIALIZATION)))
    init_left_expr_cache();

  /*
    If the new left operand is already in the cache, reuse the old result.
    Use the cached result only if this is not the first execution of IN
    because the cache is not valid for the first execution.
  */
  if (!first_execution && left_expr_cache &&
      test_if_item_cache_changed(*left_expr_cache) < 0)
    DBUG_RETURN(FALSE);

  /*
    The exec() method below updates item::value, and item::null_value, thus if
    we don't call it, the next call to item::val_int() will return whatever
    result was computed by its previous call.
  */
  DBUG_RETURN(Item_subselect::exec());
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,203477901881790851065086422005657484226,35,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"double Item_in_subselect::val_real()
{
  /*
    As far as Item_in_subselect called only from Item_in_optimizer this
    method should not be used
  */
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
    return value;
  DBUG_ASSERT((engine->uncacheable() & ~UNCACHEABLE_EXPLAIN) ||
              ! engine->is_executed());
  null_value= was_null= FALSE;
  if (exec())
  {
    reset();
    return 0;
  }
  if (was_null && !value)
    null_value= TRUE;
  return (double) value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,146921072988771252780820844659006801556,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  thd->where= save_where;
  return res;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,134931615237633544149886270925536433960,7,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_indexsubquery_engine::print(String *str,
                                           enum_query_type query_type)
{
  str->append(STRING_WITH_LEN(""<index_lookup>(""));
  tab->ref.items[0]->print(str, query_type);
  str->append(STRING_WITH_LEN("" in ""));
  str->append(tab->table->s->table_name.str, tab->table->s->table_name.length);
  KEY *key_info= tab->table->key_info+ tab->ref.key;
  str->append(STRING_WITH_LEN("" on ""));
  str->append(key_info->name);
  if (check_null)
    str->append(STRING_WITH_LEN("" checking NULL""));
  if (cond)
  {
    str->append(STRING_WITH_LEN("" where ""));
    cond->print(str, query_type);
  }
  if (having)
  {
    str->append(STRING_WITH_LEN("" having ""));
    having->print(str, query_type);
  }
  str->append(')');
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,30624504359628520736486771872148179242,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void check_out_index_stats(JOIN *join)
{
  ORDER *order;
  uint n_order_items;

  /*
    First, collect the keys that we can use in each table.
    We can use a key if 
    - all tables refer to it.
  */
  key_map key_start_use[MAX_TABLES];
  key_map key_infix_use[MAX_TABLES];
  table_map key_used=0;
  table_map non_key_used= 0;
  
  bzero(&key_start_use, sizeof(key_start_use)); //psergey-todo: safe initialization!
  bzero(&key_infix_use, sizeof(key_infix_use));
  
  for (order= join->group_list; order; order= order->next)
  {
    Item *item= order->item[0];

    if (item->real_type() == Item::FIELD_ITEM)
    {
      if (item->used_tables() & OUTER_REF_TABLE_BIT)
        continue; /* outside references are like constants for us */

      Field *field= ((Item_field*)item->real_item())->field;
      uint table_no= field->table->tablenr;
      if (!(non_key_used && table_map(1) << table_no) && 
          !field->part_of_key.is_clear_all())
      {
        key_map infix_map= field->part_of_key;
        infix_map.subtract(field->key_start);
        key_start_use[table_no].merge(field->key_start);
        key_infix_use[table_no].merge(infix_map);
        key_used |= table_no;
      }
      continue;
    }
    /* 
      Note: the below will cause clauses like GROUP BY YEAR(date) not to be
      handled. 
    */
    non_key_used |= item->used_tables();
  }
  
  Table_map_iterator tm_it(key_used & ~non_key_used);
  int tableno;
  while ((tableno = tm_it.next_bit()) != Table_map_iterator::BITMAP_END)
  {
    key_map::iterator key_it(key_start_use);
    int keyno;
    while ((keyno = tm_it.next_bit()) != key_map::iterator::BITMAP_END)
    {
      for (order= join->group_list; order; order= order->next)
      {
        Item *item= order->item[0];
        if (item->used_tables() & (table_map(1) << tableno))
        {
          DBUG_ASSERT(item->real_type() == Item::FIELD_ITEM);
        }
      }
      /*
      if (continuation)
      {
        walk through list and find which key parts are occupied;
        // note that the above can't be made any faster.
      }
      else
        use rec_per_key[0];
      
      find out the cardinality.
      check if cardinality decreases if we use it;
      */
    }
  }
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,70498980150700154255742541499787421739,78,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_hash_sj_engine::exec()
{
  Item_in_subselect *item_in= (Item_in_subselect *) item;
  SELECT_LEX *save_select= thd->lex->current_select;
  subselect_partial_match_engine *pm_engine= NULL;
  int res= 0;

  DBUG_ENTER(""subselect_hash_sj_engine::exec"");

  /*
    Optimize and materialize the subquery during the first execution of
    the subquery predicate.
  */
  thd->lex->current_select= materialize_engine->select_lex;
  /* The subquery should be optimized, and materialized only once. */
  DBUG_ASSERT(materialize_join->optimization_state == JOIN::OPTIMIZATION_DONE &&
              !is_materialized);
  materialize_join->exec();
  if ((res= MY_TEST(materialize_join->error || thd->is_fatal_error ||
                    thd->is_error())))
    goto err;

  /*
    TODO:
    - Unlock all subquery tables as we don't need them. To implement this
      we need to add new functionality to JOIN::join_free that can unlock
      all tables in a subquery (and all its subqueries).
    - The temp table used for grouping in the subquery can be freed
      immediately after materialization (yet it's done together with
      unlocking).
  */
  is_materialized= TRUE;
  /*
    If the subquery returned no rows, the temporary table is empty, so we know
    directly that the result of IN is FALSE. We first update the table
    statistics, then we test if the temporary table for the query result is
    empty.
  */
  tmp_table->file->info(HA_STATUS_VARIABLE);
  if (!tmp_table->file->stats.records)
  {
    /* The value of IN will not change during this execution. */
    item_in->reset();
    item_in->make_const();
    item_in->set_first_execution();
    thd->lex->current_select= save_select;
    DBUG_RETURN(FALSE);
  }

  /*
    TIMOUR: The schema-based analysis for partial matching can be done once for
    prepared statement and remembered. It is done here to remove the need to
    save/restore all related variables between each re-execution, thus making
    the code simpler.
  */
  strategy= get_strategy_using_schema();
  /* This call may discover that we don't need partial matching at all. */
  strategy= get_strategy_using_data();
  if (strategy == PARTIAL_MATCH)
  {
    uint count_pm_keys; /* Total number of keys needed for partial matching. */
    MY_BITMAP *nn_key_parts= NULL; /* Key parts of the only non-NULL index. */
    uint count_non_null_columns= 0; /* Number of columns in nn_key_parts. */
    bool has_covering_null_row;
    bool has_covering_null_columns;
    select_materialize_with_stats *result_sink=
      (select_materialize_with_stats *) result;
    uint field_count= tmp_table->s->fields;

    if (count_partial_match_columns < field_count)
    {
      nn_key_parts= &non_null_key_parts;
      count_non_null_columns= bitmap_bits_set(nn_key_parts);
    }
    has_covering_null_row= (result_sink->get_max_nulls_in_row() == field_count);
    has_covering_null_columns= (count_non_null_columns +
                                count_null_only_columns == field_count);

    if (has_covering_null_row && has_covering_null_columns)
    {
      /*
        The whole table consist of only NULL values. The result of IN is
        a constant UNKNOWN.
      */
      DBUG_ASSERT(tmp_table->file->stats.records == 1);
      item_in->value= 0;
      item_in->null_value= 1;
      item_in->make_const();
      item_in->set_first_execution();
      thd->lex->current_select= save_select;
      DBUG_RETURN(FALSE);
    }

    if (has_covering_null_row)
    {
      DBUG_ASSERT(count_partial_match_columns == field_count);
      count_pm_keys= 0;
    }
    else if (has_covering_null_columns)
      count_pm_keys= 1;
    else
      count_pm_keys= count_partial_match_columns - count_null_only_columns +
                     (nn_key_parts ? 1 : 0);

    choose_partial_match_strategy(MY_TEST(nn_key_parts),
                                  has_covering_null_row,
                                  &partial_match_key_parts);
    DBUG_ASSERT(strategy == PARTIAL_MATCH_MERGE ||
                strategy == PARTIAL_MATCH_SCAN);
    if (strategy == PARTIAL_MATCH_MERGE)
    {
      pm_engine=
        new subselect_rowid_merge_engine((subselect_uniquesubquery_engine*)
                                         lookup_engine, tmp_table,
                                         count_pm_keys,
                                         has_covering_null_row,
                                         has_covering_null_columns,
                                         count_columns_with_nulls,
                                         item, result,
                                         semi_join_conds->argument_list());
      if (!pm_engine ||
          pm_engine->prepare(thd) ||
          ((subselect_rowid_merge_engine*) pm_engine)->
            init(nn_key_parts, &partial_match_key_parts))
      {
        /*
          The call to init() would fail if there was not enough memory to allocate
          all buffers for the rowid merge strategy. In this case revert to table
          scanning which doesn't need any big buffers.
        */
        delete pm_engine;
        pm_engine= NULL;
        strategy= PARTIAL_MATCH_SCAN;
      }
    }

    if (strategy == PARTIAL_MATCH_SCAN)
    {
      if (!(pm_engine=
            new subselect_table_scan_engine((subselect_uniquesubquery_engine*)
                                            lookup_engine, tmp_table,
                                            item, result,
                                            semi_join_conds->argument_list(),
                                            has_covering_null_row,
                                            has_covering_null_columns,
                                            count_columns_with_nulls)) ||
          pm_engine->prepare(thd))
      {
        /* This is an irrecoverable error. */
        res= 1;
        goto err;
      }
    }
  }

  if (pm_engine)
    lookup_engine= pm_engine;
  item_in->change_engine(lookup_engine);

err:
  thd->lex->current_select= save_select;
  DBUG_RETURN(res);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,225580211164096792410753804490861198243,163,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_union_engine::change_result(Item_subselect *si,
                                           select_result_interceptor *res,
                                           bool temp)
{
  item= si;
  int rc= unit->change_result(res, result);
  if (temp)
    thd->change_item_tree((Item**) &result, (Item*)res);
  else
    result= res;
  return rc;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,81739610727433751875225486275463437812,12,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_subselect::~Item_subselect()
{
  DBUG_ENTER(""Item_subselect::~Item_subselect"");
  DBUG_PRINT(""enter"", (""this: %p"", this));
  if (own_engine)
    delete engine;
  else
    engine->cleanup();
  engine= NULL;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,298417954682882555229631583096917056255,11,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_single_select_engine::may_be_null()
{
  return ((no_tables() && !join->conds && !join->having) ? maybe_null : 1);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,307330486323739762891049258167566272067,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_hash_sj_engine::get_strategy_using_data()
{
  Item_in_subselect *item_in= (Item_in_subselect *) item;
  select_materialize_with_stats *result_sink=
    (select_materialize_with_stats *) result;
  Item *outer_col;

  /*
    If we already determined that a complete match is enough based on schema
    information, nothing can be better.
  */
  if (strategy == COMPLETE_MATCH)
    return COMPLETE_MATCH;

  for (uint i= 0; i < item_in->left_expr->cols(); i++)
  {
    if (!bitmap_is_set(&partial_match_key_parts, i))
      continue;
    outer_col= item_in->left_expr->element_index(i);
    /*
      If column 'i' doesn't contain NULLs, and the corresponding outer reference
      cannot have a NULL value, then 'i' is a non-nullable column.
    */
    if (result_sink->get_null_count_of_col(i) == 0 && !outer_col->maybe_null)
    {
      bitmap_clear_bit(&partial_match_key_parts, i);
      bitmap_set_bit(&non_null_key_parts, i);
      --count_partial_match_columns;
    }
    if (result_sink->get_null_count_of_col(i) == tmp_table->file->stats.records)
      ++count_null_only_columns;
    if (result_sink->get_null_count_of_col(i))
      ++count_columns_with_nulls;
  }

  /* If no column contains NULLs use regular hash index lookups. */
  if (!count_partial_match_columns)
    return COMPLETE_MATCH;
  return PARTIAL_MATCH;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,316149667672124681688462352106254737060,40,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_singlerow_subselect::store(uint i, Item *item)
{
  row[i]->store(item);
  row[i]->cache_value();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,160994007564739748423686020127238082967,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Ordered_key::cmp_keys_by_row_data_and_rownum(Ordered_key *key,
                                             rownum_t* a, rownum_t* b)
{
  /* The result of comparing the two keys according to their row data. */
  int cmp_row_res= key->cmp_keys_by_row_data(*a, *b);
  if (cmp_row_res)
    return cmp_row_res;
  return (*a < *b) ? -1 : (*a > *b) ? 1 : 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,179498256380862678576460129615379743687,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Ordered_key::alloc_keys_buffers()
{
  DBUG_ASSERT(key_buff_elements > 0);

  if (!(key_buff= (rownum_t*) my_malloc((size_t)(key_buff_elements * 
    sizeof(rownum_t)), MYF(MY_WME | MY_THREAD_SPECIFIC))))
    return TRUE;

  /*
    TIMOUR: it is enough to create bitmaps with size
    (max_null_row - min_null_row), and then use min_null_row as
    lookup offset.
  */
  /* Notice that max_null_row is max array index, we need count, so +1. */
  if (my_bitmap_init(&null_key, NULL, (uint)(max_null_row + 1), FALSE))
    return TRUE;

  cur_key_idx= HA_POS_ERROR;

  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,74572430935979993516454600040989898973,21,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_singlerow_subselect::Item_singlerow_subselect(THD *thd, st_select_lex *select_lex):
  Item_subselect(thd), value(0)
{
  DBUG_ENTER(""Item_singlerow_subselect::Item_singlerow_subselect"");
  init(select_lex, new (thd->mem_root) select_singlerow_subselect(thd, this));
  maybe_null= 1;
  max_columns= UINT_MAX;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,139468003830134769360005441247670602452,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_single_select_engine::exec()
{
  DBUG_ENTER(""subselect_single_select_engine::exec"");

  char const *save_where= thd->where;
  SELECT_LEX *save_select= thd->lex->current_select;
  thd->lex->current_select= select_lex;

  if (join->optimization_state == JOIN::NOT_OPTIMIZED)
  {
    SELECT_LEX_UNIT *unit= select_lex->master_unit();

    unit->set_limit(unit->global_parameters());
    if (join->optimize())
    {
      thd->where= save_where;
      executed= 1;
      thd->lex->current_select= save_select;
      DBUG_RETURN(join->error ? join->error : 1);
    }
    if (!select_lex->uncacheable && thd->lex->describe && 
        !(join->select_options & SELECT_DESCRIBE))
    {
      item->update_used_tables();
      if (item->const_item())
      {
        /*
          It's necessary to keep original JOIN table because
          create_sort_index() function may overwrite original
          JOIN_TAB::type and wrong optimization method can be
          selected on re-execution.
        */
        select_lex->uncacheable|= UNCACHEABLE_EXPLAIN;
        select_lex->master_unit()->uncacheable|= UNCACHEABLE_EXPLAIN;
      }
    }
    if (item->engine_changed(this))
    {
      thd->lex->current_select= save_select;
      DBUG_RETURN(1);
    }
  }
  if (select_lex->uncacheable &&
      select_lex->uncacheable != UNCACHEABLE_EXPLAIN
      && executed)
  {
    if (join->reinit())
    {
      thd->where= save_where;
      thd->lex->current_select= save_select;
      DBUG_RETURN(1);
    }
    item->reset();
    item->assigned((executed= 0));
  }
  if (!executed)
  {
    item->reset_value_registration();
    JOIN_TAB *changed_tabs[MAX_TABLES];
    JOIN_TAB **last_changed_tab= changed_tabs;
    if (item->have_guarded_conds())
    {
      /*
        For at least one of the pushed predicates the following is true:
        We should not apply optimizations based on the condition that was
        pushed down into the subquery. Those optimizations are ref[_or_null]
        accesses. Change them to be full table scans.
      */
      JOIN_TAB *tab;
      for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);
           tab; tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))
      {
        if (tab && tab->keyuse)
        {
          for (uint i= 0; i < tab->ref.key_parts; i++)
          {
            bool *cond_guard= tab->ref.cond_guards[i];
            if (cond_guard && !*cond_guard)
            {
              /* Change the access method to full table scan */
              tab->save_read_first_record= tab->read_first_record;
              tab->save_read_record= tab->read_record.read_record;
              tab->read_record.read_record= rr_sequential;
              tab->read_first_record= read_first_record_seq;
              tab->read_record.record= tab->table->record[0];
              tab->read_record.thd= join->thd;
              tab->read_record.ref_length= tab->table->file->ref_length;
              tab->read_record.unlock_row= rr_unlock_row;
              *(last_changed_tab++)= tab;
              break;
            }
          }
        }
      }
    }
    
    join->exec();

    /* Enable the optimizations back */
    for (JOIN_TAB **ptab= changed_tabs; ptab != last_changed_tab; ptab++)
    {
      JOIN_TAB *tab= *ptab;
      tab->read_record.record= 0;
      tab->read_record.ref_length= 0;
      tab->read_first_record= tab->save_read_first_record; 
      tab->read_record.read_record= tab->save_read_record;
    }
    executed= 1;
    if (!(uncacheable() & ~UNCACHEABLE_EXPLAIN) &&
        !item->with_recursive_reference)
      item->make_const();
    thd->where= save_where;
    thd->lex->current_select= save_select;
    DBUG_RETURN(join->error || thd->is_fatal_error || thd->is_error());
  }
  thd->where= save_where;
  thd->lex->current_select= save_select;
  DBUG_RETURN(0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,128451545115489505043071094794253692910,119,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_union_engine::subselect_union_engine(st_select_lex_unit *u,
					       select_result_interceptor *result_arg,
					       Item_subselect *item_arg)
  :subselect_engine(item_arg, result_arg)
{
  unit= u;
  unit->item= item_arg;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,228506752022550941943672738696190750180,8,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int Item_in_subselect::get_identifier()
{
  return engine->get_identifier();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,88528698631839359397345171467660246622,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Ordered_key::cleanup()
{
  /*
    Currently these keys are recreated for each PS re-execution, thus
    there is nothing to cleanup, the whole object goes away after execution
    is over. All handler related initialization/deinitialization is done by
    the parent subselect_rowid_merge_engine object.
  */
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,198541660454707045969710049628659950514,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"enum_field_types Item_singlerow_subselect::field_type() const
{
  return engine->field_type();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,190839985728227478364862063318707267415,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_allany_subselect::cleanup()
{
  /*
    The MAX/MIN transformation through injection is reverted through the
    change_item_tree() mechanism. Revert the select_lex object of the
    query to its initial state.
  */
  for (SELECT_LEX *sl= unit->first_select();
       sl; sl= sl->next_select())
    if (test_set_strategy(SUBS_MAXMIN_INJECTED))
      sl->with_sum_func= false;
  Item_in_subselect::cleanup();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,193421565017129523621378892553110606180,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_hash_sj_engine::init(List<Item> *tmp_columns, uint subquery_id)
{
  THD *thd= get_thd();
  select_union *result_sink;
  /* Options to create_tmp_table. */
  ulonglong tmp_create_options= thd->variables.option_bits | TMP_TABLE_ALL_COLUMNS;
                             /* | TMP_TABLE_FORCE_MYISAM; TIMOUR: force MYISAM */

  DBUG_ENTER(""subselect_hash_sj_engine::init"");

  if (my_bitmap_init_memroot(&non_null_key_parts, tmp_columns->elements,
                            thd->mem_root) ||
      my_bitmap_init_memroot(&partial_match_key_parts, tmp_columns->elements,
                            thd->mem_root))
    DBUG_RETURN(TRUE);

  /*
    Create and initialize a select result interceptor that stores the
    result stream in a temporary table. The temporary table itself is
    managed (created/filled/etc) internally by the interceptor.
  */
/*
  TIMOUR:
  Select a more efficient result sink when we know there is no need to collect
  data statistics.

  if (strategy == COMPLETE_MATCH)
  {
    if (!(result= new select_union))
      DBUG_RETURN(TRUE);
  }
  else if (strategy == PARTIAL_MATCH)
  {
  if (!(result= new select_materialize_with_stats))
    DBUG_RETURN(TRUE);
  }
*/
  if (!(result_sink= new (thd->mem_root) select_materialize_with_stats(thd)))
    DBUG_RETURN(TRUE);
    
  char buf[32];
  uint len= my_snprintf(buf, sizeof(buf), ""<subquery%d>"", subquery_id);
  char *name;
  if (!(name= (char*)thd->alloc(len + 1)))
    DBUG_RETURN(TRUE);
  memcpy(name, buf, len+1);

  result_sink->get_tmp_table_param()->materialized_subquery= true;
  if (item->substype() == Item_subselect::IN_SUBS && 
      ((Item_in_subselect*)item)->is_jtbm_merged)
  {
    result_sink->get_tmp_table_param()->force_not_null_cols= true;
  }
  if (result_sink->create_result_table(thd, tmp_columns, TRUE,
                                       tmp_create_options,
				       name, TRUE, TRUE))
    DBUG_RETURN(TRUE);

  tmp_table= result_sink->table;
  result= result_sink;

  /*
    If the subquery has blobs, or the total key length is bigger than
    some length, or the total number of key parts is more than the
    allowed maximum (currently MAX_REF_PARTS == 32), then the created
    index cannot be used for lookups and we can't use hash semi
    join. If this is the case, delete the temporary table since it
    will not be used, and tell the caller we failed to initialize the
    engine.
  */
  if (tmp_table->s->keys == 0)
  {
    //fprintf(stderr, ""Q: %s\n"", current_thd->query());
    DBUG_ASSERT(0);
    DBUG_ASSERT(
      tmp_table->s->uniques ||
      tmp_table->key_info->key_length >= tmp_table->file->max_key_length() ||
      tmp_table->key_info->user_defined_key_parts >
      tmp_table->file->max_key_parts());
    free_tmp_table(thd, tmp_table);
    tmp_table= NULL;
    delete result;
    result= NULL;
    DBUG_RETURN(TRUE);
  }

  /*
    Make sure there is only one index on the temp table, and it doesn't have
    the extra key part created when s->uniques > 0.
  */
  DBUG_ASSERT(tmp_table->s->keys == 1 &&
              ((Item_in_subselect *) item)->left_expr->cols() ==
              tmp_table->key_info->user_defined_key_parts);

  if (make_semi_join_conds() ||
      /* A unique_engine is used both for complete and partial matching. */
      !(lookup_engine= make_unique_engine()))
    DBUG_RETURN(TRUE);

  /*
    Repeat name resolution for 'cond' since cond is not part of any
    clause of the query, and it is not 'fixed' during JOIN::prepare.
  */
  if (semi_join_conds && !semi_join_conds->fixed &&
      semi_join_conds->fix_fields(thd, (Item**)&semi_join_conds))
    DBUG_RETURN(TRUE);
  /* Let our engine reuse this query plan for materialization. */
  materialize_join= materialize_engine->join;
  materialize_join->change_result(result, NULL);

  DBUG_RETURN(FALSE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,289066082569498403241636366448021744043,112,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_single_select_engine::force_reexecution()
{ 
  executed= false;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,132580722955637049043598961940772036490,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_hash_sj_engine::cleanup()
{
  enum_engine_type lookup_engine_type= lookup_engine->engine_type();
  is_materialized= FALSE;
  bitmap_clear_all(&non_null_key_parts);
  bitmap_clear_all(&partial_match_key_parts);
  count_partial_match_columns= 0;
  count_null_only_columns= 0;
  strategy= UNDEFINED;
  materialize_engine->cleanup();
  /*
    Restore the original Item_in_subselect engine. This engine is created once
    at parse time and stored across executions, while all other materialization
    related engines are created and chosen for each execution.
  */
  ((Item_in_subselect *) item)->engine= materialize_engine;
  if (lookup_engine_type == TABLE_SCAN_ENGINE ||
      lookup_engine_type == ROWID_MERGE_ENGINE)
  {
    subselect_engine *inner_lookup_engine;
    inner_lookup_engine=
      ((subselect_partial_match_engine*) lookup_engine)->lookup_engine;
    /*
      Partial match engines are recreated for each PS execution inside
      subselect_hash_sj_engine::exec().
    */
    delete lookup_engine;
    lookup_engine= inner_lookup_engine;
  }
  DBUG_ASSERT(lookup_engine->engine_type() == UNIQUESUBQUERY_ENGINE);
  lookup_engine->cleanup();
  result->cleanup(); /* Resets the temp table as well. */
  DBUG_ASSERT(tmp_table);
  free_tmp_table(thd, tmp_table);
  tmp_table= NULL;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,164105089746231303424026555722278302871,36,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"ulonglong subselect_hash_sj_engine::rowid_merge_buff_size(
  bool has_non_null_key, bool has_covering_null_row,
  MY_BITMAP *partial_match_key_parts)
{
  /* Total size of all buffers used by partial matching. */
  ulonglong buff_size;
  ha_rows row_count= tmp_table->file->stats.records;
  uint rowid_length= tmp_table->file->ref_length;
  select_materialize_with_stats *result_sink=
    (select_materialize_with_stats *) result;
  ha_rows max_null_row;

  /* Size of the subselect_rowid_merge_engine::row_num_to_rowid buffer. */
  buff_size= row_count * rowid_length * sizeof(uchar);

  if (has_non_null_key)
  {
    /* Add the size of Ordered_key::key_buff of the only non-NULL key. */
    buff_size+= row_count * sizeof(rownum_t);
  }

  if (!has_covering_null_row)
  {
    for (uint i= 0; i < partial_match_key_parts->n_bits; i++)
    {
      if (!bitmap_is_set(partial_match_key_parts, i) ||
          result_sink->get_null_count_of_col(i) == row_count)
        continue; /* In these cases we wouldn't construct Ordered keys. */

      /* Add the size of Ordered_key::key_buff */
      buff_size+= (row_count - result_sink->get_null_count_of_col(i)) *
                         sizeof(rownum_t);
      /* Add the size of Ordered_key::null_key */
      max_null_row= result_sink->get_max_null_of_col(i);
      if (max_null_row >= UINT_MAX)
      {
        /*
          There can be at most UINT_MAX bits in a MY_BITMAP that is used to
          store NULLs in an Ordered_key. Return a number of bytes bigger than
          the maximum allowed memory buffer for partial matching to disable
          the rowid merge strategy.
        */
        return ULONGLONG_MAX;
      }
      buff_size+= bitmap_buffer_size(max_null_row);
    }
  }

  return buff_size;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,268436720139819830896417487341809787566,50,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_rowid_merge_engine::
exists_complementing_null_row(MY_BITMAP *keys_to_complement)
{
  rownum_t highest_min_row= 0;
  rownum_t lowest_max_row= UINT_MAX;
  uint count_null_keys, i;
  Ordered_key *cur_key;

  if (!count_columns_with_nulls)
  {
    /*
      If there are both NULLs and non-NUll values in the outer reference, and
      the subquery contains no NULLs, a complementing NULL row cannot exist.
    */
    return FALSE;
  }

  for (i= (non_null_key ? 1 : 0), count_null_keys= 0; i < merge_keys_count; i++)
  {
    cur_key= merge_keys[i];
    if (bitmap_is_set(keys_to_complement, cur_key->get_keyid()))
      continue;
    if (!cur_key->get_null_count())
    {
      /* If there is column without NULLs, there cannot be a partial match. */
      return FALSE;
    }
    if (cur_key->get_min_null_row() > highest_min_row)
      highest_min_row= cur_key->get_min_null_row();
    if (cur_key->get_max_null_row() < lowest_max_row)
      lowest_max_row= cur_key->get_max_null_row();
    null_bitmaps[count_null_keys++]= cur_key->get_null_key();
  }

  if (lowest_max_row < highest_min_row)
  {
    /* The intersection of NULL rows is empty. */
    return FALSE;
  }

  return bitmap_exists_intersection((const MY_BITMAP**) null_bitmaps,
                                    count_null_keys,
                                    (uint)highest_min_row, (uint)lowest_max_row);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,241076668167764778321391245390126188157,44,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::fix_length_and_dec()
{
  if (engine->fix_length_and_dec(0))
    return TRUE;
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,67248598852205099504282289465946337701,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_allany_subselect::transform_into_max_min(JOIN *join)
{
  DBUG_ENTER(""Item_allany_subselect::transform_into_max_min"");
  if (!test_strategy(SUBS_MAXMIN_INJECTED | SUBS_MAXMIN_ENGINE))
    DBUG_RETURN(false);
  Item **place= optimizer->arguments() + 1;
  SELECT_LEX *select_lex= join->select_lex;
  Item *subs;
  DBUG_ASSERT(thd == join->thd);

  /*
  */
  DBUG_ASSERT(!substitution);

  /*
    Check if optimization with aggregate min/max possible
    1 There is no aggregate in the subquery
    2 It is not UNION
    3 There is tables
    4 It is not ALL subquery with possible NULLs in the SELECT list
  */
  if (!select_lex->group_list.elements &&                /*1*/
      !select_lex->having &&                             /*1*/
      !select_lex->with_sum_func &&                      /*1*/
      !(select_lex->next_select()) &&                    /*2*/
      select_lex->table_list.elements &&                 /*3*/
      (!select_lex->ref_pointer_array[0]->maybe_null ||  /*4*/
       substype() != Item_subselect::ALL_SUBS))          /*4*/
  {
    Item_sum_hybrid *item;
    nesting_map save_allow_sum_func;
    if (func->l_op())
    {
      /*
        (ALL && (> || =>)) || (ANY && (< || =<))
        for ALL condition is inverted
      */
      item= new (thd->mem_root) Item_sum_max(thd,
                                             select_lex->ref_pointer_array[0]);
    }
    else
    {
      /*
        (ALL && (< || =<)) || (ANY && (> || =>))
        for ALL condition is inverted
      */
      item= new (thd->mem_root) Item_sum_min(thd,
                                             select_lex->ref_pointer_array[0]);
    }
    if (upper_item)
      upper_item->set_sum_test(item);
    thd->change_item_tree(&select_lex->ref_pointer_array[0], item);
    {
      List_iterator<Item> it(select_lex->item_list);
      it++;
      thd->change_item_tree(it.ref(), item);
    }

    DBUG_EXECUTE(""where"",
                 print_where(item, ""rewrite with MIN/MAX"", QT_ORDINARY););

    save_allow_sum_func= thd->lex->allow_sum_func;
    thd->lex->allow_sum_func|=
        (nesting_map)1 << thd->lex->current_select->nest_level;
    /*
      Item_sum_(max|min) can't substitute other item => we can use 0 as
      reference, also Item_sum_(max|min) can't be fixed after creation, so
      we do not check item->fixed
    */
    if (item->fix_fields(thd, 0))
      DBUG_RETURN(true);
    thd->lex->allow_sum_func= save_allow_sum_func; 
    /* we added aggregate function => we have to change statistic */
    count_field_types(select_lex, &join->tmp_table_param, join->all_fields, 
                      0);
    if (join->prepare_stage2())
      DBUG_RETURN(true);
    subs= new (thd->mem_root) Item_singlerow_subselect(thd, select_lex);

    /*
      Remove other strategies if any (we already changed the query and
      can't apply other strategy).
    */
    set_strategy(SUBS_MAXMIN_INJECTED);
  }
  else
  {
    Item_maxmin_subselect *item;
    subs= item= new (thd->mem_root) Item_maxmin_subselect(thd, this, select_lex, func->l_op());
    if (upper_item)
      upper_item->set_sub_test(item);
    /*
      Remove other strategies if any (we already changed the query and
      can't apply other strategy).
    */
    set_strategy(SUBS_MAXMIN_ENGINE);
  }
  /*
    The swap is needed for expressions of type 'f1 < ALL ( SELECT ....)'
    where we want to evaluate the sub query even if f1 would be null.
  */
  subs= func->create_swap(thd, expr, subs);
  thd->change_item_tree(place, subs);
  if (subs->fix_fields(thd, &subs))
    DBUG_RETURN(true);
  DBUG_ASSERT(subs == (*place)); // There was no substitutions

  select_lex->master_unit()->uncacheable&= ~UNCACHEABLE_DEPENDENT_INJECTED;
  select_lex->uncacheable&= ~UNCACHEABLE_DEPENDENT_INJECTED;

  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,174988037395219415831382712448748430471,112,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::mark_as_eliminated_processor(void *arg)
{
  eliminated= TRUE;
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,318227579714638237470832100498503222332,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_subselect::Item_subselect(THD *thd_arg):
  Item_result_field(thd_arg), Used_tables_and_const_cache(),
  value_assigned(0), own_engine(0), thd(0), old_engine(0),
  have_to_be_excluded(0),
  inside_first_fix_fields(0), done_first_fix_fields(FALSE), 
  expr_cache(0), forced_const(FALSE), substitution(0), engine(0), eliminated(FALSE),
  changed(0), is_correlated(FALSE), with_recursive_reference(0)
{
  DBUG_ENTER(""Item_subselect::Item_subselect"");
  DBUG_PRINT(""enter"", (""this: %p"", this));
  sortbuffer.str= 0;

#ifndef DBUG_OFF
  exec_counter= 0;
#endif
  with_subselect= 1;
  reset();
  /*
    Item value is NULL if select_result_interceptor didn't change this value
    (i.e. some rows will be found returned)
  */
  null_value= TRUE;
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,3139641459350960475572229042805610139,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::fix_length_and_dec()
{
  DBUG_ENTER(""Item_in_subselect::fix_length_and_dec"");
  init_length_and_dec();
  /*
    Unlike Item_exists_subselect, LIMIT 1 is set later for
    Item_in_subselect, depending on the chosen strategy.
  */
  DBUG_RETURN(FALSE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,107361013647640704192144439648376509393,10,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_union_engine::print(String *str, enum_query_type query_type)
{
  unit->print(str, query_type);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,306137328770367781054647259291277443170,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::setup_mat_engine()
{
  subselect_hash_sj_engine       *mat_engine= NULL;
  subselect_single_select_engine *select_engine;

  DBUG_ENTER(""Item_in_subselect::setup_mat_engine"");
  DBUG_ASSERT(thd);

  /*
    The select_engine (that executes transformed IN=>EXISTS subselects) is
    pre-created at parse time, and is stored in statement memory (preserved
    across PS executions).
  */
  DBUG_ASSERT(engine->engine_type() == subselect_engine::SINGLE_SELECT_ENGINE);
  select_engine= (subselect_single_select_engine*) engine;

  /* Create/initialize execution objects. */
  if (!(mat_engine= new subselect_hash_sj_engine(thd, this, select_engine)))
    DBUG_RETURN(TRUE);

  if (mat_engine->prepare(thd) ||
      mat_engine->init(&select_engine->join->fields_list,
                       engine->get_identifier()))
    DBUG_RETURN(TRUE);

  engine= mat_engine;
  DBUG_RETURN(FALSE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,270115597357102821288505140152550993332,28,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"table_map subselect_single_select_engine::upper_select_const_tables()
{
  return calc_const_tables(select_lex->outer_select()->leaf_tables);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,294391450682721072269701626996700686769,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_uniquesubquery_engine::~subselect_uniquesubquery_engine()
{
  /* Tell handler we don't need the index anymore */
  //psergey-merge-todo: the following was gone in 6.0:
 //psergey-merge: don't need this after all: tab->table->file->ha_index_end();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,93218377468050880711309229818303029418,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item_in_subselect::create_single_in_to_exists_cond(JOIN *join,
                                                   Item **where_item,
                                                   Item **having_item)
{
  SELECT_LEX *select_lex= join->select_lex;
  DBUG_ASSERT(thd == join->thd);
  /*
    The non-transformed HAVING clause of 'join' may be stored in two ways
    during JOIN::optimize: this->tmp_having= this->having; this->having= 0;
  */
  Item* join_having= join->having ? join->having : join->tmp_having;
  DBUG_ENTER(""Item_in_subselect::create_single_in_to_exists_cond"");

  *where_item= NULL;
  *having_item= NULL;

  if (join_having || select_lex->with_sum_func ||
      select_lex->group_list.elements)
  {
    Item *item= func->create(thd, expr,
                             new (thd->mem_root) Item_ref_null_helper(
                                                      thd,
                                                      &select_lex->context,
                                                      this,
                                                      &select_lex->
                                                      ref_pointer_array[0],  
                                                      (char *)""<ref>"",
                                                      this->full_name()));
    if (!abort_on_null && left_expr->maybe_null)
    {
      /* 
        We can encounter ""NULL IN (SELECT ...)"". Wrap the added condition
        within a trig_cond.
      */
      disable_cond_guard_for_const_null_left_expr(0);
      item= new (thd->mem_root) Item_func_trig_cond(thd, item, get_cond_guard(0));
    }

    if (!join_having)
      item->name= (char*) in_having_cond;
    if (fix_having(item, select_lex))
      DBUG_RETURN(true);
    *having_item= item;
  }
  else
  {
    /*
      No need to use real_item for the item, as the ref items that are possible
      in the subquery either belong to views or to the parent select.
      For such case we need to refer to the reference and not to the original
      item.
    */
    Item *item= (Item*) select_lex->item_list.head();

    if (select_lex->table_list.elements ||
        !(select_lex->master_unit()->is_union()))
    {
      Item *having= item;
      Item *orig_item= item;
       
      item= func->create(thd, expr, item);
      if (!abort_on_null && orig_item->maybe_null)
      {
	having= new (thd->mem_root) Item_is_not_null_test(thd, this, having);
        if (left_expr->maybe_null)
        {
          disable_cond_guard_for_const_null_left_expr(0);
          if (!(having= new (thd->mem_root) Item_func_trig_cond(thd, having,
                                                            get_cond_guard(0))))
            DBUG_RETURN(true);
        }
        having->name= (char*) in_having_cond;
        if (fix_having(having, select_lex))
          DBUG_RETURN(true);
        *having_item= having;

	item= new (thd->mem_root) Item_cond_or(thd, item,
                               new (thd->mem_root) Item_func_isnull(thd, orig_item));
      }
      /* 
        If we may encounter NULL IN (SELECT ...) and care whether subquery
        result is NULL or FALSE, wrap condition in a trig_cond.
      */
      if (!abort_on_null && left_expr->maybe_null)
      {
        disable_cond_guard_for_const_null_left_expr(0);
        if (!(item= new (thd->mem_root) Item_func_trig_cond(thd, item,
                                                            get_cond_guard(0))))
          DBUG_RETURN(true);
      }

      /*
        TODO: figure out why the following is done here in 
        single_value_transformer but there is no corresponding action in
        row_value_transformer?
      */
      item->name= (char *) in_additional_cond;
      if (!item->fixed && item->fix_fields(thd, 0))
        DBUG_RETURN(true);
      *where_item= item;
    }
    else
    {
      DBUG_ASSERT(select_lex->master_unit()->is_union());

      Item *new_having=
        func->create(thd, expr,
                     new (thd->mem_root) Item_ref_null_helper(thd,
                                                &select_lex->context,
                                                this,
                                                &select_lex->ref_pointer_array[0],
                                                (char *)""<no matter>"",
                                                (char *)""<result>""));
      if (!abort_on_null && left_expr->maybe_null)
      {
        disable_cond_guard_for_const_null_left_expr(0);
        if (!(new_having= new (thd->mem_root) Item_func_trig_cond(thd, new_having,
                                                          get_cond_guard(0))))
          DBUG_RETURN(true);
      }

      new_having->name= (char*) in_having_cond;
      if (fix_having(new_having, select_lex))
        DBUG_RETURN(true);
      *having_item= new_having;
    }
  }

  DBUG_RETURN(false);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,325851926727089630083969921537734746845,130,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"Item *Item_subselect::get_tmp_table_item(THD *thd_arg)
{
  if (!with_sum_func && !const_item())
    return new (thd->mem_root) Item_temptable_field(thd_arg, result_field);
  return copy_or_same(thd_arg);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,79798189863190445300742019758086756012,6,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::cleanup()
{
  DBUG_ENTER(""Item_subselect::cleanup"");
  Item_result_field::cleanup();
  if (old_engine)
  {
    if (engine)
      engine->cleanup();
    engine= old_engine;
    old_engine= 0;
  }
  if (engine)
    engine->cleanup();
  reset();
  filesort_buffer.free_sort_buffer();
  my_free(sortbuffer.str);
  sortbuffer= null_lex_str;

  value_assigned= 0;
  expr_cache= 0;
  forced_const= FALSE;
  DBUG_PRINT(""info"", (""exec_counter: %d"", exec_counter));
#ifndef DBUG_OFF
  exec_counter= 0;
#endif
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,90549691497408292581411527296661524684,27,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"String *Item_in_subselect::val_str(String *str)
{
  /*
    As far as Item_in_subselect called only from Item_in_optimizer this
    method should not be used
  */
  DBUG_ASSERT(0);
  DBUG_ASSERT(fixed == 1);
  if (forced_const)
    goto value_is_ready;
  DBUG_ASSERT((engine->uncacheable() & ~UNCACHEABLE_EXPLAIN) ||
              ! engine->is_executed());
  null_value= was_null= FALSE;
  if (exec())
  {
    reset();
    return 0;
  }
  if (was_null && !value)
  {
    null_value= TRUE;
    return 0;
  }
value_is_ready:
  str->set((ulonglong)value, &my_charset_bin);
  return str;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,213504011889411798922268976582824333912,27,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"subselect_hash_sj_engine::get_strategy_using_schema()
{
  Item_in_subselect *item_in= (Item_in_subselect *) item;

  if (item_in->is_top_level_item())
    return COMPLETE_MATCH;
  else
  {
    List_iterator<Item> inner_col_it(*item_in->unit->get_column_types(false));
    Item *outer_col, *inner_col;

    for (uint i= 0; i < item_in->left_expr->cols(); i++)
    {
      outer_col= item_in->left_expr->element_index(i);
      inner_col= inner_col_it++;

      if (!inner_col->maybe_null && !outer_col->maybe_null)
        bitmap_set_bit(&non_null_key_parts, i);
      else
      {
        bitmap_set_bit(&partial_match_key_parts, i);
        ++count_partial_match_columns;
      }
    }
  }

  /* If no column contains NULLs use regular hash index lookups. */
  if (count_partial_match_columns)
    return PARTIAL_MATCH;
  return COMPLETE_MATCH;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,300776903073680387729599303256225077939,31,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_engine::set_row(List<Item> &item_list, Item_cache **row)
{
  Item *sel_item;
  List_iterator_fast<Item> li(item_list);
  cmp_type= res_type= STRING_RESULT;
  res_field_type= MYSQL_TYPE_VAR_STRING;
  for (uint i= 0; (sel_item= li++); i++)
  {
    item->max_length= sel_item->max_length;
    res_type= sel_item->result_type();
    cmp_type= sel_item->cmp_type();
    res_field_type= sel_item->field_type();
    item->decimals= sel_item->decimals;
    item->unsigned_flag= sel_item->unsigned_flag;
    maybe_null= sel_item->maybe_null;
    if (!(row[i]= Item_cache::get_cache(thd, sel_item, sel_item->cmp_type())))
      return TRUE;
    row[i]->setup(thd, sel_item);
 //psergey-backport-timours:   row[i]->store(sel_item);
  }
  if (item_list.elements > 1)
    cmp_type= res_type= ROW_RESULT;
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,287503268653369432580072951059907285824,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_single_select_engine::exclude()
{
  select_lex->master_unit()->exclude_level();
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,298650488775161257828315893492639017126,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void subselect_hash_sj_engine::exclude()
{
  DBUG_ASSERT(FALSE);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,171403982710115357454912298022258606328,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"static bool check_equality_for_exist2in(Item_func *func,
                                        bool allow_subselect,
                                        Item_ident **local_field,
                                        Item **outer_exp)
{
  Item **args;
  if (func->functype() != Item_func::EQ_FUNC)
    return FALSE;
  DBUG_ASSERT(func->argument_count() == 2);
  args= func->arguments();
  if (args[0]->real_type() == Item::FIELD_ITEM &&
      args[0]->all_used_tables() != OUTER_REF_TABLE_BIT &&
      args[1]->all_used_tables() == OUTER_REF_TABLE_BIT &&
      (allow_subselect || !args[1]->has_subquery()))
  {
    /* It is Item_field or Item_direct_view_ref) */
    DBUG_ASSERT(args[0]->type() == Item::FIELD_ITEM ||
                args[0]->type() == Item::REF_ITEM);
    *local_field= (Item_ident *)args[0];
    *outer_exp= args[1];
    return TRUE;
  }
  else if (args[1]->real_type() == Item::FIELD_ITEM &&
           args[1]->all_used_tables() != OUTER_REF_TABLE_BIT &&
           args[0]->all_used_tables() == OUTER_REF_TABLE_BIT &&
           (allow_subselect || !args[0]->has_subquery()))
  {
    /* It is Item_field or Item_direct_view_ref) */
    DBUG_ASSERT(args[1]->type() == Item::FIELD_ITEM ||
                args[1]->type() == Item::REF_ITEM);
    *local_field= (Item_ident *)args[1];
    *outer_exp= args[0];
    return TRUE;
  }

  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,259606125574668190233892225152873133789,37,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Ordered_key::init(int col_idx)
{
  THD *thd= tbl->in_use;

  key_column_count= 1;

  // TIMOUR: check for mem allocation err, revert to scan

  key_columns= (Item_field**) thd->alloc(sizeof(Item_field*));
  compare_pred= (Item_func_lt**) thd->alloc(sizeof(Item_func_lt*));

  key_columns[0]= new (thd->mem_root) Item_field(thd, tbl->field[col_idx]);
  /* Create the predicate (tmp_column[i] < outer_ref[i]). */
  compare_pred[0]= new (thd->mem_root) Item_func_lt(thd, key_columns[0],
                                    search_key->element_index(col_idx));
  compare_pred[0]->fix_fields(thd, (Item**)&compare_pred[0]);

  if (alloc_keys_buffers())
  {
    /* TIMOUR revert to partial match via table scan. */
    return TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,14075696517190187649646096017149827020,24,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"my_decimal *Item_exists_subselect::val_decimal(my_decimal *decimal_value)
{
  DBUG_ASSERT(fixed == 1);
  if (!forced_const && exec())
    reset();
  int2my_decimal(E_DEC_FATAL_ERROR, value, 0, decimal_value);
  return decimal_value;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,193050391931447564752817866701842183336,8,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_subselect::init(st_select_lex *select_lex,
			  select_result_interceptor *result)
{
  /*
    Please see Item_singlerow_subselect::invalidate_and_restore_select_lex(),
    which depends on alterations to the parse tree implemented here.
  */

  DBUG_ENTER(""Item_subselect::init"");
  DBUG_PRINT(""enter"", (""select_lex: %p  this: %p"",
                       select_lex, this));
  unit= select_lex->master_unit();

  if (unit->item)
  {
    engine= unit->item->engine;
    parsing_place= unit->item->parsing_place;
    if (unit->item->substype() == EXISTS_SUBS &&
        ((Item_exists_subselect *)unit->item)->exists_transformed)
    {
      /* it is permanent transformation of EXISTS to IN */
      unit->item= this;
      engine->change_result(this, result, FALSE);
    }
    else
    {
      /*
        Item can be changed in JOIN::prepare while engine in JOIN::optimize
        => we do not copy old_engine here
      */
      unit->thd->change_item_tree((Item**)&unit->item, this);
      engine->change_result(this, result, TRUE);
    }
  }
  else
  {
    SELECT_LEX *outer_select= unit->outer_select();
    /*
      do not take into account expression inside aggregate functions because
      they can access original table fields
    */
    parsing_place= (outer_select->in_sum_expr ? NO_MATTER
                                              : outer_select->parsing_place);
    if (unit->is_union())
      engine= new subselect_union_engine(unit, result, this);
    else
      engine= new subselect_single_select_engine(select_lex, result, this);
  }
  {
    SELECT_LEX *upper= unit->outer_select();
    if (upper->parsing_place == IN_HAVING)
      upper->subquery_in_having= 1;
    /* The subquery is an expression cache candidate */
    upper->expr_cache_may_be_used[upper->parsing_place]= TRUE;
  }
  DBUG_PRINT(""info"", (""engine: %p"", engine));
  DBUG_VOID_RETURN;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,31085681342914664110481291683071495776,58,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"String *Item_exists_subselect::val_str(String *str)
{
  DBUG_ASSERT(fixed == 1);
  if (!forced_const && exec())
    reset();
  str->set((ulonglong)value,&my_charset_bin);
  return str;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,104529142844641531300697570646973447355,8,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_hash_sj_engine::prepare(THD *thd_arg)
{
  /*
    Create and optimize the JOIN that will be used to materialize
    the subquery if not yet created.
  */
  set_thd(thd_arg);
  return materialize_engine->prepare(thd);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,231988807110041543314258684490313409530,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_union_engine::prepare(THD *thd_arg)
{
  set_thd(thd_arg);
  return unit->prepare(thd, result, SELECT_NO_UNLOCK);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,291247266886597731599046975162699288908,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_in_subselect::init_cond_guards()
{
  DBUG_ASSERT(thd);
  uint cols_num= left_expr->cols();
  if (!abort_on_null && !pushed_cond_guards &&
      (left_expr->maybe_null || cols_num > 1))
  {
    if (!(pushed_cond_guards= (bool*)thd->alloc(sizeof(bool) * cols_num)))
        return TRUE;
    for (uint i= 0; i < cols_num; i++)
      pushed_cond_guards[i]= TRUE;
  }
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,40565408371415475036303817720766932248,14,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_single_select_engine::prepare(THD *thd)
{
  if (prepared)
    return 0;
  set_thd(thd);
  if (select_lex->join)
  {
    select_lex->cleanup();
  }
  join= new JOIN(thd, select_lex->item_list,
		 select_lex->options | SELECT_NO_UNLOCK, result);
  if (!join || !result)
    return 1; /* Fatal error is set already. */
  prepared= 1;
  SELECT_LEX *save_select= thd->lex->current_select;
  thd->lex->current_select= select_lex;
  if (join->prepare(select_lex->table_list.first,
		    select_lex->with_wild,
		    select_lex->where,
		    select_lex->order_list.elements +
		    select_lex->group_list.elements,
		    select_lex->order_list.first,
                    false,
		    select_lex->group_list.first,
		    select_lex->having,
		    NULL, select_lex,
		    select_lex->master_unit()))
    return 1;
  thd->lex->current_select= save_select;
  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,80911771373531728255803634151769476458,31,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_hash_sj_engine::fix_length_and_dec(Item_cache** row)
{
  DBUG_ASSERT(FALSE);
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,129199037300606649756119471511755316181,5,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_rowid_merge_engine::test_null_row(rownum_t row_num)
{
  Ordered_key *cur_key;
  for (uint i = 0; i < merge_keys_count; i++)
  {
    cur_key= merge_keys[i];
    if (bitmap_is_set(&matching_keys, cur_key->get_keyid()))
    {
      /*
        The key 'i' (with id 'cur_keyid') already matches a value in row
        'row_num', thus we skip it as it can't possibly match a NULL.
      */
      continue;
    }
    if (!cur_key->is_null(row_num))
      return FALSE;
  }
  return TRUE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,141467560062996986575550724035605753300,19,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_partial_match_engine::exec()
{
  Item_in_subselect *item_in= (Item_in_subselect *) item;
  int lookup_res;

  DBUG_ASSERT(!(item_in->left_expr_has_null() &&
                item_in->is_top_level_item()));

  if (!item_in->left_expr_has_null())
  {
    /* Try to find a matching row by index lookup. */
    if (lookup_engine->copy_ref_key(false))
    {
      /* The result is FALSE based on the outer reference. */
      item_in->value= 0;
      item_in->null_value= 0;
      return 0;
    }
    else
    {
      /* Search for a complete match. */
      if ((lookup_res= lookup_engine->index_lookup()))
      {
        /* An error occurred during lookup(). */
        item_in->value= 0;
        item_in->null_value= 0;
        return lookup_res;
      }
      else if (item_in->value || !count_columns_with_nulls)
      {
        /*
          A complete match was found, the result of IN is TRUE.
          If no match was found, and there are no NULLs in the materialized
          subquery, then the result is guaranteed to be false because this
          branch is executed when the outer reference has no NULLs as well.
          Notice: (this->item == lookup_engine->item)
        */
        return 0;
      }
    }
  }

  if (has_covering_null_row)
  {
    /*
      If there is a NULL-only row that covers all columns the result of IN
      is UNKNOWN. 
    */
    item_in->value= 0;
    /*
      TIMOUR: which one is the right way to propagate an UNKNOWN result?
      Should we also set empty_result_set= FALSE; ???
    */
    //item_in->was_null= 1;
    item_in->null_value= 1;
    return 0;
  }

  /*
    There is no complete match. Look for a partial match (UNKNOWN result), or
    no match (FALSE).
  */
  if (tmp_table->file->inited)
    tmp_table->file->ha_index_end();

  if (partial_match())
  {
    /* The result of IN is UNKNOWN. */
    item_in->value= 0;
    /*
      TIMOUR: which one is the right way to propagate an UNKNOWN result?
      Should we also set empty_result_set= FALSE; ???
    */
    //item_in->was_null= 1;
    item_in->null_value= 1;
  }
  else
  {
    /* The result of IN is FALSE. */
    item_in->value= 0;
    /*
      TIMOUR: which one is the right way to propagate an UNKNOWN result?
      Should we also set empty_result_set= FALSE; ???
    */
    //item_in->was_null= 0;
    item_in->null_value= 0;
  }

  return 0;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,105259134004887937254304826356037138092,90,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"void Item_allany_subselect::print(String *str, enum_query_type query_type)
{
  if (test_strategy(SUBS_IN_TO_EXISTS))
    str->append(STRING_WITH_LEN(""<exists>""));
  else
  {
    left_expr->print(str, query_type);
    str->append(' ');
    str->append(func->symbol(all));
    str->append(all ? "" all "" : "" any "", 5);
  }
  Item_subselect::print(str, query_type);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,23807505486623908549818723977976642718,13,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Ordered_key::lookup()
{
  DBUG_ASSERT(key_buff_elements);

  ha_rows lo= 0;
  ha_rows hi= key_buff_elements - 1;
  ha_rows mid;
  int cmp_res;

  while (lo <= hi)
  {
    mid= lo + (hi - lo) / 2;
    cmp_res= cmp_key_with_search_key(key_buff[mid]);
    /*
      In order to find the minimum match, check if the pevious element is
      equal or smaller than the found one. If equal, we need to search further
      to the left.
    */
    if (!cmp_res && mid > 0)
      cmp_res= !cmp_key_with_search_key(key_buff[mid - 1]) ? 1 : 0;

    if (cmp_res == -1)
    {
      /* row[mid] < search_key */
      lo= mid + 1;
    }
    else if (cmp_res == 1)
    {
      /* row[mid] > search_key */
      if (!mid)
        goto not_found;
      hi= mid - 1;
    }
    else
    {
      /* row[mid] == search_key */
      cur_key_idx= mid;
      return TRUE;
    }
  }
not_found:
  cur_key_idx= HA_POS_ERROR;
  return FALSE;
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,187755591002085108221793682995479188888,44,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool subselect_single_select_engine::no_tables()
{
  return(select_lex->table_list.elements == 0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,88066399100507077632208124056134056451,4,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"bool Item_subselect::expr_cache_is_needed(THD *thd)
{
  return ((engine->uncacheable() & UNCACHEABLE_DEPENDENT) &&
          engine->cols() == 1 &&
          optimizer_flag(thd, OPTIMIZER_SWITCH_SUBQUERY_CACHE) &&
          !(engine->uncacheable() & (UNCACHEABLE_RAND |
                                     UNCACHEABLE_SIDEEFFECT)) &&
          !with_recursive_reference);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,236652879103663561580904302043727531838,9,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
"int subselect_uniquesubquery_engine::scan_table()
{
  int error;
  TABLE *table= tab->table;
  DBUG_ENTER(""subselect_uniquesubquery_engine::scan_table"");

  if ((table->file->inited &&
       (error= table->file->ha_index_end())) ||
      (error= table->file->ha_rnd_init(1)))
  {
    (void) report_error(table, error);
    DBUG_RETURN(true);
  }

  table->file->extra_opt(HA_EXTRA_CACHE,
                         get_thd()->variables.read_buff_size);
  table->null_row= 0;
  for (;;)
  {
    error=table->file->ha_rnd_next(table->record[0]);
    if (error) {
      if (error == HA_ERR_RECORD_DELETED)
      {
        error= 0;
        continue;
      }
      if (error == HA_ERR_END_OF_FILE)
      {
        error= 0;
        break;
      }
      else
      {
        error= report_error(table, error);
        break;
      }
    }

    if (!cond || cond->val_int())
    {
      empty_result_set= FALSE;
      break;
    }
  }

  table->file->ha_rnd_end();
  DBUG_RETURN(error != 0);
}",0,['CWE-89'],server,3c209bfc040ddfc41ece8357d772547432353fd2,326678134008963569204569514950572676835,48,"MDEV-25994: Crash with union of my_decimal type in ORDER BY clause

When single-row subquery fails with ""Subquery reutrns more than 1 row""
error, it will raise an error and return NULL.

On the other hand, Item_singlerow_subselect sets item->maybe_null=0
for table-less subqueries like ""(SELECT not_null_value)""  (*)

This discrepancy (item with maybe_null=0 returning NULL) causes the
code in Type_handler_decimal_result::make_sort_key_part() to crash.

Fixed this by allowing inference (*) only when the subquery is NOT a
UNION."
