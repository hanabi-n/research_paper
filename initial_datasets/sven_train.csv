func,target,cwe,project,commit_id,hash,size,message
"def build_board(conn, game,size):
    # we'll build the empty board, and then fill in with the move list that
    # we get from the DB.
    board = []
    for i in range(size):
        board.append([""""]*size)


    # search for all moves that have happenend during this game.
    cursor = conn.cursor()
    cursor.execute(""SELECT x,y,letter FROM moves WHERE gameID = %d;"" % game)

    counts = {""X"":0, ""O"":0}
    for move in cursor.fetchall():
        (x,y,letter) = move

        x = int(x)
        y = int(y)
        assert x >= 0 and x < size
        assert y >= 0 and y < size

        assert letter in ""XO""

        assert board[x][y] == """"
        board[x][y] = letter

        counts[letter] += 1

    cursor.close()

    assert counts[""X""] >= counts[""O""]
    assert counts[""X""] <= counts[""O""]+1

    if counts[""X""] == counts[""O""]:
        nextPlayer = 0
    else:
        nextPlayer = 1
    letter = ""XO""[nextPlayer]

    return (board,nextPlayer,letter)",1,cwe-089,,,,,
"    def check_and_update_ranks(self, scene):
        # There are 2 cases here:
        #   1) Ranks have never been calculated for this scene before
        #       - This means we need to calculate what the ranks were every month of this scenes history
        #       - We should only do this if ranks don't already exist for this scene
        #   2) Ranks have been calculated for this scene before
        #       - We already have bulk ranks. We should check if it has been more than 1 month since we last
        #           calculated ranks. If so, calculate again with the brackets that have come out this month

        LOG.info('About to check if ranks need updating for {}'.format(scene))
        # First, do we have any ranks for this scene already?
        sql = 'select count(*) from ranks where scene=""{}"";'.format(scene)
        res = self.db.exec(sql)
        count = res[0][0]

        n = 5 if (scene == 'pro' or scene == 'pro_wiiu') else constants.TOURNAMENTS_PER_RANK
        if count == 0:
            LOG.info('Detected that we need to bulk update ranks for {}'.format(scene))
            # Alright, we have nothing. Bulk update ranks
            first_month = bracket_utils.get_first_month(self.db, scene)
            last_month = bracket_utils.get_last_month(self.db, scene)
            
            # Iterate through all tournaments going month by month, and calculate ranks
            months = bracket_utils.iter_months(first_month, last_month, include_first=False, include_last=True)
            for month in months:
                urls, _ = bracket_utils.get_n_tournaments_before_date(self.db, scene, month, n)
                self.process_ranks(scene, urls, month)
        else:

            # Get the date of the last time we calculated ranks
            sql = ""select date from ranks where scene='{}' order by date desc limit 1;"".format(scene)
            res = self.db.exec(sql)
            last_rankings_date = res[0][0]

            # Check to see if it's been more than 1 month since we last calculated ranks
            more_than_one_month = bracket_utils.has_month_passed(last_rankings_date)
            if more_than_one_month:
                # Get only the last n tournaments, so it doesn't take too long to process
                today = datetime.datetime.today().strftime('%Y-%m-%d')
                msg = 'Detected that we need up update monthly ranks for {}, on {}'.format(scene, today)
                LOG.info(msg)

                # We should only ever calculate ranks on the 1st. If today is not the first, log error
                if not today.split('-')[-1] == '1':
                    LOG.exc('We are calculating ranks today, {}, but it isnt the first'.format(today))

                months = bracket_utils.iter_months(last_rankings_date, today, include_first=False, include_last=True)
                for month in months:
                    # Make sure that we actually have matches during this month
                    # Say we are trying to calculate ranks for 2018-05-01, the player would need to have matches during 2018-04-01, 2018-04-30
                    prev_date = bracket_utils.get_previous_month(month)
                    brackets_during_month = bracket_utils.get_tournaments_during_month(self.db, scene, prev_date)

                    if len(brackets_during_month) > 0:
                        tweet('Calculating {} ranks for {}'.format(month, scene))
                        urls, _ = bracket_utils.get_n_tournaments_before_date(self.db, scene, month, n)
                        self.process_ranks(scene, urls, month)

            else:
                LOG.info('It has not yet been 1 month since we calculated ranks for {}. Skipping'.format(scene))",1,cwe-089,,,,,
"    def tag_num_to_tag(self, tag_num):
        ''' Returns tag given tag_num. '''

        q = ""SELECT tag FROM tags WHERE rowid = '"" + str(tag_num) + ""'""
        self.query(q)
        return self.c.fetchone()[0]",1,cwe-089,,,,,
"@api.route('/items/<int:item_id>', methods=['GET'])
def get_item(item_id):
    sql = '''SELECT id, name_enus FROM tblDBCItem WHERE id = {} AND auctionable = true;'''.format(item_id)
    cursor = mysql.connection.cursor()
    cursor.execute(sql)
    data = cursor.fetchone()

    if data:
        item = {}
        for tup in zip([column[0] for column in cursor.description], data):
            item[tup[0]] = tup[1]
    else:
        return jsonify({""error"": ""item not found""}), 404

    return jsonify(item)",1,cwe-089,,,,,
"    def getPostsByPostid(self,postid):
        sqlText=""select users.name,post.comment from users,post where \
                users.userid=post.userid and post.postid=%d""%(postid)
        result=sql.queryDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"	def getFileCacheID(self, pth):
		""""""
		Returns ID of a cached file on Telegram from DB. None if file doesn't exist or has no cached ID.
		:param pth:
		:return:
		""""""
		command = ""SELECT file_id FROM {0} WHERE path='{1}'"".format(TABLE_NAME, pth)
		data = self._run_command(command)

		try:
			data = data[0][0]
		except IndexError:
			data = None

		return data",1,cwe-089,,,,,
"def add_post(content):
  """"""Add a post to the 'database' with the current timestamp.""""""
  db = psycopg2.connect(database=DBNAME)
  c = db.cursor()
  c.execute(""insert into posts values('%s')"" % content)
  db.commit()
  db.close()",1,cwe-089,,,,,
"def getSubmissionDateFromDatabase(submission):
    database = sqlite3.connect('database.db')
    cursor = database.cursor()
    return cursor.execute(""SELECT Date FROM ChallengeRankings WHERE SubmissionID = '"" + str(submission.id) + ""'"").fetchone()[0]
    database.close()",1,cwe-089,,,,,
"@endpoints.route(""/ranks"")
def ranks():
    if db == None:
        init()

    scene = request.args.get('scene', default='austin')
    date = request.args.get('date')
 
    # If no date was provided, pick the date of the latest tournament
    if date == None:
        sql = ""SELECT distinct date FROM ranks WHERE scene='{}' ORDER BY date DESC LIMIT 1;"".format(scene)
        res = db.exec(sql)
        date = res[0][0]

    # Get all the urls that this player has participated in
    sql = ""SELECT * FROM ranks WHERE scene = '{}' and date='{}'"".format(scene, date)
    res = db.exec(sql)

    # Make a dict out of this data
    # eg {'christmasmike': 50}
    cur_ranks = {}
    for r in res:
        tag = r[1]
        rank = r[2]

        cur_ranks[tag] = rank

    # Now get the ranks from last month, so we know if these players went up or down
    y, m, d = date.split('-')
    prev_date = bracket_utils.get_previous_month(date)

    # Get all the urls that this player has participated in
    sql = ""SELECT * FROM ranks WHERE scene = '{}' and date='{}'"".format(scene, prev_date)
    res = db.exec(sql)

    # Make a dict out of this data
    # eg {'christmasmike': 50}
    prev_ranks = {}
    for r in res:
        tag = r[1]
        rank = r[2]

        prev_ranks[tag] = rank

    return render_template('libraries/html/ranks.html', cur_ranks=cur_ranks, prev_ranks=prev_ranks, scene=scene, date=date)",1,cwe-089,,,,,
"    def set_language(self, lang):
        """"""
        Update language of user in the User object and in the database
        :param lang: string with language tag like ""en-US""
        :return: None
        """"""
        log.debug('Updating info about user %s language '
                  'in memory & database...', self)

        self.language = lang

        query = (""UPDATE users ""
                 f""SET language='{self.language}' ""
                 f""WHERE chat_id='{self.chat_id}'"")

        try:
            db.add(query)
        except DatabaseError:
            log.error(""Can't add new language of %s to the database"", self)
        else:
            log.debug('Language updated.')",1,cwe-089,,,,,
"    def tid_num_to_tag_nums(self, tid_num):
        ''' Returns list of the associated tag_nums to the given tid_num. '''

        q = ""SELECT tag FROM tid_tag WHERE tid = '"" + str(tid_num) + ""'""
        self.query(q)
        return [i[0] for i in self.c.fetchall()]",1,cwe-089,,,,,
"@app.route('/summary', methods=['GET'])
def summary():
	if 'username' in session:

		conn = mysql.connect()
		cursor = conn.cursor()

		#select the maximum score from the results table
		cursor.execute(""SELECT courseConcentration FROM results WHERE total = (SELECT MAX(total) FROM (SELECT * FROM results WHERE courseId > 4) Temp) and courseId > 4 and emailAccount='"" + session['username'] + ""'"");
		courseConcentration = cursor.fetchone()

		return render_template('summary.html', courseConcentration = courseConcentration[0])
	return redirect(url_for('login'))",1,cwe-089,,,,,
"def add_post(content):
  """"""Add a post to the 'database' with the current timestamp.""""""
  conn = psycopg2.connect(""dbname=forum"")
  cursor = conn.cursor()
  cursor.execute(""insert into posts values ('%s')"" % content)
  conn.commit()
  conn.close()",1,cwe-089,,,,,
"def delete_playlist(id, db):
    db.execute(""DELETE FROM playlist where id={id};"".format(id=id))",1,cwe-089,,,,,
"    def writeToDb(self, url):
        try:
            self.cursor.execute(""INSERT INTO queue (url, visited) VALUES ('{}', '0');"".format(url))
            self.db.commit()
        except Exception as e:
            print(e)",1,cwe-089,,,,,
"@frappe.whitelist(allow_guest=True)
def send_message(subject=""Website Query"", message="""", sender="""", status=""Open""):
	from frappe.www.contact import send_message as website_send_message
	lead = customer = None

	website_send_message(subject, message, sender)

	customer = frappe.db.sql(""""""select distinct dl.link_name from `tabDynamic Link` dl
		left join `tabContact` c on dl.parent=c.name where dl.link_doctype='Customer'
		and c.email_id='{email_id}'"""""".format(email_id=sender))

	if not customer:
		lead = frappe.db.get_value('Lead', dict(email_id=sender))
		if not lead:
			new_lead = frappe.get_doc(dict(
				doctype='Lead',
				email_id = sender,
				lead_name = sender.split('@')[0].title()
			)).insert(ignore_permissions=True)

	opportunity = frappe.get_doc(dict(
		doctype ='Opportunity',
		enquiry_from = 'Customer' if customer else 'Lead',
		status = 'Open',
		title = subject,
		contact_email = sender,
		to_discuss = message
	))

	if customer:
		opportunity.customer = customer[0][0]
	elif lead:
		opportunity.lead = lead
	else:
		opportunity.lead = new_lead.name

	opportunity.insert(ignore_permissions=True)

	comm = frappe.get_doc({
		""doctype"":""Communication"",
		""subject"": subject,
		""content"": message,
		""sender"": sender,
		""sent_or_received"": ""Received"",
		'reference_doctype': 'Opportunity',
		'reference_name': opportunity.name
	})
	comm.insert(ignore_permissions=True)

	return ""okay""",1,cwe-089,,,,,
"    @jwt_required
    def delete(self, email):
        """""" Deletes admin with the corresponding email """"""
        return database_utilities.execute_query(f""""""delete from admins where email = '{email}'"""""")",1,cwe-089,,,,,
"def delete_playlists_videos(playlist_id, db):
    db.execute(""DELETE FROM video where playlist_id={playlist_id};"".format(
        playlist_id=playlist_id))",1,cwe-089,,,,,
"    @staticmethod
    def upsert_mapped_projects(user_id: int, project_id: int):
        """""" Adds projects to mapped_projects if it doesn't exist """"""
        sql = ""select * from users where id = {0} and projects_mapped @> '{{{1}}}'"".format(user_id, project_id)
        result = db.engine.execute(sql)

        if result.rowcount > 0:
            return  # User has previously mapped this project so return

        sql = '''update users
                    set projects_mapped = array_append(projects_mapped, {0})
                  where id = {1}'''.format(project_id, user_id)

        db.engine.execute(sql)",1,cwe-089,,,,,
"def get_first_ranked_month(db, scene, player):
    sql = ""select date from ranks where scene='{}' and player='{}' order by date limit 1;"".format(scene, player)
    res = db.exec(sql)
    date = res[0][0]
    return date",1,cwe-089,,,,,
"@hook.command(adminonly=True)
def openPoll(question, reply=None, db=None):
    """"""Creates a new poll.""""""
    if not db_ready: db_init(db)
    try:
        active = db.execute(""SELECT pollID FROM polls WHERE active = 1"").fetchone()[0]
        if active: 
            reply(""There already is an open poll."")
            return
    except:
        db.execute(""INSERT INTO polls (question, active) VALUES ('{}', 1)"".format(question))
        reply(""Opened new poll: {}"".format(question))
        #reply(""Poll opened!"")
    return",1,cwe-089,,,,,
"        def view_grocery_list():
            print(""grocery== list"")
            groceryListFrame = Frame(self)
            groceryListFrame.rowconfigure(0, weight=1)
            groceryListFrame.columnconfigure(0, weight=1)
            groceryListFrame.rowconfigure(1, weight=3)
            groceryListFrame.columnconfigure(1, weight=3)
            groceryListFrame.pack()

            menu.pack_forget()
            groceryButton.pack_forget()
            label.configure(text=""Grocery List"")

            i = 0
            database_file = ""meal_planner.db""
            item_array = []
            with sqlite3.connect(database_file) as conn:
                cursor = conn.cursor()
                tableName = ""ingredients_"" + str(weekNumber)
                selection = cursor.execute(""""""SELECT * FROM """""" + tableName)
                for result in [selection]:
                    for row in result.fetchall():
                        print(row)
                        for ingredient in row:
                            print(ingredient)
                            item_array.append(str(ingredient).split())
                        i = i +1
                        Label(groceryListFrame, text=ingredient, font=MEDIUM_FONT, justify=LEFT).grid(row=i, column=0, sticky=""w"")
            

            j = 0
            for item in item_array:
                print(item)


            returnButton = Button(menuFrame, text = ""Return to Menu"", highlightbackground=""#e7e7e7"", command=lambda: [groceryListFrame.pack_forget(),
                                                                                     menu.pack(), returnButton.pack_forget(), label.configure(text=""Meal Planer""),
                                                                                    groceryButton.pack(side=RIGHT)])
            returnButton.pack(side=RIGHT)",1,cwe-089,,,,,
"@app.route('/<page_name>/history/record')
def view_page_record(page_name):
    content_id = request.args.get('id')
    query = db.query(""select page_content.content, page_content.timestamp from page, page_content where page.id = page_content.page_id and page_content.id = '%s'"" % content_id)
    page_record = query.namedresult()[0]

    return render_template(
        'page_record.html',
        page_name = page_name,
        page_record = page_record
    )",1,cwe-089,,,,,
"    def update_inverter(self, inverter_serial, ts, status, etoday, etotal):
        query = '''
            UPDATE Inverters
            SET     
                TimeStamp='%s', 
                Status='%s', 
                eToday='%s',
                eTotal='%s'
            WHERE Serial='%s';
        ''' % (ts, status, etoday, etotal, inverter_serial)
        self.c.execute(query)",1,cwe-089,,,,,
"def insert(key, value):
    connection = psycopg2.connect(host=config['HOST'], port=config['PORT'], database=config['NAME'], user=config['USER'], password=config['PASSWORD'])
    cur = connection.cursor()
    try:
        cur.execute(""insert into reply_map values('{}', '{}')"".format(key, value))
        connection.commit()
    except:
        pass",1,cwe-089,,,,,
"    def save_failure_transaction(self, user_id, project_id, money):
        self.cursor.execute(""insert into transactions (project_id,user_id, money, timestamp, state) values (%s, %s, %s, now(), 'failed' )"" % (project_id, user_id, money))
        self.db.commit()",1,cwe-089,,,,,
"    @unpack
    def test_process_as_form(self, job_number, dcn_key, was_prev_matched,
            was_prev_closed, was_prev_tracked):
        email_obj = {
            'sender' : ""Alex Roy <Alex.Roy@dilfo.com>"",
            'subject' : ""DO NOT MODIFY MESSAGE BELOW - JUST HIT `SEND`"",
            'date' : ""Tue, 7 May 2019 17:34:17 +0000"",
            'content' : (
                f""job_number={job_number}&title=TEST_ENTRY&city=Ottawa&""
                f""address=2562+Del+Zotto+Ave.%2C+Ottawa%2C+Ontario&""
                f""contractor=GCN&engineer=Goodkey&owner=Douglas+Stalker&""
                f""quality=2&cc_email=&link_to_cert={dcn_key}\r\n""
            )
        }
        # set-up new entries in db, if necessary
        fake_dilfo_insert = """"""
            INSERT INTO df_dilfo (job_number, receiver_email, closed)
            VALUES ({}, 'alex.roy616@gmail.com', {})
        """"""
        fake_match_insert = """"""
            INSERT INTO df_matched (job_number, verifier, ground_truth)
            VALUES ({}, 'alex.roy616@gmail.com', {})
        """"""
        with create_connection() as conn:
            if was_prev_closed or was_prev_tracked:
                conn.cursor().execute(fake_dilfo_insert.format(job_number, was_prev_closed))
            if was_prev_matched:
                if was_prev_closed:
                    conn.cursor().execute(fake_match_insert.format(job_number, 1))
                else:
                    conn.cursor().execute(fake_match_insert.format(job_number, 0))
        with create_connection() as conn:
            df_dilfo_pre = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn)
            df_matched_pre = pd.read_sql(f""SELECT * FROM df_matched WHERE job_number={job_number}"", conn)
        process_as_form(email_obj)
        # make assertions about db now that reply has been processed
        with create_connection() as conn:
            df_dilfo_post = pd.read_sql(f""SELECT * FROM df_dilfo WHERE job_number={job_number}"", conn)
            df_matched_post = pd.read_sql(f""SELECT * FROM df_matched WHERE job_number={job_number}"", conn)
        self.assertEqual(len(df_dilfo_post), 1)
        self.assertEqual(bool(df_dilfo_post.iloc[0].closed), bool(was_prev_closed or dcn_key))
        self.assertEqual(any(df_matched_post.ground_truth), bool(was_prev_closed or dcn_key))
        self.assertEqual(len(df_matched_pre) + bool(dcn_key and not(was_prev_closed)), len(df_matched_post))
        self.assertEqual(list(df_matched_pre.columns), list(df_matched_post.columns))
        self.assertEqual(list(df_dilfo_pre.columns), list(df_dilfo_post.columns))",1,cwe-089,,,,,
"@app.route('/<page_name>')
def render_page_name(page_name):
    query = db.query(""select page_content.content, page.id as page_id, page_content.id as content_id from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1"" % page_name)
    wiki_page = query.namedresult()
    has_content = False
    page_is_taken = False
    if len(wiki_page) < 1:
        content = """"
    else:
        page_is_taken = True
        content = wiki_page[0].content
    if len(content) > 0:
        has_content = True
    else:
        pass
    content = markdown.markdown(wiki_linkify(content))
    return render_template(
        'pageholder.html',
        page_is_taken = page_is_taken,
        page_name = page_name,
        markdown = markdown,
        wiki_linkify = wiki_linkify,
        has_content = has_content,
        content = content
    )",1,cwe-089,,,,,
"    def tid_to_tid_num(self, tid):
        ''' Returns tid_num, given tid. '''

        q = ""SELECT rowid FROM tids WHERE tid = '"" + tid + ""'""
        self.query(q)
        return self.c.fetchone()[0]",1,cwe-089,,,,,
"def get_old_sourcebyinstitution_number(conn, sqlite, sourcebyinstitution):
    """"""
    Get all the old sourcebyinstitution number from the SQLite database.
    """"""
    query = """"""
        SELECT
            titles
        FROM
            history
        WHERE
            sourcebyinstitution = ""%s""
        ORDER BY
            titles DESC
        LIMIT 1
    """""" % sourcebyinstitution

    sqlite.execute(query)
    for record in sqlite:
        old_sourcebyinstitution_number = record[0]
        return old_sourcebyinstitution_number",1,cwe-089,,,,,
"def top_karma(bot, trigger):
    """"""
    Show karma status for the top n number of IRC users.
    """"""
    try:
        top_limit = int(trigger.group(2).strip())
    except ValueError:
        top_limit = 5

    query = ""SELECT slug, value FROM nick_values NATURAL JOIN nicknames \
        WHERE key = 'karma' ORDER BY value DESC LIMIT %d""
    karmalist = bot.db.execute(query % top_limit).fetchall()
    for user in karmalist:
        bot.say(""%s == %s"" % (user[0], user[1]))",1,cwe-089,,,,,
"def retrieve_playlist_by_id(id, db):
    db.execute(
        ""SELECT id, name, video_position from playlist WHERE id={id};"".format(id=id))
    row = db.fetchone()
    return row",1,cwe-089,,,,,
"@bot.message_handler(func = lambda message: get_current_state(message.chat.id) == config.States.S_GET_TASK.value)
def get_task(message):
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\settings.db"")
    conn = settings.cursor()
    conn.execute(""select * from users where chat_id = '"" + str(message.chat.id) + ""'"")
    name = conn.fetchone()
    settings.close()
    if name == None:
        bot.send_message(message.chat.id, ""You should login before get tasks."")
    else:
        bases.update.update_user(name[1], name[0], name[2])
        bot.send_message(message.chat.id, bases.problem.get_unsolved_problem(message.text, name[1]))
    set_state(message.chat.id, config.States.S_START.value)",1,cwe-089,,,,,
"@bot.message_handler(commands=['stats'])
def stats(message):
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\settings.db"")
    conn = settings.cursor()
    conn.execute(""select * from users where chat_id = '"" + str(message.chat.id) + ""'"")
    name = conn.fetchone()
    settings.close()
    if name != None:
        bases.update.update_user(name[1], name[0], name[2])
        bases.problem.create_text_stats(name[1])
        img = open(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\users\\"" + name[1] + "".png"", ""rb"")
        bot.send_photo(message.chat.id, img)
        img.close()
        if bases.problem.create_stats_picture(name[1]):
            bot.send_message(message.chat.id, ""Sorry, you haven't solved tasks."")
            return 0
        img = open(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\users\\"" + name[1] + "".png"", ""rb"")
        bot.send_photo(message.chat.id, img)
        img.close()
    else:
        bot.send_message(message.chat.id, ""You should login before getting statistic."")",1,cwe-089,,,,,
"    @jwt_required
    def delete(self, user_id):
        """""" Deletes user with the corresponding user_id """"""
        return database_utilities.execute_query(f""""""delete from users where user_id = '{user_id}'"""""")",1,cwe-089,,,,,
"    def verify_rno(self, rno):
        query = ""SELECT COUNT(rno) FROM rides WHERE rno = {rno}"".format(rno = rno)
        self.cursor.execute(query)
        result = self.cursor.fetchone()
        if (int(result[0]) > 0):
            return True 
        else:
            return False",1,cwe-089,,,,,
"    def get_requested_day(self, date):

        data = dict()

        day_start, day_end = self.get_epoch_day(date)
        data['interval'] = {'from': self.convert_local_ts_to_utc(day_start, self.local_timezone), 'to': self.convert_local_ts_to_utc(day_end, self.local_timezone)}

        query = '''
            SELECT TimeStamp, SUM(Power) AS Power 
            FROM DayData 
            WHERE TimeStamp BETWEEN %s AND %s 
            GROUP BY TimeStamp;
        '''

        data['data'] = list()
        for row in self.c.execute(query % (day_start, day_end)):
            data['data'].append({ 'time': row[0], 'power': row[1] })


        if self.get_datetime(date).date() == datetime.today().date():
            query = '''
                SELECT SUM(EToday) as EToday
                FROM Inverters;
                '''
        else:
            query = '''
                SELECT SUM(DayYield) AS Power 
                FROM MonthData 
                WHERE TimeStamp BETWEEN %s AND %s
                GROUP BY TimeStamp
                ''' % (day_start, day_end)
        self.c.execute(query)
        row = self.c.fetchone()
        if row and row[0]: data['total'] = row[0]
        else: data['total'] = 0


        query = '''
            SELECT MIN(TimeStamp) as Min, MAX(TimeStamp) as Max 
            FROM ( SELECT TimeStamp FROM DayData GROUP BY TimeStamp );
            '''

        self.c.execute(query)
        first_data, last_data = self.c.fetchone()

        if (first_data):  data['hasPrevious'] = (first_data < day_start)
        else: data['hasPrevious'] = False

        if (last_data): data['hasNext'] = (last_data > day_end)
        else: data['hasNext'] = False

        #print(json.dumps(data, indent=4))
        return data",1,cwe-089,,,,,
"def add_language(lang):
    try:
        cur.execute(f""INSERT INTO language (name) VALUES ('{lang}')"")
    except Exception as e:
        pass
    cur.execute(f""SELECT language_id FROM language where name='{lang}'"")
    lang_id = cur.fetchone()[0]
    if conn.commit():
        return lang_id
    return lang_id",1,cwe-089,,,,,
"def makeJudge(judge):
	db.execute(""UPDATE players SET Judge = 1 WHERE Name = '%s' COLLATE NOCASE"" % (judge)) 
	database.commit()",1,cwe-089,,,,,
"def isValidAdmToken(adm_token):
    conn, c = connectDB()
    req = ""SELECT *  from {} where adm_token='{}'"".format(CFG(""admintoken_table_name""), adm_token)
    answer = bool(queryOne(c, req))
    closeDB(conn)
    return answer",1,cwe-089,,,,,
"    @staticmethod
    def get_mapped_projects(user_id: int, preferred_locale: str) -> UserMappedProjectsDTO:
        """""" Get all projects a user has mapped on """"""

        # This query looks scary, but we're really just creating an outer join between the query that gets the
        # counts of all mapped tasks and the query that gets counts of all validated tasks.  This is necessary to
        # handle cases where users have only validated tasks on a project, or only mapped on a project.
        sql = '''SELECT p.id,
                        p.status,
                        p.default_locale,
                        c.mapped,
                        c.validated,
                        st_asgeojson(p.centroid)
                   FROM projects p,
                        (SELECT coalesce(v.project_id, m.project_id) project_id,
                                coalesce(v.validated, 0) validated,
                                coalesce(m.mapped, 0) mapped
                          FROM (SELECT t.project_id,
                                       count (t.validated_by) validated
                                  FROM tasks t
                                 WHERE t.project_id IN (SELECT unnest(projects_mapped) FROM users WHERE id = {0})
                                   AND t.validated_by = {0}
                                 GROUP BY t.project_id, t.validated_by) v
                         FULL OUTER JOIN
                        (SELECT t.project_id,
                                count(t.mapped_by) mapped
                           FROM tasks t
                          WHERE t.project_id IN (SELECT unnest(projects_mapped) FROM users WHERE id = {0})
                            AND t.mapped_by = {0}
                          GROUP BY t.project_id, t.mapped_by) m
                         ON v.project_id = m.project_id) c
                   WHERE p.id = c.project_id ORDER BY p.id DESC'''.format(user_id)

        results = db.engine.execute(sql)

        if results.rowcount == 0:
            raise NotFound()

        mapped_projects_dto = UserMappedProjectsDTO()
        for row in results:
            mapped_project = MappedProject()
            mapped_project.project_id = row[0]
            mapped_project.status = ProjectStatus(row[1]).name
            mapped_project.tasks_mapped = row[3]
            mapped_project.tasks_validated = row[4]
            mapped_project.centroid = geojson.loads(row[5])

            project_info = ProjectInfo.get_dto_for_locale(row[0], preferred_locale, row[2])
            mapped_project.name = project_info.name

            mapped_projects_dto.mapped_projects.append(mapped_project)

        return mapped_projects_dto",1,cwe-089,,,,,
"    def delete_data(self, session, id):
        self._openContainer(session)
        sid = str(id)
        if (self.idNormalizer is not None):
            sid = self.idNormalizer.process_string(session, str(id))
        query = ""DELETE FROM %s WHERE identifier = '%s';"" % (self.table, sid)
        self._query(query)
        return None",1,cwe-089,,,,,
"    def user_verify(self):
        eid = self.email
        code = self.password
        if eid.strip() == '':
            return
        if code.strip() == '':
            return
        query = '''select * from usr where email like\''''+eid+'\''
        cursor = g.conn.execute(query)
        for row in cursor:
            key = str(row.password)
            if key.strip() == code.strip():
                self.name = str(row.name)
                self.email = eid
                self.id = eid
                self.valid = True
            break",1,cwe-089,,,,,
"@app.route('/movies/search', methods=['GET', 'POST'])
def search_films():
    form = SearchForm()
    if not form.validate_on_submit():
        return render_template('search.html', title='Search for films', form=form)
    search_terms = form.data['term'].split(' ')
    search_string = ' & '.join(search_terms)
    cur.execute(f""SELECT * FROM film where fulltext @@ to_tsquery('{search_string}')"")
    res = cur.fetchall()
    return render_template('search_results.html', title='Home', res=len(res))",1,cwe-089,,,,,
"def getGameCountInSeriesSoFar(submission):
    database = sqlite3.connect('database.db')
    cursor = database.cursor()
    return cursor.execute(""SELECT COUNT(*) FROM ChallengeRankings WHERE SeriesTitle = '"" + getTitle(submission) + ""' AND Date <= '"" + getSubmissionDateFromDatabase(submission) + ""'"").fetchone()[0]
    database.close()",1,cwe-089,,,,,
"@mod.route('/add', methods=['GET', 'POST'])
def add():
    if request.method == 'POST':
        msg_id = int(request.form['msg_id'])
        user_id = session['logged_id']
        content = request.form['content']
        c_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        sql = ""INSERT INTO comment(msg_id,user_id,content,c_time) "" + \
                ""VALUES(%d,%d,'%s','%s');"" % (msg_id, user_id, content, c_time)
        cursor.execute(sql)
        conn.commit()
    return redirect(url_for('comment.show', msg_id=msg_id))",1,cwe-089,,,,,
"def get_mod_taken_together_with(code):
    '''
        Retrieves the list of modules taken together with the specified
        module code in the same semester.

        Returns a table of lists (up to 10 top results). Each list contains
        (specified code, module code of mod taken together, aySem, number of students)

        e.g. [(CS1010, CS1231, AY 16/17 Sem 1, 5)] means there are 5 students
        taking CS1010 and CS1231 together in AY 16/17 Sem 1.
    '''
    NUM_TOP_RESULTS_TO_RETURN = 10

    sql_command = ""SELECT sp1.moduleCode, sp2.moduleCode, sp1.acadYearAndSem, COUNT(*) "" + \
                ""FROM studentPlans sp1, studentPlans sp2 "" + \
                ""WHERE sp1.moduleCode = '"" + code + ""' AND "" + \
                ""sp2.moduleCode <> sp1.moduleCode AND "" + \
                ""sp1.studentId = sp2.studentId AND "" + \
                ""sp1.acadYearAndSem = sp2.acadYearAndSem "" + \
                ""GROUP BY sp1.moduleCode, sp2.moduleCode, sp1.acadYearAndSem "" + \
                ""ORDER BY COUNT(*) DESC""

    DB_CURSOR.execute(sql_command)

    return DB_CURSOR.fetchmany(NUM_TOP_RESULTS_TO_RETURN)",1,cwe-089,,,,,
"@endpoints.route(""/wins"")
def wins():
    if db == None:
        init()

    player = request.args.get('tag', default=""christmasmike"")
    sql = ""SELECT * FROM matches WHERE winner = '""+str(player)+""' ORDER BY date DESC;""
    result = db.exec(sql)

    result = [str(x) for x in result]
    result = '\n'.join(result)
    return json.dumps(result)",1,cwe-089,,,,,
"    def delete_event(self, event_id):
        sql = """"""DELETE FROM events
                 WHERE event_id = {0}
                 """""".format(event_id)
        affected_count = self.cur.execute(sql)
        self.conn.commit()
        return affected_count",1,cwe-089,,,,,
"    def add_item(self, item):
        """"""""Add new item.""""""
        if self.connection:
            self.cursor.execute('insert into item (name, shoppinglistid) values (""%s"", ""%s"")' % (item[0], item[1]))
            self.connection.commit()",1,cwe-089,,,,,
"def fetch_issue(cursor, id):
    """"""
    Fetch an issue by id along with its tags. Returns None if no issue
    with the specified id exists in the database.
    """"""
    cursor.execute(f""""""
        SELECT
            issue.id,
            issue.title,
            issue.description,
            tag.namespace,
            tag.predicate,
            tag.value
        FROM
            issue LEFT JOIN tag
            ON issue.id = tag.issue_id
        WHERE
            issue.id = {id}
    """""")

    issue = None
    for row in cursor:
        if issue is None:
            issue = {
                ""id"": row[""id""],
                ""title"": row[""title""],
                ""description"": row[""description""],
                ""tags"": [],
            }
        # If tag exists in row, add to issue.
        if row[""value""]:
            issue[""tags""].append({
                ""namespace"": row[""namespace""],
                ""predicate"": row[""predicate""],
                ""value"": row[""value""],
            })

    return issue",1,cwe-089,,,,,
"def also_add(name, also):
    db = db_connect()
    cursor = db.cursor()
    try:
        cursor.execute('''
            INSERT INTO isalso(name,also) VALUES('{}','{}')
            '''.format(name, also))
        db.commit()
        logger.debug('added to isalso name {} with value {}'.format(
            name, also))
        db.close()
    except Exception as e:
        logger.error('Execution failed with error: {}'.format(e))
        raise",1,cwe-089,,,,,
"    def getCommentsLike(self,commentid):
        sqlText=""select userid from comment_like where commentid=%d""%(commentid)
        result=sql.queryDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"def update_theory_base(tag, link):
    theory = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\theory.db"")
    conn = theory.cursor()
    conn.execute(""insert into "" + str(tag) + "" values (?)"", (str(link), ))
    theory.commit()
    theory.close()",1,cwe-089,,,,,
"@app.route('/get_asset_and_volume')
def get_asset_and_volume():
    asset_id = request.args.get('asset_id')

    if not isObject(asset_id):
        ws.send('{""id"":1, ""method"":""call"", ""params"":[0,""lookup_asset_symbols"",[[""' + asset_id + '""], 0]]}')
        result_l = ws.recv()
        j_l = json.loads(result_l)
        asset_id = j_l[""result""][0][""id""]

    #print asset_id
    ws.send('{""id"":1, ""method"":""call"", ""params"":[0,""get_assets"",[[""' + asset_id + '""], 0]]}')
    result = ws.recv()
    j = json.loads(result)

    dynamic_asset_data_id =  j[""result""][0][""dynamic_asset_data_id""]

    ws.send('{""id"": 1, ""method"": ""call"", ""params"": [0, ""get_objects"", [[""'+dynamic_asset_data_id+'""]]]}')
    result2 = ws.recv()
    j2 = json.loads(result2)
    #print j2[""result""][0][""current_supply""]

    j[""result""][0][""current_supply""] = j2[""result""][0][""current_supply""]
    j[""result""][0][""confidential_supply""] = j2[""result""][0][""confidential_supply""]
    #print j[""result""]

    j[""result""][0][""accumulated_fees""] = j2[""result""][0][""accumulated_fees""]
    j[""result""][0][""fee_pool""] = j2[""result""][0][""fee_pool""]

    issuer = j[""result""][0][""issuer""]
    ws.send('{""id"": 1, ""method"": ""call"", ""params"": [0, ""get_objects"", [[""'+issuer+'""]]]}')
    result3 = ws.recv()
    j3 = json.loads(result3)
    j[""result""][0][""issuer_name""] = j3[""result""][0][""name""]


    con = psycopg2.connect(**config.POSTGRES)
    cur = con.cursor()

    query = ""SELECT volume, mcap FROM assets WHERE aid='""+asset_id+""'""
    cur.execute(query)
    results = cur.fetchall()
    con.close()
    try:
        j[""result""][0][""volume""] = results[0][0]
        j[""result""][0][""mcap""] = results[0][1]
    except:
        j[""result""][0][""volume""] = 0
        j[""result""][0][""mcap""] = 0

    return jsonify(j[""result""])",1,cwe-089,,,,,
"def reportMatch(winner, loser):
    """"""Records the outcome of a single match between two players.

    Args:
      winner:  the id number of the player who won
      loser:  the id number of the player who lost
    """"""
    try:
        int(winner)
        int(loser)
    except ValueError:
        raise ValueError(
            ""\""winner\"" and/or \""loser\"" input are not integers.\n""
            ""Please use the id number of each player to report match results.""
        )
    w = str(winner)
    l = str(loser)
    db = connect()
    c = db.cursor()
    statement = ""INSERT INTO matches values ({w}, {l})"".format(w=w, l=l)
    c.execute(statement)
    db.commit()
    db.close()",1,cwe-089,,,,,
"def getPlayer(player):
	db.execute(""SELECT * FROM players WHERE Name = '%s' COLLATE NOCASE"" % player)
	playerstats = dict(db.fetchone())
	return playerstats",1,cwe-089,,,,,
"def karma_sub(name):
    karma = karma_ask(name)
    db = db_connect()
    cursor = db.cursor()
    if karma is None:
        try:
            cursor.execute('''
                INSERT INTO people(name,karma,shame) VALUES('{}',-1,0)
                '''.format(name))
            db.commit()
            logger.debug('Inserted into karmadb -1 karma for {}'.format(name))
            db.close()
            return -1

        except Exception as e:
            logger.error('Execution failed with error: {}'.format(e))
            raise
    else:
        karma = karma - 1
        try:
            cursor.execute('''
                UPDATE people SET karma = {0} WHERE name = '{1}'
                '''.format(karma, name))
            db.commit()
            logger.debug('Inserted into karmadb -1 karma for {}'.format(name))
            db.close()
            return karma
        except Exception as e:
            logger.error('Execution failed with error: {}'.format(e))
            raise",1,cwe-089,,,,,
"@app.route('/', methods=['POST'])
def login():
    print('login')
    user = str(request.form['username'])
    password = str(request.form['password'])
    cur.execute('SELECT * FROM users WHERE name = \'{}\' AND password = \'{}\';'.format(user, password))
    response = cur.fetchone()
    if response != None:
        print(response, 'OK')
        return redirect(url_for('enter_test_point'))
    else:
        print(response, 'not OK')
        flash('Invalid login or password')
        return render_template('login.html')",1,cwe-089,,,,,
"    def fetch_data(self, session, id):
        self._openContainer(session)
        sid = str(id)
        if (self.idNormalizer is not None):
            sid = self.idNormalizer.process_string(session, sid)
        query = (""SELECT data FROM %s WHERE identifier = '%s';"" %
                 (self.table, sid)
                 )
        res = self._query(query)
        try:
            data = res.dictresult()[0]['data']
        except IndexError:
            raise ObjectDoesNotExistException(id)
        try:
            ndata = pg.unescape_bytea(data)
        except:
            # insufficient PyGreSQL version
            ndata = data.replace(""\\'"", ""'"")

        ndata = ndata.replace('\\000\\001', nonTextToken)
        ndata = ndata.replace('\\012', '\n')
        return ndata",1,cwe-089,,,,,
"def registerPlayer(name):
    """"""Adds a player to the tournament database.

    The database assigns a unique serial id number for the player.  (This
    should be handled by your SQL database schema, not in your Python code.)

    Args:
      name: the player's full name (need not be unique).
    """"""
    conn = connect()
    cursor = conn.cursor()
    cursor.execute(""INSERT INTO players (name) VALUES ('%s')"" % (name,));
    conn.commit()
    conn.close()",1,cwe-089,,,,,
"@mod.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        error = None
        email = request.form['email'].strip()
        nickname = request.form['nickname'].strip()
        password = request.form['password'].strip()
        password2 = request.form['password2'].strip()

        email = email.lower()

        if email == """" or nickname == """" or password == """" or password2 == """":
            error = 'Please input all the information'
        elif password2 != password:
            error = 'The password is not repeated correctly'
        elif len(password) < 6:
            error = 'The password has at least 6 characters'
        elif not re.match(r'^[0-9a-zA-Z_]{0,19}@' +
                          '[0-9a-zA-Z]{1,15}\.[com,cn,net]', email):
            error = 'Please input the right email'

        sql = ""SELECT * FROM users where email = '%s';"" % (email)
        cursor.execute(sql)
        u = cursor.fetchone()

        if u is not None:
            error = 'The email has already exsit'

        if error is not None:
            return render_template('register.html', error=error)
        else:
            password = bcrypt.generate_password_hash(password)
            cursor.execute(""INSERT INTO users(email,nickname,password) VALUES(%s,%s,%s);"", (email, nickname, password))
            conn.commit()
            flash('Register Success!')
            return redirect(url_for('users.login'))

    return render_template('register.html')",1,cwe-089,,,,,
"def process_form():
    # see https://docs.python.org/3.4/library/cgi.html for the basic usage
    # here.
    form = cgi.FieldStorage()


    # connect to the database
    conn = MySQLdb.connect(host   = pnsdp.SQL_HOST,
                           user   = pnsdp.SQL_USER,
                           passwd = pnsdp.SQL_PASSWD,
                           db     = pnsdp.SQL_DB)


    if ""user"" not in form or ""game"" not in form:
        raise FormError(""Invalid parameters."")
    if ""pos"" not in form and ""resign"" not in form:
        raise FormError(""Invalid parameters."")

    game = int(form[""game""].value)


    (players,size,state) = get_game_info(conn, game)

    user = form[""user""].value
    if user not in players:
        raise FormError(""Invalid player ID - player is not part of this game"")


    if ""resign"" in form:
        resign = True
    else:
        resign = False
        pos = form[""pos""].value.split("","")
        assert len(pos) == 2
        x = int(pos[0])
        y = int(pos[1])


    (board,nextPlayer,letter) = build_board(conn, game,size)

    if user != players[nextPlayer]:
        raise FormError(""Internal error, incorrect player is attempting to move."")


    if resign:
        # this user is choosing to resign.  Update the game state to reflect that.
        other_player_name = players[1-nextPlayer]

        cursor = conn.cursor()
        cursor.execute(""""""UPDATE games SET state=""%s:resignation"" WHERE id=%d;"""""" % (other_player_name,game))
        cursor.close()

    else:
        assert x >= 0 and x < size
        assert y >= 0 and y < size

        assert board[x][y] == """"
        board[x][y] = ""XO""[nextPlayer]

        # we've done all of our sanity checks.  We now know enough to say that
        # it's safe to add a new move.
        cursor = conn.cursor()
        cursor.execute(""""""INSERT INTO moves(gameID,x,y,letter,time) VALUES(%d,%d,%d,""%s"",NOW());"""""" % (game,x,y,letter))

        if cursor.rowcount != 1:
            raise FormError(""Could not make move, reason unknown."")

        cursor.close()

        result = analyze_board(board)
        if result != """":
            if result == ""win"":
                result = players[nextPlayer]+"":win""

            cursor = conn.cursor()
            cursor.execute(""""""UPDATE games SET state=""%s"" WHERE id=%d;"""""" % (result,game))
            cursor.close()

    # we've made changes, make sure to commit them!
    conn.commit()
    conn.close()


    # return the parms to the caller, so that they can build a good redirect
    return (user,game)",1,cwe-089,,,,,
"@login_manager.user_loader
def load_user(s_id):
    email = str(s_id)
    query = '''select * from usr where email like\'''' + email + '\''
    cursor = g.conn.execute(query)
    user = User()
    for row in cursor:
        user.name = str(row.name)
        user.email = str(row.email)
        break
    return user",1,cwe-089,,,,,
"@mod.route('/delete/<int:cmt_id>', methods=['GET', 'POST'])
def delete(cmt_id):
    if request.method == 'GET':
        sql = ""SELECT msg_id FROM comment where cmt_id = %d;"" % (cmt_id)
        cursor.execute(sql)
        m = cursor.fetchone()
        sql = ""DELETE FROM comment where cmt_id = '%d';"" % (cmt_id)
        cursor.execute(sql)
        conn.commit()
        flash('Delete Success!')
    return redirect(url_for('comment.show', msg_id=m[0]))",1,cwe-089,,,,,
"@app.route('/get_markets')
def get_markets():
    asset_id = request.args.get('asset_id')

    if not isObject(asset_id):
        ws.send('{""id"":1, ""method"":""call"", ""params"":[0,""lookup_asset_symbols"",[[""' + asset_id + '""], 0]]}')
        result_l = ws.recv()
        j_l = json.loads(result_l)
        asset_id = j_l[""result""][0][""id""]


    con = psycopg2.connect(**config.POSTGRES)
    cur = con.cursor()

    query = ""SELECT * FROM markets WHERE aid='""+asset_id+""'""
    cur.execute(query)
    results = cur.fetchall()
    con.close()
    return jsonify(results)",1,cwe-089,,,,,
"	def get_secrets(self, from_date_added=0):
		secrets = []
		for row in self.cursor.execute('SELECT encrypted, json_id, date_added FROM secret WHERE date_added > %s ORDER BY date_added DESC' % from_date_added):
			aes_key, json_id, date_added = cryptlib.eciesDecrypt(row[0], self.privkey), row[1], row[2]
			if aes_key != None:
				secrets.append([aes_key, json_id])
			from_date_added = max(from_date_added, date_added)
		return (secrets, from_date_added)",1,cwe-089,,,,,
"    def add_consumption_data_row(self, ts, energy_used, power_used):

        if power_used > 0:

            query = '''
                INSERT OR IGNORE INTO Consumption (
                    TimeStamp,
                    EnergyUsed,
                    PowerUsed                                
                ) VALUES (
                    %s,
                    %s,
                    %s
                );
            ''' % (ts, 0, 0)
            self.c.execute(query)

            query = '''
                UPDATE Consumption SET 
                EnergyUsed = EnergyUsed + %s,
                PowerUsed = PowerUsed + %s
                WHERE TimeStamp = %s;
            ''' % (energy_used, power_used, ts)

            self.c.execute(query)

            self.db.commit()",1,cwe-089,,,,,
"@app.route('/lookup_assets')
def lookup_assets():
    start = request.args.get('start')

    con = psycopg2.connect(**config.POSTGRES)
    cur = con.cursor()

    query = ""SELECT aname FROM assets WHERE aname LIKE '""+start+""%'""
    cur.execute(query)
    results = cur.fetchall()
    con.close()
    return jsonify(results)",1,cwe-089,,,,,
"def set_state(chat_id, value):
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\settings.db"")
    conn = settings.cursor()
    conn.execute(""update users set state ='"" + str(value) + ""' where chat_id = '"" + str(chat_id) + ""'"")
    settings.commit()
    settings.close()",1,cwe-089,,,,,
"def _get_degree_2(user_id, cnx):
    """"""Get all users of degree 2 follow that are not currently followed.
    Example:
        this user (follows) user B (follows) user B
        AND user (does NOT follow) user B
        means that user B will be in the list
    Args:
        user_id (int): id of user
        cnx: DB connection
    Returns:
        list: list of user_ids
    """"""
    sql = 'WITH tmp_suggest (followed_id) AS ' \
    '(' \
        'SELECT b.followed_id AS followed_id ' \
        'FROM ' \
            'tbl_follow a INNER JOIN tbl_follow b ' \
            'ON a.followed_id = b.follower_id ' \
        'WHERE a.follower_id = %s ' \
        'AND b.followed_id NOT IN ' \
            '(SELECT followed_id FROM tbl_follow WHERE follower_id = %s) ' \
        'AND b.followed_id != %s ' \
    ') ' \
    'SELECT followed_id, COUNT(*) AS num_mutual FROM tmp_suggest ' \
    'GROUP BY followed_id ' \
    'ORDER BY num_mutual DESC' % (user_id, user_id, user_id)
    with cnx.cursor() as cursor:
        cursor.execute(sql)
        res = cursor.fetchall()
    return list(map(lambda x: x[0], res))",1,cwe-089,,,,,
"def get_tournaments_during_month(db, scene, date):
    y, m, d = date.split('-')
    ym_date = '{}-{}'.format(y, m)
    sql = ""select url, date from matches where scene='{}' and date like '%{}%' group by url, date order by date"".format(scene, ym_date)
    res = db.exec(sql)
    urls = [r[0] for r in res]
    return urls",1,cwe-089,,,,,
"    def add_input(self,data):
        connection = self.connect()
        try:
            # The following is a flaw
            query = ""INSERT INTO crimes(description) VALUES ('{}');"".format(data)
            with connection.cursor() as cursor:
                cursor.execute(query)
                connection.commit()
        finally:
            connection.close()",1,cwe-089,,,,,
"def get_error_days(cur, error_percent):
    """"""Fetches the days in which requests led to errors.

    Fetches the days in which the specified percentage
    of requests led to errors.

    Args:
        cur(obj): The cursor to execute the query.
        error_percent(int): The percentage of requests that led to errors.

    Return:
        True if success, False otherwise.
    """"""
    query = '''SELECT to_char(log_errors.date, 'Mon DD YYYY'),
            round((log_errors.errors * 100
            / log_requests.total::numeric), 2) as percent
            FROM log_errors, log_requests
            WHERE log_errors.date = log_requests.date AND
            log_errors.errors * 100
            / log_requests.total::numeric > {}
            ORDER BY log_errors.date'''.format(error_percent)
    rows = get_data(cur, query)

    # Write data to txt file.
    if rows is not None:
        file = open(""error_report.txt"", ""w"")
        for row in rows:
            file.write(""{} - {}% errors \n"".format(row[0], row[1]))
        file.close()

        return True
    else:
        return False",1,cwe-089,,,,,
"    def all_deposits(self,coin):
        sql = ""SELECT * FROM deposits WHERE coin='%s'"" % coin
        self.cursor.execute(sql)
        return self.cursor.fetchall()",1,cwe-089,,,,,
"    def get_user(self):
        if not hasattr(self, '_user'):
            qs = ""select * from account_access where access_token = '%s'"" % self.access_token
            result = self.db.get(qs)
            if result:
                self._user = result
            else:
                self._user = None
        
        return self._user",1,cwe-089,,,,,
"    @staticmethod
    def compare_and_update(user, message):
        """"""
        This method compare a user object from the bot and his info from
        the Telegram message to check whether a user has changed his bio
        or not. If yes, the user object that represents him in the bot will
        be updated accordingly. Now this function is called only when a user
        asks the bot for showing the most popular cams

        :param user: user object that represents a Telegram user in this bot
        :param message: object from Telegram that contains info about user's
        message and about himself
        :return: None
        """"""

        log.info('Checking whether user have changed his info or not...')
        msg = message.from_user
        usr_from_message = User(message.chat.id, msg.first_name, msg.username,
                                msg.last_name)

        if user.chat_id != usr_from_message.chat_id:
            log.error(""Wrong user to compare!"")
            return

        if user.first_name != usr_from_message.first_name:
            user.first_name = usr_from_message.first_name

        elif user.nickname != usr_from_message.nickname:
            user.nickname = usr_from_message.nickname

        elif user.last_name != usr_from_message.last_name:
            user.last_name = usr_from_message.last_name

        else:
            log.debug(""User's info hasn't changed"")
            return

        log.info(""User has changed his info"")
        log.debug(""Updating user's info in the database..."")
        query = (f""UPDATE users ""
                 f""SET first_name='{user.first_name}', ""
                 f""nickname='{user.nickname}', ""
                 f""last_name='{user.last_name}' ""
                 f""WHERE chat_id={user.chat_id}"")

        try:
            db.add(query)
        except DatabaseError:
            log.error(""Could not update info about %s in the database"",
                      user)
        else:
            log.debug(""User's info has been updated"")",1,cwe-089,,,,,
"def GameNewPlayed(Played, ID):
	db.execute(""UPDATE games set GamesPlayed = %i WHERE ID = %i"" % (Played, ID))
	database.commit()",1,cwe-089,,,,,
"def insertNPC(name, race,classe,sex,level,image,legit):
	c, conn = getConnection()
	date = now()
	c.execute(""INSERT INTO npc VALUES ('""+date+""','""+str(name)+""','""+race+""','""+classe+""','""+sex+""','""+str(level)+""','""+image+""','""+str(legit)+""')"")
	conn.commit()
	conn.close()",1,cwe-089,,,,,
"    def get(self, user_id):
        """""" Fetch data for user with corresponding user_id """"""
        return database_utilities.execute_query(f""""""select * from users where user_id = '{user_id}'"""""")",1,cwe-089,,,,,
"@endpoints.route(""/h2h"")
def h2h():
    if db == None:
        init()

    player1 = request.args.get('tag1', default=""christmasmike"")
    player2 = request.args.get('tag2', default=""christmasmike"")
    sql = ""SELECT * FROM matches WHERE (player1 = '""+str(player1)+""' OR ""\
            +""player2 = '""+str(player1)+""') AND (player1 = '""+str(player2)+""' OR ""\
            +""player2 = '""+str(player2)+""') ORDER BY date DESC;""
    result = db.exec(sql)
    return json.dumps(result)",1,cwe-089,,,,,
"    def insertData(self,userid,post):
        sqlText=""insert into post(userid,date,comment) \
                values(%d,current_timestamp(0),'%s');""%(userid,post);
        result=sql.insertDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"    def get_requested_month_for_inverter(self, inverter_serial, date):
        data = dict()

        month_start, month_end = self.get_epoch_month(date)
        data['interval'] = {'from': self.convert_local_ts_to_utc(month_start, self.local_timezone), 'to': self.convert_local_ts_to_utc(month_end, self.local_timezone)}
        month_total = 0

        query = '''
            SELECT TimeStamp, DayYield AS Power 
            FROM MonthData 
            WHERE TimeStamp BETWEEN %s AND %s AND Serial = %s
            '''

        data['data'] = list()
        for row in self.c.execute(query % (month_start, month_end, inverter_serial)):
            data['data'].append({'time': self.convert_local_ts_to_utc(row[0], self.local_timezone), 'power': row[1]})
            month_total += row[1]

        data['total'] = month_total

        query = '''
            SELECT MIN(TimeStamp) as Min, MAX(TimeStamp) as Max 
            FROM MonthData 
            WHERE Serial = %s;
            ''' % inverter_serial

        self.c.execute(query)
        first_data, last_data = self.c.fetchone()

        if first_data: data['hasPrevious'] = (first_data < month_start)
        else: data['hasPrevious'] = False
        if last_data: data['hasNext'] = (last_data > month_end)
        else: data['hasNext'] = False

        return data",1,cwe-089,,,,,
"    def delete_resultSet(self, session, id):
        self._openContainer(session)
        sid = str(id)
        if (self.idNormalizer is not None):
            sid = self.idNormalizer.process_string(session, sid)
        query = ""DELETE FROM %s WHERE identifier = '%s';"" % (self.table, sid)
        self._query(query)",1,cwe-089,,,,,
"def getSeriesDateFromDatabase(submission):
    database = sqlite3.connect('database.db')
    cursor = database.cursor()
    return cursor.execute(""SELECT StartDate FROM SeriesTracking WHERE SeriesTitle = '"" + str(getTitle(submission)) + ""'"").fetchone()[0]
    database.close()",1,cwe-089,,,,,
"def karma_add(name):
    karma = karma_ask(name)
    db = db_connect()
    cursor = db.cursor()
    if karma is None:
        try:
            cursor.execute('''
                INSERT INTO people(name,karma,shame) VALUES('{}',1,0)
                '''.format(name))
            db.commit()
            logger.debug('Inserted into karmadb 1 karma for {}'.format(name))
            return 1
        except Exception as e:
            logger.error('Execution failed with error: {}'.format(e))
            raise
    else:
        karma = karma + 1
        try:
            cursor.execute('''
                UPDATE people SET karma = {0} WHERE name = '{1}'
                '''.format(karma, name))
            db.commit()
            logger.debug('Inserted into karmadb {} karma for {}'.format(
                karma, name))
            return karma

        except Exception as e:
            logger.error('Execution failed with error: {}'.format(e))
            raise
    db.close()",1,cwe-089,,,,,
"  def update_date_modified(self):
    sql = ""UPDATE jdk_entries "" + \
      ""SET date_last_modified = "" + CURRENT_DATESTAMP + "" "" + \
      ""WHERE jdk_entries.id = '"" + self.entry_id + ""';""
    
    db_execute(sql)

    return None",1,cwe-089,,,,,
"    def system_search(self, search):
        search = search.lower()
        conn = sqlite3.connect('data/ed.db').cursor()
        table = conn.execute(f""select * from populated where lower(name) = '{search}'"")
        results = table.fetchone()
        if not results:
            table = conn.execute(f""select * from systems where lower(name) = '{search}'"")
            results = table.fetchone()
        if results:
            keys = tuple(i[0] for i in table.description) 
            return '\n'.join(f'{key.replace(""_"", "" "").title()}: {field}'
                             for key, field in zip(keys[1:], results[1:]) if field)
        else:
            return 'No systems found.'",1,cwe-089,,,,,
"    def add_input(self, data):
        connection = self.connect()
        try:
            # The following introduces a deliberate security flaw - SQL Injection
            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)
            with connection.cursor() as cursor:
                cursor.execute(query)
                connection.commit()
        finally:
            connection.close()",1,cwe-089,,,,,
"@bot.message_handler(commands =['login'])
def get_login(message):
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\settings.db"")
    conn = settings.cursor()
    conn.execute(""select * from users where chat_id = '"" + str(message.chat.id) + ""'"")
    name = conn.fetchone()
    if name != None:
        bot.send_message(message.chat.id, ""Previous handle: "" + str(name[1]))
    else:
        bot.send_message(message.chat.id, ""Previous handle: None"")
    settings.close()
    bot.send_message(message.chat.id, ""Type new handle: "")
    set_state(message.chat.id, config.States.S_LOGIN.value)",1,cwe-089,,,,,
"    def login(self, username, password):
        select_query = """"""
            SELECT client_id, username, balance, message
            FROM Clients
            WHERE username = '{}' AND password = '{}'
            LIMIT 1
        """""".format(username, password)

        cursor = self.__conn.cursor()

        cursor.execute(select_query)
        user = cursor.fetchone()

        if(user):
            return Client(user[0], user[1], user[2], user[3])
        else:
            return False",1,cwe-089,,,,,
"def get_current_state(chat_id):
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__))+""\\bases\\settings.db"")
    conn = settings.cursor()
    conn.execute(""select * from users where chat_id = '"" + str(chat_id) + ""'"")
    name = conn.fetchone()
    if name != None:
        return name[4]
    else:
        return False
    settings.close()",1,cwe-089,,,,,
"  def fetch_page_name(self, page_id):
    '''
    Returns the page name corresponding to the provided page ID.

    Args:
      page_id: The page ID whose ID to fetch.

    Returns:
      str: The page name corresponding to the provided page ID.

    Raises:
      ValueError: If the provided page ID is invalid or does not exist.
    '''
    helpers.validate_page_id(page_id)

    query = 'SELECT name FROM pages WHERE id=""{0}""'.format(page_id)
    self.cursor.execute(query)

    page_name = self.cursor.fetchone()

    if not page_name:
      raise ValueError('Invalid page ID ""{0}"" provided. Page ID does not exist.'.format(page_id))

    return page_name[0].encode('utf-8').replace('_', ' ')",1,cwe-089,,,,,
"@app.route('/<page_name>/save', methods=['POST'])
def save_page_edit(page_name):
    # grab the new content from the user
    content = request.form.get('content')
    # check if 'page_name' exists in the database
    query = db.query(""select page_content.content, page.id as page_id, page_content.id as content_id from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1"" % page_name)
    result = query.namedresult()
    # if it doesn't exist, create a new page in the database
    if len(result) < 1:
        db.insert(
            'page', {
                'page_name': page_name
            }
        )
    else:
        pass
    # now that we're certain that the page exists in the database, we again grab the query
    # and insert new content in the database
    query = db.query(""select id from page where page_name = '%s'"" % page_name)
    page_id = query.namedresult()[0].id
    db.insert(
        'page_content', {
            'page_id': page_id,
            'content': content,
            'timestamp': time.strftime(""%Y-%m-%d %H:%M:%S"", localtime())
        }
    )
    return redirect(""/%s"" % page_name)",1,cwe-089,,,,,
"def get_top_popular(top_num):
    """""" query the top(top_num) popular articles
        top_num => list of [title, count]
    """"""
    cmd = """"""SELECT title, views FROM articles
             INNER JOIN (
             SELECT path, count(path) AS views
             FROM log GROUP BY log.path
             ) AS log
             ON log.path = '/article/' || articles.slug
             ORDER BY views DESC
             LIMIT {}"""""".format(top_num)
    return execute_query(cmd)",1,cwe-089,,,,,
"@app.route('/<page_name>/edit')
def render_page_edit(page_name):
    query = db.query(""select page_content.content from page, page_content where page.id = page_content.page_id and page.page_name = '%s' order by page_content.id desc limit 1"" % page_name)
    wiki_page = query.namedresult()
    if len(wiki_page) > 0:
        content = wiki_page[0].content
    else:
        content = """"
    return render_template(
        'edit_page.html',
        page_name = page_name,
        content = content
    )",1,cwe-089,,,,,
"def get_monthly_ranks_for_scene(db, scene, tag):

    sql = ""SELECT date, rank FROM ranks WHERE scene='{}' AND player='{}'"".format(scene, tag)
    res = db.exec(sql)

    res = [r for r in res if played_during_month(db, scene, tag, get_previous_month(r[0]))]

    # Build up a dict of {date: rank}
    ranks = {}
    for r in res:
        ranks[r[0]] = r[1]

    return ranks",1,cwe-089,,,,,
"    @staticmethod
    def auto_unlock_tasks(project_id: int):
        """"""Unlock all tasks locked for longer than the auto-unlock delta""""""
        expiry_delta = Task.auto_unlock_delta()
        lock_duration = (datetime.datetime.min + expiry_delta).time().isoformat()
        expiry_date = datetime.datetime.utcnow() - expiry_delta
        old_locks_query = '''SELECT t.id
            FROM tasks t, task_history th
            WHERE t.id = th.task_id
            AND t.project_id = th.project_id
            AND t.task_status IN (1,3)
            AND th.action IN ( 'LOCKED_FOR_VALIDATION','LOCKED_FOR_MAPPING' )
            AND th.action_text IS NULL
            AND t.project_id = {0}
            AND th.action_date <= '{1}'
            '''.format(project_id, str(expiry_date))

        old_tasks = db.engine.execute(old_locks_query)

        if old_tasks.rowcount == 0:
            # no tasks older than the delta found, return without further processing
            return

        for old_task in old_tasks:
            task = Task.get(old_task[0], project_id)
            task.auto_unlock_expired_tasks(expiry_date, lock_duration)",1,cwe-089,,,,,
"    def add_input(self, data):
        connection = self.connect()
        try:
            # The following introduces a deliberate security flaw. 
            # See section on SQL injection below
            query = ""INSERT INTO crimes (description) VALUES('{}');"".format(data)
            with connection.cursor() as cursor:
                cursor.execute(query)
                connection.commit()
        finally:
            connection.close()",1,cwe-089,,,,,
"    def getAllComments(self):
        sqlText=""select comment from comments where userid=%d order by date;""
        allposts=sql.queryDB(self.conn,sqlText)
        return allposts;",1,cwe-089,,,,,
"def update_user(username, chat_id, last_update):
    conn = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\users\\"" + username + '.db')
    conn2 = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + '\\cf.db')
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\settings.db"")
    cursor = conn.cursor()
    cursor2 = conn2.cursor()
    cursor_settings = settings.cursor()
    cursor_settings.execute(""select last_problem from users where chat_id = '"" + str(chat_id) + ""'"")
    update_eq = cursor_settings.fetchone()
    cursor_settings.execute(""select * from last_update_problemset"")
    update_base = cursor_settings.fetchone()
    last_problem = update_base[0]
    if update_eq[0] != update_base[0]:
        cursor2.execute(""SELECT * FROM problems"")
        x = cursor2.fetchone()
        while x != None:
            cursor.execute(""select * from result where problem = '"" + str(x[0]) + ""' and diff = '"" + str(x[1]) + ""'"")
            x2 = cursor.fetchone()
            if x2 == None:
                cursor.execute(""insert into result values (?, ?, ? )"", (x[0], x[1], ""NULL""))
            last_problem = x
            x = cursor2.fetchone()
        conn2.close()
        settings.close()
    if len(last_problem) == 2:
        last_problem = last_problem[0] + last_problem[1]

    url = 'http://codeforces.com/submissions/' + username
    r = requests.get(url)
    max_page = 1
    soup = BeautifulSoup(r.text, ""lxml"")

    for link in soup.find_all(attrs={""class"": ""page-index""}):
        s = link.find('a')
        s2 = s.get(""href"").split('/')
        max_page = max(max_page, int(s2[4]))

    v = False
    r = requests.get('http://codeforces.com/submissions/' + username + '/page/0')
    soup = BeautifulSoup(r.text, ""lxml"")
    last_try_new = soup.find(attrs={""class"": ""status-small""})
    last_try_new = str(last_try_new).split()
    last_try_new = str(last_try_new[2]) + str(last_try_new[3])
    for i in range(1, max_page + 1):
        r = requests.get('http://codeforces.com/submissions/' + username + '/page/' + str(i))
        soup = BeautifulSoup(r.text, ""lxml"")
        count = 0
        j = 0
        ver = soup.find_all(attrs={""class"": ""submissionVerdictWrapper""})
        last_try = soup.find_all(attrs={""class"": ""status-small""})
        for link in soup.find_all('a'):
            last_try_date = str(last_try[j]).split()
            last_try_date = str(last_try_date[2]) + str(last_try_date[3])
            if last_try_date == last_update:
                v = True
                break
            s = link.get('href')
            if s != None and s.find('/problemset') != -1:
                s = s.split('/')
                if len(s) == 5:
                    s2 = str(ver[count]).split()
                    s2 = s2[5].split('\""')
                    count += 1
                    j += 1
                    cursor.execute(""select * from result where problem = '"" + s[3] + ""'and diff = '"" + s[4] + ""'"")
                    x = cursor.fetchone()
                    if s2[1] == 'OK' and x != None:
                        cursor.execute(
                            ""update result set verdict = '"" + s2[1] + ""' where problem = '"" + s[3] + ""' and diff = '"" +
                            s[4] + ""'"")
                    if x[2] != 'OK':
                        cursor.execute(
                            ""update result set verdict = '"" + s2[1] + ""' where problem = '"" + s[3] + ""' and diff = '"" +
                            s[4] + ""'"")
        if v:
            break

    conn.commit()
    conn.close()

    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\settings.db"")
    conn = settings.cursor()
    conn.execute(""update users set username = '"" + str(username) + ""' where chat_id = '"" + str(chat_id) + ""'"")
    conn.execute(""update users set last_update = '"" + str(last_try_new) + ""' where chat_id = '"" + str(chat_id) + ""'"")
    conn.execute(""update users set last_problem = '"" + str(last_problem) + ""' where chat_id = '"" + str(chat_id) + ""'"")

    settings.commit()
    settings.close()",1,cwe-089,,,,,
"    def save_accepted_transaction(self, user_id, project_id, money):
        self.cursor.execute(""update users set money = money - %s where id = %s""%(money, user_id))
        self.cursor.execute(""update projects set money = money + %s where id = %s"" % (money, project_id))
        self.cursor.execute(""insert into transactions (project_id, user_id, money, timestamp, state) values (%s, %s, %s, now(), 'accepted' )"" % (project_id, user_id, money))
        self.db.commit()",1,cwe-089,,,,,
"def shame_ask(name):
    db = db_connect()
    cursor = db.cursor()
    try:
        cursor.execute('''
            SELECT shame FROM people WHERE name='{}'
            '''.format(name))
        shame = cursor.fetchone()
        db.close()
        if shame is None:
            logger.debug('No shame found for name {}'.format(name))
            return shame
        else:
            shame = shame[0]
            logger.debug('shame of {} found for name {}'.format(shame, name))
            return shame
    except Exception as e:
        logger.error('Execution failed with error: {}'.format(e))
        raise",1,cwe-089,,,,,
"def incrementOption(cursor, poll_name, option):
    key = poll_name+""-""+option
    req = ""UPDATE {} SET count=count+1 WHERE name_option = '{}';"".format(CFG(""options_table_name""), key)
    cursor.execute(req)",1,cwe-089,,,,,
"@app.route('/overview/<classNum>')
def overview(classNum):
	if 'username' in session:
		classNoSpace = classNum.split(' ')[0]+classNum.split(' ')[1]

		#Save the current course as a session variable.
		session['currentCourse'] = classNoSpace

		conn = mysql.connect()
		cursor = conn.cursor()

		cursor.execute(""SELECT courseName,courseOverview from courses where courseAbbreviation='"" + classNoSpace + ""'"")
		data = cursor.fetchone()

		return render_template('overview.html', className = classNum, courseTitle = data[0], courseOverview = data[1])

	return redirect(url_for('index'))",1,cwe-089,,,,,
"def addTags(tag_list, listing_id):
    """"""
    Adds a list of tags tag_list for a given listing with listing_id to the database
    """"""
    cur = conn.cursor()
    for x in tag_list:
        sql = ""INSERT INTO {} VALUES {}"".format(listing_tags_table_name, str((listing_id, x)))
        cur.execute(sql)",1,cwe-089,,,,,
"@mod.route('/edit/<int:cmt_id>', methods=['GET', 'POST'])
def edit(cmt_id):
    m = None
    if request.method == 'GET':
        sql = ""SELECT * FROM comment where cmt_id = %d;"" % (cmt_id)
        cursor.execute(sql)
        m = cursor.fetchone()
        return render_template('comment/edit.html', m=m, cmt_id=cmt_id)

    if request.method == 'POST':
        content = request.form['content']
        sql = ""UPDATE comment SET content = '%s' where cmt_id = '%d';"" \
            % (content, cmt_id)
        cursor.execute(sql)
        conn.commit()
        sql = ""SELECT msg_id FROM comment where cmt_id = %d;"" % (cmt_id)
        cursor.execute(sql)
        m = cursor.fetchone()
        flash('Edit Success!')
        return redirect(url_for('comment.show', msg_id=m[0]))

    return render_template('comment/edit.html', m=m, cmt_id=cmt_id)",1,cwe-089,,,,,
"def process_form():
    # see https://docs.python.org/3.4/library/cgi.html for the basic usage
    # here.
    form = cgi.FieldStorage()


    if ""player1"" not in form or ""player2"" not in form or ""size"" not in form:
        raise FormError(""Invalid parameters."")

    player1 = form[""player1""].value
    player2 = form[""player2""].value
    for c in player1+player2:
        if c not in ""_-"" and not c.isdigit() and not c.isalpha():
            raise FormError(""Invalid parameters: The player names can only contains upper and lowercase characters, digits, underscores, and hypens"")
            return

    try:
        size = int(form[""size""].value)
    except:
        raise FormError(""Invalid parameters: 'size' is not an integer."")
        return

    if size < 2 or size > 9:
        raise FormError(""The 'size' must be in the range 2-9, inclusive."")


    # connect to the database
    conn = MySQLdb.connect(host   = pnsdp.SQL_HOST,
                           user   = pnsdp.SQL_USER,
                           passwd = pnsdp.SQL_PASSWD,
                           db     = pnsdp.SQL_DB)
    cursor = conn.cursor()

    # insert the new row
    cursor.execute(""""""INSERT INTO games(player1,player2,size) VALUES(""%s"",""%s"",%d);"""""" % (player1,player2,size))

    gameID = cursor.lastrowid


    # MySQLdb has been building a transaction as we run.  Commit them now, and
    # also clean up the other resources we've allocated.
    conn.commit()
    cursor.close()
    conn.close()

    return gameID",1,cwe-089,,,,,
"    def clean_cache(self, limit):
        """"""
        Method that remove several User objects from cache - the least 
        active users
        :param limit: number of the users that the method should remove
        from cache
        :return: None
        """"""

        log.info('Figuring out the least active users...')
        # Select users that the least active recently
        user_ids = tuple(self.users.keys())
        query = ('SELECT chat_id '
                 'FROM photo_queries_table2 '
                 f'WHERE chat_id in {user_ids} '
                 'GROUP BY chat_id '
                 'ORDER BY MAX(time) '
                 f'LIMIT {limit}')

        try:
            cursor = db.execute_query(query)
        except DatabaseConnectionError:
            log.error(""Can't figure out the least active users..."")
            return

        if not cursor.rowcount:
            log.warning(""There are no users in the db"")
            return

        # Make list out of tuple of tuples that is returned by MySQL
        least_active_users = [chat_id[0] for chat_id in cursor.fetchall()]
        log.info('Removing %d least active users from cache...', limit)
        num_deleted_entries = 0
        for entry in least_active_users:
            log.debug('Deleting %s...', entry)
            deleted_entry = self.users.pop(entry, None)
            if deleted_entry:
                num_deleted_entries += 1
        log.debug(""%d users were removed from cache."", num_deleted_entries)",1,cwe-089,,,,,
"@app.route('/quiz')
def quiz():

    varga = request.args.get('varga')

    try:
        rows =[]

        with sql.connect('amara.db') as con:
            con.row_factory = sql.Row
            cur = con.cursor()
            cur.execute(""select * from pada inner join mula on pada.sloka_line = mula.sloka_line where pada.varga = '%s' order by random() limit 1;"" % varga)
            rows = cur.fetchall();

            artha = rows[0][""artha""];
            cur.execute(""select pada from pada where varga = '%s' and artha = '%s' order by id"" % (varga, artha));
            paryaya = cur.fetchall();

            return render_template('quiz.html', rows=rows, paryaya=paryaya, varga=varga)
    finally:
        con.close()",1,cwe-089,,,,,
"    def _checkPairing():
        if winner == loser:
            raise ValueError('Attempt to match player against self')

        q = '''
        SELECT COUNT(*) FROM matches
        WHERE (matches.winner_id = %s AND matches.loser_id = %s)
              OR (matches.winner_id = %s AND matches.loser_id = %s);
        ''' % (winner, loser, loser, winner)
        cur.execute(q)
        if cur.fetchone()[0] > 0:
            raise ValueError('Pairing %s, %s already played' % (winner, loser))",1,cwe-089,,,,,
"    def add_month_data_row(self, inverter_serial, ts, etoday, etotal):

        y = datetime.fromtimestamp(ts) - timedelta(days=1)
        y_ts = int(datetime(y.year, y.month, y.day, 23, tzinfo=pytz.utc).timestamp())

        query = '''
            INSERT INTO MonthData (
                TimeStamp,
                Serial,
                DayYield,
                TotalYield                                 
            ) VALUES (
                %s,
                %s,
                %s,
                %s
            );
        ''' % (y_ts, inverter_serial, etoday, etotal)
        self.c.execute(query)",1,cwe-089,,,,,
"def create_playlist(name, db):
    db.execute(
        ""INSERT INTO playlist (name, video_position) VALUES('{name}', 0);"".format(name=name))",1,cwe-089,,,,,
"def karma_ask(name):
    db = db_connect()
    cursor = db.cursor()
    try:
        cursor.execute(
            ''' SELECT karma FROM people WHERE name='{}' '''.format(name))
        karma = cursor.fetchone()
        if karma is None:
            logger.debug('No karma found for name {}'.format(name))
            db.close()
            return karma
        else:
            karma = karma[0]
            logger.debug('karma of {} found for name {}'.format(karma, name))
            db.close()
            return karma
    except Exception as e:
        logger.error('Execution failed with error: {}'.format(e))
        raise",1,cwe-089,,,,,
"    def post(self):
        """""" Returns JWT upon login verification """"""
        json_data = request.get_json()
        if not json_data['email']:
            return jsonify({""msg"": ""Missing email""}), 400

        data = database_utilities.execute_query(
            f""""""select * from admins where email = '{json_data['email']}'"""""")
        if data:
            email = data[0]['email']
            access_token = create_access_token(identity=email)
            refresh_token = create_refresh_token(identity=email)

            resp = jsonify({""login"": True})
            set_access_cookies(resp, access_token)
            set_refresh_cookies(resp, refresh_token)
            return resp
        else:
            return jsonify({""msg"": ""User is not an admin""})",1,cwe-089,,,,,
"    def add_day_data_row(self, ts, data, prev_etotal):

        if data['power'] > 0:

            inv_serial = data['source']['serial_id']
            query = '''
               INSERT INTO DayData (
                   TimeStamp,
                   Serial,
                   Power,
                   TotalYield
               ) VALUES (
                   %s,
                   %s,
                   %s,
                   %s
               );
            ''' % (ts, inv_serial, data['power'],  prev_etotal + data['energy'])
            self.c.execute(query)",1,cwe-089,,,,,
"    def store_metadata(self, session, key, mType, value):
        if (self.idNormalizer is not None):
            id = self.idNormalizer.process_string(session, id)
        elif type(id) == unicode:
            id = id.encode('utf-8')
        else:
            id = str(id)
        self._openContainer(session)
        query = (""UPDATE %s SET %s = %r WHERE identifier = '%s';"" %
                 (self.table, mType, value, id)
                 )
        try:
            self._query(query)
        except:
            return None
        return value",1,cwe-089,,,,,
"    def get(self, space_id):
        """""" Fetch data for space with the corresponding space_id """"""
        return database_utilities.execute_query(
            f""""""select * from spaces where space_id = '{space_id}'"""""")",1,cwe-089,,,,,
"def check(current_num):
    try:
        cursor.execute('SELECT * FROM comics WHERE num=""%s""' % current_num)
    except sqlite3.OperationalError:
        cursor.execute('CREATE TABLE comics (num text)')
        return False
    else:
        return False if cursor.fetchone() is None else True",1,cwe-089,,,,,
"@app.route('/delete_crawl', methods=['POST'])
@is_logged_in
def delete_crawl():

        # Get Form Fields
        cid = request.form['cid']

        # Create cursor
        cur = mysql.connection.cursor()

        # Get user by username
        result = cur.execute(""DELETE FROM Crawls WHERE cid = %s"" % cid)

        # Commit to DB
        mysql.connection.commit()

        # Close connection
        cur.close()

        # FIXME check if successfull first, return message
        flash('Crawl successfully removed', 'success')

        return redirect(url_for('dashboard'))",1,cwe-089,,,,,
"@app.route('/movies/add', methods=['GET', 'POST'])
def add_movie():
    form = MovieForm()
    if not form.validate_on_submit():
        return render_template('new_movie.html', title='Add New Movie', form=form)
    lang_id = add_language(form.data['language'])
    movie = {
            'title': '',
            'description': '',
            'release_year': 0,
            'rental_duration': 0,
            'rental_rate': 0.00,
            'length': 0,
            'replacement_cost': 0.00
        }
    for k, v in movie.items():
        movie[k] = form.data[k]
    movie['language_id'] = movie.get('language_id', lang_id)
    cur.execute(
        """"""
        INSERT INTO film (title, description, release_year, language_id, rental_duration, rental_rate, length, replacement_cost)
        VALUES ('{}', '{}', {}, {}, {}, {}, {}, {})
        """""".format(*[v for k, v in movie.items()])
    )
    try:
        cur.execute(f""SELECT * FROM film where fulltext @@ to_tsquery('Dark Knight')"")
        res = cur.fetchall()
        conn.commit()
        return redirect(url_for('movies'))
    except Exception as e:
        return redirect(url_for('index'))",1,cwe-089,,,,,
"def new_category(category_name):
    try:
        conn = check_heroku_db()
        cur = conn.cursor()
        cur.execute('''INSERT INTO categories (cat_name) VALUES (%s)''', (category_name,))
        conn.commit()
        conn.close()

    except psycopg2.DatabaseError as e:
        print('Error %s' % e)
        sys.exit(1)",1,cwe-089,,,,,
"def get_first_month(db, scene):
    sql = ""select date from matches where scene='{}' order by date limit 1;"".format(scene)
    res = db.exec(sql)
    date = res[0][0]
    return date",1,cwe-089,,,,,
"def getOptions(poll_name):
    conn, c = connectDB()
    options_str = queryOne(c, ""SELECT options FROM {} WHERE name='{}'"".format(CFG(""poll_table_name""), poll_name))
    if options_str == None:
        return None
    options = options_str.split("","")
    closeDB(conn)
    return options",1,cwe-089,,,,,
"def retrieve_last_video_position(playlist_id, db):
    db.execute(""SELECT max(position) as position from video WHERE playlist_id={playlist_id};"".format(
        playlist_id=playlist_id))
    row = db.fetchone()
    return row['position']",1,cwe-089,,,,,
"@app.route('/<page_name>/history')
def view_page_history(page_name):
    query = db.query(""select page_content.timestamp, page_content.id from page, page_content where page.id = page_content.page_id and page.page_name = '%s'"" % page_name)
    page_histories = query.namedresult()

    return render_template(
        'page_history.html',
        page_name = page_name,
        page_histories = page_histories
    )",1,cwe-089,,,,,
"    def add_input(self, data):
        connection = self.connects()
        try:
            # The following introduces a deliberate security flaw. See section on SQL injecton below
            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(
                data)
            with connection.cursor() as cursor:
                cursor.execute(query)
                connection.commit()
        finally:
            connection.close()",1,cwe-089,,,,,
"def get_top_author(top_num):
    """""" query the top(top_num) popular author
        top_num => list of [author, count]
    """"""
    cmd = """"""SELECT authors.name,author_result.num
                    FROM authors JOIN
                    (SELECT SUM(article_result.num) as num,
                    article_result.author
                    from (SELECT articles.title, articles.author,
                    SUM(log.views) AS num
                    FROM articles
                    INNER JOIN (
                    SELECT path, count(path) AS views
                    FROM log GROUP BY log.path
                    ) AS log ON log.path = '/article/'
                    || articles.slug
                    GROUP BY articles.title, articles.author)
                    AS article_result
                    GROUP BY article_result.author) as author_result
                    ON authors.id = author_result.author
                    ORDER BY num DESC LIMIT {}"""""".format(top_num)
    return execute_query(cmd)",1,cwe-089,,,,,
"@app.route('/get_all_referrers')
def get_all_referrers():
    account_id = request.args.get('account_id')

    if not isObject(account_id):
        ws.send('{""id"":1, ""method"":""call"", ""params"":[0,""lookup_account_names"",[[""' + account_id + '""], 0]]}')
        result_l = ws.recv()
        j_l = json.loads(result_l)

        account_id = j_l[""result""][0][""id""]

    con = psycopg2.connect(**config.POSTGRES)
    cur = con.cursor()

    query = ""select * from referrers where referrer='""+account_id+""'""
    cur.execute(query)
    results = cur.fetchall()

    return jsonify(results)",1,cwe-089,,,,,
"    def add_translationname(self, trname):
        """"""Add new translation by item name for an item.""""""
        if self.connection:
            for item in self.find_item_name([trname[0], '0']):
                self.cursor.execute('insert into itemtranslation (itemid, itemlanguageid, translation) values (""%s"", ""%s"", ""%s"")' % (item[0], trname[1], trname[2]))
            self.connection.commit()",1,cwe-089,,,,,
"    @staticmethod
    def get_max_task_id_for_project(project_id: int):
        """"""Gets the nights task id currently in use on a project""""""
        sql = """"""select max(id) from tasks where project_id = {0} GROUP BY project_id"""""".format(project_id)
        result = db.engine.execute(sql)
        if result.rowcount == 0:
            raise NotFound()
        for row in result:
            return row[0]",1,cwe-089,,,,,
"def findNPC(race, classe, sex,level):
	c, conn = getConnection()
	date = now()
	#select image, SUM(legit) as l FROM npc WHERE race='Elf' AND class='Bard' AND sex='Male' GROUP BY image HAVING l>5 ORDER BY SUM(legit) DESC;
	c.execute(""select image, avg(legit) as l FROM npc WHERE race='""+race+""' AND class='""+classe+""' AND sex='""+sex+""' GROUP BY image HAVING l > 5 ORDER BY SUM(legit) DESC;"")
	conn.commit()
	out = c.fetchmany(5)
	conn.close()
	return out",1,cwe-089,,,,,
"@mod.route('/edit/<int:msg_id>', methods=['GET', 'POST'])
def edit(msg_id):
    m = None
    if request.method == 'GET':
        sql = ""SELECT * FROM message where msg_id = %d;"" % (msg_id)
        cursor.execute(sql)
        m = cursor.fetchone()
        return render_template('message/edit.html', m=m, msg_id=msg_id)

    if request.method == 'POST':
        content = request.form['content']
        sql = ""UPDATE message SET content = '%s' where msg_id = '%d';"" \
            % (content, msg_id)
        cursor.execute(sql)
        conn.commit()
        flash('Edit Success!')
        return redirect(url_for('show_entries'))

    return render_template('message/edit.html', m=m, msg_id=msg_id)",1,cwe-089,,,,,
"    def add_input(self,data):
        connection = self.connect()

        try:
            query = ""INSERT INTO crimes (description) VALUES ('{}');"".format(data)
            with connection.cursor() as cursor:
                cursor.execute(query)
                connection.commit()
        finally:
            connection.close()",1,cwe-089,,,,,
"    def fetch_resultSet(self, session, id):
        self._openContainer(session)

        sid = str(id)
        if (self.idNormalizer is not None):
            sid = self.idNormalizer.process_string(session, sid)
        query = (""SELECT class, data FROM %s WHERE identifier = '%s';"" %
                 (self.table, sid)
                 )
        res = self._query(query)
        try:
            rdict = res.dictresult()[0]
        except IndexError:
            raise ObjectDoesNotExistException('%s/%s' % (self.id, sid))

        data = rdict['data']
        try:
            ndata = pg.unescape_bytea(data)
        except:
            # Insufficient PyGreSQL version
            ndata = data.replace(""\\'"", ""'"")

        ndata = ndata.replace('\\000', '\x00')
        ndata = ndata.replace('\\012', '\n')
        # data is res.dictresult()
        cl = rdict['class']
        rset = dynamic.buildObject(session, cl, [[]])
        rset.deserialize(session, ndata)
        rset.id = id

        # Update expires
        now = time.time()
        nowStr = time.strftime(""%Y-%m-%d %H:%M:%S"", time.gmtime(now))
        expires = now + self.get_default(session, 'expires', 600)
        rset.timeExpires = expires
        expiresStr = time.strftime(""%Y-%m-%d %H:%M:%S"", time.gmtime(expires))

        query = (""UPDATE %s SET timeAccessed = '%s', expires = '%s' ""
                 ""WHERE identifier = '%s';"" %
                 (self.table, nowStr, expiresStr, sid)
                 )
        self._query(query)
        return rset",1,cwe-089,,,,,
"def init_user(username, chat_id):
    conn = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\users\\"" + username + '.db')
    conn2 = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + '\\cf.db')
    cursor = conn.cursor()
    cursor2 = conn2.cursor()
    cursor.execute(""CREATE TABLE result (problem INTEGER, diff STRING, verdict STRING)"")
    cursor2.execute(""SELECT * FROM problems"")
    x = cursor2.fetchone()
    while x != None:
        cursor.execute(""insert into result values (?, ?, ? )"", (x[0], x[1], ""NULL""))
        x = cursor2.fetchone()

    url = 'http://codeforces.com/submissions/' + username
    r = requests.get(url)
    max_page = 1
    soup = BeautifulSoup(r.text, ""lxml"")

    for link in soup.find_all(attrs={""class"": ""page-index""}):
        s = link.find('a')
        s2 = s.get(""href"").split('/')
        max_page = max(max_page, int(s2[4]))

    old = """"
    r = requests.get('http://codeforces.com/submissions/' + username + '/page/0')
    soup = BeautifulSoup(r.text, ""lxml"")
    last_try = soup.find(attrs={""class"":""status-small""})
    if not last_try == None:
        last_try = str(last_try).split()
        last_try = str(last_try[2]) + str(last_try[3])

    for i in range(1, max_page + 1):
        r = requests.get('http://codeforces.com/submissions/' + username + '/page/' + str(i))
        soup = BeautifulSoup(r.text, ""lxml"")
        count = 0
        ver = soup.find_all(attrs={""class"": ""submissionVerdictWrapper""})
        for link in soup.find_all('a'):
            s = link.get('href')
            if s != None and s.find('/problemset') != -1:
                s = s.split('/')
                if len(s) == 5:
                    s2 = str(ver[count]).split()
                    s2 = s2[5].split('\""')
                    count += 1
                    cursor.execute(""select * from result where problem = '"" + s[3] + ""'and diff = '"" + s[4] + ""'"")
                    x = cursor.fetchone()
                    if s2[1] == 'OK' and x != None:
                        cursor.execute(""update result set verdict = '"" + s2[1] + ""' where problem = '"" + s[3] + ""' and diff = '"" + s[4] + ""'"")
                    if x != None and x[2] != 'OK':
                        cursor.execute(""update result set verdict = '"" + s2[1] +""' where problem = '"" + s[3] + ""' and diff = '"" + s[4] + ""'"")

    conn.commit()
    conn.close()
    conn2.close()

    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\settings.db"")
    conn = settings.cursor()
    conn.execute(""select * from last_update_problemset"")
    last_problem = conn.fetchone()
    conn.execute(""select * from users where chat_id = '"" + str(chat_id) + ""'"")
    x = conn.fetchone()
    if x == None:
        conn.execute(""insert into users values (?, ?, ?, ?, ?)"", (chat_id, username, str(last_try), str(last_problem[0]), 1))
    else:
        conn.execute(""update users set username = '"" + str(username) + ""' where chat_id = '"" + str(chat_id) + ""'"")
        conn.execute(""update users set last_update = '"" + str(last_try) + ""' where chat_id = '"" + str(chat_id) + ""'"")
        conn.execute(""update users set last_problem = '"" + str(last_problem[0]) + ""' where chat_id = '"" + str(chat_id) + ""'"")
        conn.execute(""update users set state = '"" + str(1) + ""' where chat_id = '"" + str(chat_id) + ""'"")
    settings.commit()
    settings.close()",1,cwe-089,,,,,
"def process_vote(target,action,chan,mask,db,notice,conn):
    if ' ' in target: 
        notice('Invalid nick')
        return

    try: votes2kick = database.get(db,'channels','votekick','chan',chan)
    except: votes2kick = 10
    try: votes2ban = database.get(db,'channels','voteban','chan',chan)
    except: votes2ban = 10

    if len(target) is 0:
        if action is 'kick': notice('Votes required to kick: {}'.format(votes2kick))
        elif action is 'ban': notice('Votes required to ban: {}'.format(votes2ban))
        return

    votefinished = False
    global db_ready
    if not db_ready: db_init(db)
    chan = chan.lower()
    target = target.lower()
    voter = user.format_hostmask(mask)
    voters = db.execute(""SELECT voters FROM votes where chan='{}' and action='{}' and target like '{}'"".format(chan,action,target)).fetchone()

    if conn.nick.lower() in target: return ""I dont think so Tim.""

    if voters: 
        voters = voters[0]
        if voter in voters: 
            notice(""You have already voted."")
            return
        else:
            voters = '{} {}'.format(voters,voter).strip()
            notice(""Thank you for your vote!"")
    else: 
        voters = voter

    votecount = len(voters.split(' '))

    if 'kick' in action: 
        votemax = int(votes2kick)
        if votecount >= votemax:
            votefinished = True
            conn.send(""KICK {} {} :{}"".format(chan, target, ""You have been voted off the island.""))
    if 'ban' in action:
        votemax = int(votes2ban)
        if votecount >= votemax:
            votefinished = True
            conn.send(""MODE {} +b {}"".format(chan, user.get_hostmask(target,db)))
            conn.send(""KICK {} {} :"".format(chan, target, ""You have been voted off the island.""))
    
    if votefinished: db.execute(""DELETE FROM votes where chan='{}' and action='{}' and target like '{}'"".format(chan,action,target))
    else: db.execute(""insert or replace into votes(chan, action, target, voters, time) values(?,?,?,?,?)"", (chan, action, target, voters, time.time()))
        
    db.commit()
    return (""Votes to {} {}: {}/{}"".format(action, target, votecount,votemax))",1,cwe-089,,,,,
"@mod.route('/like/<int:msg_id>', methods=['GET', 'POST'])
def like(msg_id):
    if request.method == 'GET':
        user_id = session['logged_id']
        c_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        sql = ""INSERT INTO like_msg(msg_id, user_id,c_time) "" + \
                ""VALUES(%d,'%s','%s');"" % (msg_id, user_id, c_time)
        cursor.execute(sql)
        conn.commit()
    return redirect(url_for('show_entries'))",1,cwe-089,,,,,
"    def tag_to_tag_num(self, tag):
        ''' Returns tag_num given tag. '''

        q = ""SELECT rowid FROM tags WHERE tag = '"" + tag + ""'""
        self.query(q)
        return self.c.fetchone()[0]",1,cwe-089,,,,,
"def update_history_and_sourcebyinstitution(conn, sqlite, k10plus, ai):
    """"""
    Get all current sources and title numbers from Solr and log them into database.
    """"""
    current_sources = get_all_current_sources(k10plus, ai)
    current_institutions = get_all_current_institutions(k10plus, ai)
    old_sourcebyinstitutions = get_all_old_sourcebyinstitutions(conn, sqlite)
    current_sourcebyinstitutions = []

    for source in current_sources:

        for institution in current_institutions:

            if not institution or institution == "" "" or '""' in institution:
                continue

            sourcebyinstitution = ""SID "" + str(source) + "" ("" + institution + "")""
            current_sourcebyinstitutions.append(sourcebyinstitution)

            params = {
                ""q"": 'source_id:%s AND institution:""%s""' % (source, institution),
                ""rows"": 0,
                ""wt"": ""json""
            }

            # check k10plus
            result = get_solr_result(k10plus, params)
            number = result[""response""][""numFound""]
            if number != 0:
                sql = 'INSERT INTO history (sourcebyinstitution, titles) VALUES (""%s"", %s)' % (sourcebyinstitution, number)
                sqlite.execute(sql)
                conn.commit()
            else:
                # check ai
                result = get_solr_result(ai, params)
                number = result[""response""][""numFound""]
                if number != 0:
                    # TODO: escape via sqlite
                    sql = 'INSERT INTO history (sourcebyinstitution, titles) VALUES (""%s"", %s)' % (sourcebyinstitution, number)
                    sqlite.execute(sql)
                    conn.commit()

            if sourcebyinstitution not in old_sourcebyinstitutions:
                logging.info(""The %s is now connected to SID %s."", institution, source)
                sql = ""INSERT INTO sourcebyinstitution (sourcebyinstitution) VALUES ('%s')"" % sourcebyinstitution
                sqlite.execute(sql)
                conn.commit()

            if number != 0:
                old_sourcebyinstitution_number = get_old_sourcebyinstitution_number(conn, sqlite, sourcebyinstitution)
                if number < old_sourcebyinstitution_number:
                    message = ""Die Anzahl der Titel hat sich bei %s gegenueber einem frueheren Import verringert."" % (sourcebyinstitution)
                    send_message(message)

            # requests.exceptions.ConnectionError: HTTPConnectionPool(XXXXXX): Max retries exceeded
            time.sleep(0.25)

    for old_sourcebyinstitution in old_sourcebyinstitutions:
        if old_sourcebyinstitution not in current_sourcebyinstitutions:
            message = ""Die %s ist nicht laenger für die SID %s angesigelt."" % (institution, source)
            send_message(message)",1,cwe-089,,,,,
"    def change_message(self, new_message, logged_user):
        update_sql = """"""
            UPDATE Clients
            SET message = '{}'
            WHERE client_id = '{}'
        """""".format(new_message, logged_user.get_client_id())

        cursor = self.__conn.cursor()

        cursor.execute(update_sql)
        self.__conn.commit()
        logged_user.set_message(new_message)",1,cwe-089,,,,,
"    def create_event(self, title, start_time, time_zone, server_id, description):
        sql = """"""INSERT INTO events (title, start_time, time_zone, server_id, description)
                 VALUES ('{0}', '{1}', '{2}', '{3}', '{4}')
                 """""".format(title, start_time, time_zone, server_id, description)
        self.cur.execute(sql)
        self.conn.commit()",1,cwe-089,,,,,
"@bot.message_handler(func = lambda message: get_current_state(message.chat.id) == config.States.S_LOGIN.value)
def get_login2(message):
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\bases\\settings.db"")
    conn = settings.cursor()
    if bases.createuserbase.check_username(message.text):
        bot.send_message(message.chat.id, ""Invalid handle."")
        set_state(message.chat.id, config.States.S_START.value)
        return 0

    conn.execute(""select * from users where chat_id = '"" + str(message.chat.id) + ""'"")
    name = conn.fetchone()
    settings.close()
    bases.update.cf_update()
    bases.createuserbase.clean_base(name[1])
    bases.createuserbase.clean_base(message.text)
    bot.send_message(message.chat.id, ""Creating base..."")
    bases.createuserbase.init_user(message.text, message.chat.id)
    bot.send_message(message.chat.id, ""Done!"")
    set_state(message.chat.id, config.States.S_START.value)",1,cwe-089,,,,,
"def get_bracket_graph_data(db, tag):
    # First, we have to find out which scenes this player has brackets in
    sql = ""SELECT DISTINCT scene FROM ranks WHERE player='{}'"".format(tag)
    scenes = db.exec(sql)
    scenes = [s[0] for s in scenes]

    bracket_placings_by_scene = {s: get_bracket_placings_in_scene(db, s, tag) for s in scenes}

    return bracket_placings_by_scene",1,cwe-089,,,,,
"    def get(self, email):
        """""" Fetch data for admin with the corresponding email """"""
        return database_utilities.execute_query(f""""""select * from admins where email = '{email}'"""""")",1,cwe-089,,,,,
"def insertUsage(user, command):
	c, conn = getConnection()
	date = now()
	c.execute(""INSERT INTO usage (date,user,command) VALUES ('""+date+""','""+str(user)+""','""+command+""')"")
	conn.commit()
	conn.close()",1,cwe-089,,,,,
"    def verify_email(self, member):
        query = ""SELECT COUNT(email) FROM members WHERE email = '{email}'"".format(email = member)
        self.cursor.execute(query)
        result = self.cursor.fetchone()
        if (int(result[0]) > 0):
            return True 
        else:
            return False",1,cwe-089,,,,,
"    def get_previous_yields(self, inverter_serial):
        query = '''
           SELECT TimeStamp, EToday, ETotal
           FROM Inverters
           WHERE Serial = '%s'
        ''' % (inverter_serial)
        self.c.execute(query)
        data = self.c.fetchone()
        return data[0], data[1], data[2]",1,cwe-089,,,,,
"@app.route('/referrer_count')
def referrer_count():
    account_id = request.args.get('account_id')

    if not isObject(account_id):
        ws.send('{""id"":1, ""method"":""call"", ""params"":[0,""lookup_account_names"",[[""' + account_id + '""], 0]]}')
        result_l = ws.recv()
        j_l = json.loads(result_l)

        account_id = j_l[""result""][0][""id""]

    con = psycopg2.connect(**config.POSTGRES)
    cur = con.cursor()

    query = ""select count(*) from referrers where referrer='""+account_id+""'""
    cur.execute(query)
    results = cur.fetchone()

    return jsonify(results)",1,cwe-089,,,,,
"    def analyze_scene(self, scene):
        base_urls = scene.get_base_urls()
        users = scene.get_users()
        name = scene.get_name()
        LOG.info('found the following users for scene {}: {}'.format(name, users))

        # This scene might have one user who always posts the brackets on their challonge account
        for user in users:
            # Have we analyzed this user before?
            sql = ""SELECT * FROM user_analyzed WHERE user='{}';"".format(user)
            results = self.db.exec(sql)

            # Did we have any matches in the database?
            if len(results) > 0:
                # We have analyzed this user before. Just grab one page of brackets to see if there have been any new tournaments
                # eg, just look at /users/christmasmike?page=1 instead of all the pages that exist
                most_recent_page = bracket_utils.get_brackets_from_user(user, pages=1)
                for bracket in most_recent_page:
                    LOG.info('here are the brackets from the most recent page of user {}: {}'.format(user, most_recent_page))
                    # This user has already been analyzed, there's a good chance this bracket has been analyzed also
                    sql = ""SELECT * FROM user_analyzed WHERE url='{}' AND user='{}';"".format(bracket, user)
                    results = self.db.exec(sql)

                    if len(results) == 0:
                        # This is a new bracket that must have been published in the last hour or so
                        LOG.info('found this url from a user: {} {}'.format(bracket, user))
                        display_name = bracket_utils.get_display_base(bracket)
                        # We don't care about doubles tournaments
                        if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():
                            LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))
                            continue

                        self.data_processor.process(bracket, name, display_name)

                        # mark this bracket as analyzed
                        sql = ""INSERT INTO user_analyzed (url, user, scene) VALUES ('{}', '{}', '{}');"".format(bracket, user, name)
                        self.db.exec(sql)

                        # Tweet that we found a new bracket
                        msg = ""Found new {} bracket: {}"".format(name, bracket)
                        tweet(msg)
                    else:
                        LOG.info('url {} is not new for user {}'.format(bracket, user))
            else:
                # This is a new user, analyze all brackets
                user_urls = bracket_utils.get_brackets_from_user(user)
                for url in user_urls:
                    LOG.info('found this url from a user: {} {}'.format(url, user))
                    display_name = bracket_utils.get_display_base(url)
                    # We don't care about doubles tournaments
                    if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():
                        LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))
                        continue

                    self.data_processor.process(url, name, display_name)

                    # mark this bracket as analyzed
                    sql = ""INSERT INTO user_analyzed (url, user, scene) VALUES ('{}', '{}', '{}');"".format(url, user, name)
                    self.db.exec(sql)

                LOG.info('done with user {}'.format(user))


        # This scene might always call their brackets the same thing, eg weekly1, weekly2, weekly3 etc
        for base_url in base_urls:
            # attempt to load this data from the database
            LOG.info('About to start this analysis thread for scene {}'.format(scene.get_name()))
            sql = ""SELECT first,last FROM valids WHERE base_url = '"" + str(base_url) + ""';""
            result = self.db.exec(sql)
            has_results = len(result) > 0 

            # Did we find a match in the database?
            if has_results:
                LOG.info(""validURLs found values in the database"" + str(result))
                first = result[0][0]
                last = result[0][1]

                # Check for a new valid URL
                new_last = bracket_utils._get_last_valid_url(base_url, last-1)

                if not new_last == last:
                    if new_last - last > 5:
                        with open(""DEBUGOUTPUT.txt"", 'a') as f:
                            f.write(""[validURLs.py:55]: found a SHIT TON of new tournaments for bracket: {}"".format(base_url))

                    else:
                        bracket = base_url.replace('###', str(new_last))
                        LOG.info('Found new bracket: {}'.format(bracket))
                        msg = ""Found new bracket: {}"".format(bracket)
                        tweet(msg)

                    # If there's been a new last, update the database
                    sql = ""UPDATE valids SET last="" + str(new_last) + "" where base_url = '""+str(base_url)+""';""
                    self.db.exec(sql)


                    # Analyze each of these new brackets
                    for i in range(last+1, new_last+1):
                        # Since this URL is new, we have to process the data
                        bracket = base_url.replace('###', str(i))
                        # Create the display name for this bracket
                        # Eg challonge.com/NP9ATX54 -> NP9 54
                        display_name = bracket_utils.get_display_base(bracket, counter=i)
                        # We don't care about doubles tournaments
                        if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():
                            LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))
                            continue

                        self.data_processor.process(bracket, name, display_name, new_bracket=True)

            else:
                # We need to create first and last from scratch
                first = bracket_utils._get_first_valid_url(base_url)
                last = bracket_utils._get_last_valid_url(base_url, first)

                # This is new data, we need to put it into the db
                sql = ""INSERT INTO valids (base_url, first, last, scene) VALUES (""
                sql += ""'""+str(base_url)+""', ""+str(first)+ "", ""+str(last)+"", '""+str(name)+""');""
                self.db.exec(sql)

                for i in range(first, last+1):
                    bracket = base_url.replace('###', str(i))
                    # Create the display name for this bracket
                    # Eg challonge.com/NP9ATX54 -> NP9 54
                    display_name = bracket_utils.get_display_base(bracket, counter=i)
                    # We don't care about doubles tournaments
                    if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():
                        LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))
                        continue

                    self.data_processor.process(bracket, name, display_name)

                    # Calculate ranks after each tournament so we can see how players are progressing
        if not analyzed_scenes and should_tweet:
            tweet('About to start ranking for scene {}'.format(name))
        self.data_processor.check_and_update_ranks(name)",1,cwe-089,,,,,
"def get_article(index):
    with conn.cursor(cursor_factory=DictCursor) as cur:
        query = ""SELECT * FROM articles WHERE index=""+str(index)
        cur.execute(query)
        article = cur.fetchone()
        return article",1,cwe-089,,,,,
"def create_cf_base():
    url = 'http://codeforces.com/problemset/'
    r = requests.get(url)
    max_page = 0
    soup = BeautifulSoup(r.text, ""lxml"")
    base = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\cf.db"")
    conn = base.cursor()
    conn.execute(""create table problems (problem INTEGER, diff CHAR)"")
    for i in available_tags:
        conn.execute(""create table "" + i + "" (problems INTEGER, diff CHAR)"")

    for link in soup.find_all(attrs={""class"" : ""page-index""}):
        s = link.find('a')
        s2 = s.get(""href"").split('/')
        max_page = max(max_page, int(s2[3]))

    a = 0
    b = 0
    f = False
    for i in range(1, max_page + 1):
        r = requests.get('http://codeforces.com/problemset/' + '/page/' + str(i))
        soup = BeautifulSoup(r.text, ""lxml"")
        old = ''
        for link in soup.find_all('a'):
            s = link.get('href')
            if s != None and s.find('/problemset') != -1:
                s = s.split('/')
                if len(s) == 5 and old != s[3] + s[4]:
                    a = s[3]
                    b = s[4]
                    old = s[3] + s[4]
                    if not f:
                        f = True
                        last_update = old
                    conn.execute(""insert into problems values (?, ?)"", (a, b))
                if len(s) == 4 and s[3] in available_tags:
                    conn.execute(""insert into "" + s[3] + "" values (?, ?)"", (a, b))

    base.commit()
    base.close()
    settings = sqlite3.connect(os.path.abspath(os.path.dirname(__file__)) + ""\\settings.db"")
    conn = settings.cursor()
    conn.execute(""create table users (chat_id INTEGER, username STRING, last_update STRING, last_problem STRING, state INTEGER)"")
    conn.execute(""create table last_update_problemset (problem STRING)"")
    conn.execute(""insert into last_update_problemset values (?)"", (last_update, ))
    settings.commit()
    settings.close()",1,cwe-089,,,,,
"def closeGame(ID):
	db.execute(""UPDATE games set Running = 'No' WHERE ID = %i"" % ID)
	database.commit()",1,cwe-089,,,,,
"    def cancelFollow(self,userid,friendid):
        sqlText=""delete from friends where userid=%d and friendid=%d;""%(userid,friendid)
        result=sql.deleteDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"    def change_pass(self, new_pass, logged_user):
        update_sql = """"""
            UPDATE Clients
            SET password = '{}'
            WHERE client_id = '{}'
        """""".format(new_pass, logged_user.get_client_id())

        cursor = self.__conn.cursor()

        cursor.execute(update_sql)
        self.__conn.commit()",1,cwe-089,,,,,
"    def getCommentsByPostid(self,postid,userid):
        sqlText=""select (select Count(*) from comment_like where comments.commentid = comment_like.commentid) as like,(select Count(*) from comment_like where comments.commentid = comment_like.commentid and comment_like.userid=%d) as flag,commentid,name,comment from users,comments where users.userid=comments.userid and postid=%d order by date desc;""%(userid,postid)
        result=sql.queryDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"        def callback(recipeName):
            menu.pack_forget()
            viewRecipeFrame.pack(expand=True, fill='both')
            groceryButton.pack_forget()
            database_file = ""meal_planner.db""
            print(recipeName)
            with sqlite3.connect(database_file) as conn:
                cursor = conn.cursor()
                selection = cursor.execute(""""""SELECT * FROM recipe WHERE name = """""" + ""\"""" + recipeName + ""\"""")
                for result in [selection]:
                    for row in result.fetchall():
                        name = row[0]
                        time = row[1]
                        servings = row[2]
                        ingredients = row[4]
                        directions = row[5]

                        string = (""Name: {} \n Cook time: {} \n Number of Servings: {} \n "".format(name, time, servings))
                        secondString = (""Ingredients: {}"".format(ingredients))
                        thirdString = (""Directions: {}"".format(directions))
            Label(viewRecipeFrame, text=string, font=MEDIUM_FONT, bg=""#f8f8f8"", fg=""#000000"").pack(side=TOP)
            Label(viewRecipeFrame, text=secondString, font=MEDIUM_FONT, bg=""#f8f8f8"", fg=""#000000"").pack(side=TOP)
            Label(viewRecipeFrame, text=thirdString, font=MEDIUM_FONT, bg=""#f8f8f8"", fg=""#000000"").pack(side=TOP)
            returnButton = Button(menuFrame, text = ""Return to Menu"", highlightbackground=""#e7e7e7"", command=lambda: [viewRecipeFrame.pack_forget(),
                                                                                     menu.pack(), returnButton.pack_forget(), label.configure(text=""Meal Planer""),
                                                                                    groceryButton.pack(side=RIGHT)])
            returnButton.pack(side=RIGHT)",1,cwe-089,,,,,
"    @jwt_required
    def patch(self, user_id):
        """""" Replaces information of corresponding user_id with request body """"""
        query = f""""""update users set user_id = %s """"""
        query += f""""""where user_id = '{user_id}'""""""
        json_data = request.get_json()
        parameters = (json_data['user_id'], )
        database_utilities.execute_query(query, parameters)",1,cwe-089,,,,,
"@mod.route('/edit', methods=['GET', 'POST'])
def edit():
    sql = ""SELECT * FROM users where email = '%s';"" % (session['logged_email'])
    cursor.execute(sql)
    u = cursor.fetchone()
    if request.method == 'POST':
        sql = ""UPDATE users SET nickname = '%s' where email = '%s'"" \
        % (request.form['nickname'], session['logged_email'])
        cursor.execute(sql)
        sql = ""SELECT * FROM users where email = '%s';"" \
            % (session['logged_email'])
        cursor.execute(sql)
        u = cursor.fetchone()
        conn.commit()
        flash('Edit Nickname Success!')
    return render_template('users/edit.html', u=u)",1,cwe-089,,,,,
"def shame_add(name):
    shame = shame_ask(name)
    db = db_connect()
    cursor = db.cursor()
    if shame is None:
        try:
            cursor.execute('''
                INSERT INTO people(name,karma,shame) VALUES('{}',0,1)
                '''.format(name))
            db.commit()
            logger.debug('Inserted into karmadb 1 shame for {}'.format(name))
            db.close()
            return 1
        except Exception as e:
            logger.error('Execution failed with error: {}'.format(e))
            raise

    else:
        shame = shame + 1
        try:
            cursor.execute('''
                UPDATE people SET shame = {0} WHERE name = '{1}'
                '''.format(shame, name))
            db.commit()
            logger.debug('Inserted into karmadb {} shame for {}'.format(
                shame, name))
            db.close()
            return shame
        except Exception as e:
            logger.error('Execution failed with error: {}'.format(e))
            raise",1,cwe-089,,,,,
"    def can_user_pass_that_amount_of_money(self, user_id, money):
        self.cursor.execute(""SELECT count(id) FROM kickstarter.users where id = %s and money >= %s"" % (user_id, money))
        return self.cursor.fetchall()[0][0]",1,cwe-089,,,,,
"@endpoints.route(""/placings"")
def placings():
    if db == None:
        init()

    tag = request.args.get('tag', default='christmas mike')

    # Get all the urls that this player has participated in
    sql = ""SELECT * FROM placings WHERE player = '{}'"".format(tag)
    results = list(db.exec(sql))
    results.sort(key=lambda x: int(x[2]))

    return json.dumps(results)",1,cwe-089,,,,,
"def markTokenUsedExternal(token, optStr=""""):
    conn, c = connectDB()
    req = ""UPDATE {} SET \""options_selected\""='{}' WHERE token='{}'"".format(CFG(""tokens_table_name""), \
                    optStr, token)
    c.execute(req)
    closeDB(conn)",1,cwe-089,,,,,
"    def get_roster(self, server_id):
        sql = """"""SELECT username, role
                 FROM roles
                 WHERE roles.server_id = {0};
                 """""".format(server_id)
        self.cur.execute(sql)
        return self.cur.fetchall()",1,cwe-089,,,,,
"def retrieve_video(id, playlist_id, db):
    db.execute(""SELECT id, position from video WHERE id={id} and playlist_id={playlist_id};"".format(
        id=id, playlist_id=playlist_id))
    row = db.fetchone()
    return row",1,cwe-089,,,,,
"    def followFriends(self,userid,friendid):
        sqlText=""insert into friends values(%d,%d);""%(friendid,userid)
        result=sql.insertDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"def getGameID(ID):
	db.execute(""SELECT * FROM games WHERE ID = %i"" % ID)
	ID = db.fetchone()
	return ID",1,cwe-089,,,,,
"@app.route('/top_proxies')
def top_proxies():
    con = psycopg2.connect(**config.POSTGRES)
    cur = con.cursor()

    query = ""SELECT sum(amount) FROM holders""
    cur.execute(query)
    total = cur.fetchone()
    total_votes = total[0]

    query = ""SELECT voting_as FROM holders WHERE voting_as<>'1.2.5' group by voting_as""
    cur.execute(query)
    results = cur.fetchall()
    #con.close()

    proxies = []

    for p in range(0, len(results)):

        proxy_line = [0] * 5

        proxy_id = results[p][0]
        proxy_line[0] = proxy_id

        query = ""SELECT account_name, amount FROM holders WHERE account_id='""+proxy_id+""' LIMIT 1""
        cur.execute(query)
        proxy = cur.fetchone()

        try:
            proxy_name = proxy[0]
            proxy_amount = proxy[1]
        except:
            proxy_name = ""unknown""
            proxy_amount = 0


        proxy_line[1] = proxy_name

        query = ""SELECT amount, account_id FROM holders WHERE voting_as='""+proxy_id+""'""
        cur.execute(query)
        results2 = cur.fetchall()

        proxy_line[2] = int(proxy_amount)

        for p2 in range(0, len(results2)):
            amount = results2[p2][0]
            account_id = results2[p2][1]
            proxy_line[2] = proxy_line[2] + int(amount)  # total proxy votes
            proxy_line[3] = proxy_line[3] + 1       # followers

        if proxy_line[3] > 2:
            percentage = float(float(proxy_line[2]) * 100.0/ float(total_votes))
            proxy_line[4] = percentage
            proxies.append(proxy_line)

    con.close()

    proxies = sorted(proxies, key=lambda k: int(k[2]))
    r_proxies = proxies[::-1]

    return jsonify(filter(None, r_proxies))",1,cwe-089,,,,,
"    def userLogin(self):

        sqlName=""select count(*) from users where name='%s' and \
                password='%s';""%(self.name,self.password)
        checkName=sql.queryDB(self.conn,sqlName)

        result=checkName[0][0]
        if result == 0:
            self.clean()
            return False
        else:
            return True",1,cwe-089,,,,,
"@app.route(""/search"", methods = [""POST""])
def search_pages():
    search = request.form.get(""search"")
    page = db.query(""select title from page where title = '%s'"" % search).namedresult()
    if len(page) == 0:
        return redirect(""/%s"" % search)
    else:
        return place_holder(search)",1,cwe-089,,,,,
"def get_articles_by_subject(subject):
    with conn.cursor(cursor_factory=DictCursor) as cur:
        query = ""SELECT * FROM articles WHERE subject='"" + subject + ""' ORDER BY last_submitted DESC""
        cur.execute(query)
        articles = cur.fetchall()
        return articles",1,cwe-089,,,,,
"    def getQueue(self, numberOfLinks=10):
        self.cursor.execute(""SELECT url FROM queue WHERE visited = '0' LIMIT {};"".format(numberOfLinks))
        result = self.cursor.fetchall()
        self.remove(result)
        return result",1,cwe-089,,,,,
"@hook.command(autohelp=False)
def showPoll(pollID, db=None):
    """"""Shows the answers for a given poll.""""""
    if not db_ready: db_init(db)
    if pollID == None:
        poll = db.execute(""SELECT pollID, question FROM polls WHERE active = 1"")
        if len(poll) == 0:
            reply(""There's no poll open."")
            return
    else:
        poll = db.execute(""SELECT pollID, question FROM polls WHERE pollID = '{}'"".format(pollID))
        if len(poll) == 0:
            reply(""No such poll found."")
            return
    pollID = poll[0][0]
    question = poll[0][1]
    reply(question)
    for (index, answer, votes) in db.execute(""SELECT 'index', answer, count(voteID) FROM answers LEFT JOIN votes ON votes.answerID = answers.answerID WHERE pollID = {} GROUP BY answers.answerID, 'index', answer ORDER BY 'index' ASC"".format(pollID, )):
        reply(""%s. %s (%s)"" % (index, answer, votes))",1,cwe-089,,,,,
"    def process_ranks(self, scene, urls, recent_date):
        PLAYER1 = 0
        PLAYER2 = 1
        WINNER = 2
        DATE = 3
        SCENE = 4

        # make sure if we already have calculated ranks for these players at this time, we do not do it again
        sql = ""SELECT * FROM ranks WHERE scene = '{}' AND date='{}';"".format(str(scene), recent_date)
        res = self.db.exec(sql)
        if len(res) > 0:
            LOG.info('We have already calculated ranks for {} on date {}. SKipping'.format(scene, recent_date))
            return

        matches = bracket_utils.get_matches_from_urls(self.db, urls)
        LOG.info('About to start processing ranks for scene {} on {}'.format(scene, recent_date))

        # Iterate through each match, and build up our dict
        win_loss_dict = {}
        for match in matches:
            p1 = match[PLAYER1]
            p2 = match[PLAYER2]
            winner = match[WINNER]
            date = match[DATE]

            #Add p1 to the dict
            if p1 not in win_loss_dict:
                win_loss_dict[p1] = {}

            if p2 not in win_loss_dict[p1]:
                win_loss_dict[p1][p2] = []

            # Add an entry to represent this match to p1
            win_loss_dict[p1][p2].append((date, winner == p1))

            # add p2 to the dict
            if p2 not in win_loss_dict:
                win_loss_dict[p2] = {}

            if p1 not in win_loss_dict[p2]:
                win_loss_dict[p2][p1] = []

            win_loss_dict[p2][p1].append((date, winner == p2))

        ranks = get_ranks(win_loss_dict)

        tag_rank_map = {}
        for i, x in enumerate(ranks):
            points, player = x
            rank = len(ranks) - i

            sql = ""INSERT INTO ranks (scene, player, rank, points, date) VALUES ('{}', '{}', '{}', '{}', '{}');""\
                    .format(str(scene), str(player), int(rank), str(points), str(recent_date))
            self.db.exec(sql)

            # Only count this player if this is the scene he/she belongs to
            sql = ""SELECT scene FROM players WHERE tag='{}';"".format(player)
            res = self.db.exec(sql)

            if len(res) == 0 or res[0][0] == scene:
                # Also create a list to update the player web
                map = {'rank':rank, 'total_ranked':len(ranks)}
                tag_rank_map[player] = map

        player_web.update_ranks(tag_rank_map)",1,cwe-089,,,,,
"    def analyze_smashgg(self, urls, name):
        LOG.info('we are about to analyze scene {} with {} brackets'.format(name, len(urls)))
        for url in urls:
            # Before we process this URL, check to see if we already have
            sql = ""SELECT * FROM analyzed where base_url='{}'"".format(url)
            res = self.db.exec(sql)
            if len(res) == 0:

                display_name = bracket_utils.get_display_base(url)

                # We don't care about doubles tournaments
                if 'doubles' in display_name.lower() or 'dubs' in display_name.lower():
                    LOG.info('We are skipping the tournament {} because it is a doubles tournament'.format(display_name))
                    continue

                LOG.info('About to process pro bracket {}'.format(url))
                self.data_processor.process(url, name, display_name)
            else:
                LOG.info(""Skpping pro bracket because it has already been analyzed: {}"".format(url))",1,cwe-089,,,,,
"@mod.route('/test', methods=['GET', 'POST'])
def test():
    user_id = session['logged_id']
    sql = 'SELECT * FROM message where user_id = %d ORDER BY c_time DESC' \
        % (user_id)
    cursor.execute(sql)
    m = cursor.fetchall()
    print(m)",1,cwe-089,,,,,
"    @staticmethod
    def get_last_active_users(limit):
        """"""
        Get from the database a tuple of users who have been recently using
        the bot
        :param limit: integer that specifies how much users to get
        :return: tuple of tuples with users info
        """"""
        log.info('Evaluating last active users with date of '
                 'last time when they used bot...')

        # From photo_queries_table2 we take chat_id of the last
        # active users and from 'users' table we take info about these
        # users by chat_id which is a foreign key
        query = ('SELECT p.chat_id, u.first_name, u.nickname, u.last_name, '
                 'u.language '
                 'FROM photo_queries_table2 p '
                 'INNER JOIN users u '
                 'ON p.chat_id = u.chat_id '
                 'GROUP BY u.chat_id, u.first_name, u.nickname, u.last_name, '
                 'u.language '
                 'ORDER BY MAX(time)'
                 f'DESC LIMIT {limit}')

        try:
            cursor = db.execute_query(query)
        except DatabaseConnectionError:
            log.error(""Cannot get the last active users because of some ""
                      ""problems with the database"")
            raise

        last_active_users = cursor.fetchall()
        return last_active_users",1,cwe-089,,,,,
"    def on_save(self):
        connection = get_connection()
        cursor = connection.cursor()
        cursor.execute(
            f""insert into visitors (ip_address, user_agent, referrer, full_path, visit_time) values ('{self.ip_address}', '{self.user_agent}', '{self.referrer}', '{self.full_path}', '{self.visit_time}');"")
        connection.commit()
        connection.close()
        return 0",1,cwe-089,,,,,
"def update_institutions(conn, sqlite, k10plus, ai):
    """"""
    Update the institution table.
    """"""
    current_institutions = get_all_current_institutions(k10plus, ai)
    old_institutions = get_all_old_institutions(conn, sqlite)

    # Check if the institution table is allready filled and this is not the first checkup
    institution_table_is_filled = len(old_institutions) > 10

    for old_institution in old_institutions:
        if institution_table_is_filled and old_institution not in current_institutions:
            message = ""Die ISIL %s ist im aktuellen Import nicht mehr vorhanden.\nWenn dies beabsichtigt ist, bitte die Institution aus der Datenbank loeschen."" % old_institution
            send_message(message)

    for current_institution in current_institutions:
        if current_institution == "" "" or '""' in current_institution:
                continue
        if current_institution not in old_institutions:
            message = ""The institution %s is new in Solr."" % current_institution
            if institution_table_is_filled:
                send_message(message)
            else:
                logging.info(message)
            sql = ""INSERT INTO institution (institution) VALUES ('%s')"" % current_institution
            sqlite.execute(sql)
            conn.commit()",1,cwe-089,,,,,
"    @staticmethod
    def _add_to_db(user):
        """"""
        Adds User object to the database
        :param user: User object with info about user
        :return: None
        """"""
        query = (""INSERT INTO users (chat_id, first_name, nickname, ""
                 ""last_name, language) ""
                 f""VALUES ({user.chat_id}, '{user.first_name}', ""
                 f""'{user.nickname}', '{user.last_name}', '{user.language}')"")
        try:
            db.add(query)
        except DatabaseError:
            log.error(""Cannot add user to the database"")
        else:
            log.info(f""User {user} was successfully added to the users db"")",1,cwe-089,,,,,
"    def deletePost(self,postid):
        sqlText=""delete from post where post.postid=%d""%(postid)
        result=sql.deleteDB(self.conn,sqlText)
        return result;",1,cwe-089,,,,,
"@app.route('/sloka')
def sloka():

    sloka_number = request.args.get('sloka_number')

    sloka_number_parts = sloka_number.split('.')

    sloka_number_previous = ""%s.%s.%d"" % (sloka_number_parts[0], sloka_number_parts[1], int(sloka_number_parts[2])-1)
    sloka_number_next = ""%s.%s.%d"" % (sloka_number_parts[0], sloka_number_parts[1], int(sloka_number_parts[2])+1)

    try:
        with sql.connect('amara.db') as con:
            con.row_factory = sql.Row
            cur = con.cursor()
            cur.execute(""select * from mula where sloka_number = '%s' order by sloka_line;"" % sloka_number)
            mula = cur.fetchall();

            cur.execute(""select * from pada where sloka_number = '%s' order by id;"" % sloka_number)
            pada = cur.fetchall();

            varga = """"
            if len(pada) > 0:
                varga = pada[0][""varga""]

            return render_template('sloka.html', mula=mula, pada=pada, varga=varga, sloka_number=sloka_number, sloka_number_previous=sloka_number_previous, sloka_number_next=sloka_number_next)
    finally:
        con.close()",1,cwe-089,,,,,
"  def update_title(self, title = None):
    if (not self.title):
      self.title = title

    # This will fall to a sql injection 
    sql = ""UPDATE jdk_entries SET title = '"" + self.title + ""'"" + \
          ""WHERE jdk_entries.id = '"" + self.entry_id + ""';"" 

    db_execute(sql)
    
    self.update_date_modified()

    return None",1,cwe-089,,,,,
"    def add_language(self, language):
        """"""""Add new language for item translations.""""""
        if self.connection:
            self.cursor.execute('insert into itemlanguage (language) values (""%s"")' % language[0])
            self.connection.commit()",1,cwe-089,,,,,
